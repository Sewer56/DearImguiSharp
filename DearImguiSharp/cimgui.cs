// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace DearImguiSharp
{
    public enum VkSystemAllocationScope
    {
        VK_SYSTEM_ALLOCATION_SCOPE_COMMAND = 0,
        VK_SYSTEM_ALLOCATION_SCOPE_OBJECT = 1,
        VK_SYSTEM_ALLOCATION_SCOPE_CACHE = 2,
        VK_SYSTEM_ALLOCATION_SCOPE_DEVICE = 3,
        VK_SYSTEM_ALLOCATION_SCOPE_INSTANCE = 4,
        VK_SYSTEM_ALLOCATION_SCOPE_MAX_ENUM = 2147483647
    }

    public enum VkInternalAllocationType
    {
        VK_INTERNAL_ALLOCATION_TYPE_EXECUTABLE = 0,
        VK_INTERNAL_ALLOCATION_TYPE_MAX_ENUM = 2147483647
    }

    public enum VkImageLayout
    {
        VK_IMAGE_LAYOUT_UNDEFINED = 0,
        VK_IMAGE_LAYOUT_GENERAL = 1,
        VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL = 2,
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_ATTACHMENT_OPTIMAL = 3,
        VK_IMAGE_LAYOUT_DEPTH_STENCIL_READ_ONLY_OPTIMAL = 4,
        VK_IMAGE_LAYOUT_SHADER_READ_ONLY_OPTIMAL = 5,
        VK_IMAGE_LAYOUT_TRANSFER_SRC_OPTIMAL = 6,
        VK_IMAGE_LAYOUT_TRANSFER_DST_OPTIMAL = 7,
        VK_IMAGE_LAYOUT_PREINITIALIZED = 8,
        VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL = 1000117000,
        VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL = 1000117001,
        VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL = 1000241000,
        VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL = 1000241001,
        VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL = 1000241002,
        VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL = 1000241003,
        VK_IMAGE_LAYOUT_PRESENT_SRC_KHR = 1000001002,
        VK_IMAGE_LAYOUT_SHARED_PRESENT_KHR = 1000111000,
        VK_IMAGE_LAYOUT_FRAGMENT_DENSITY_MAP_OPTIMAL_EXT = 1000218000,
        VK_IMAGE_LAYOUT_FRAGMENT_SHADING_RATE_ATTACHMENT_OPTIMAL_KHR = 1000164003,
        VK_IMAGE_LAYOUT_READ_ONLY_OPTIMAL_KHR = 1000314000,
        VK_IMAGE_LAYOUT_ATTACHMENT_OPTIMAL_KHR = 1000314001,
        VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000117000,
        VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000117001,
        VK_IMAGE_LAYOUT_SHADING_RATE_OPTIMAL_NV = 1000164003,
        VK_IMAGE_LAYOUT_DEPTH_ATTACHMENT_OPTIMAL_KHR = 1000241000,
        VK_IMAGE_LAYOUT_DEPTH_READ_ONLY_OPTIMAL_KHR = 1000241001,
        VK_IMAGE_LAYOUT_STENCIL_ATTACHMENT_OPTIMAL_KHR = 1000241002,
        VK_IMAGE_LAYOUT_STENCIL_READ_ONLY_OPTIMAL_KHR = 1000241003,
        VK_IMAGE_LAYOUT_MAX_ENUM = 2147483647
    }

    public enum VkFormat
    {
        VK_FORMAT_UNDEFINED = 0,
        VK_FORMAT_R4G4UNORM_PACK8 = 1,
        VK_FORMAT_R4G4B4A4UNORM_PACK16 = 2,
        VK_FORMAT_B4G4R4A4UNORM_PACK16 = 3,
        VK_FORMAT_R5G6B5UNORM_PACK16 = 4,
        VK_FORMAT_B5G6R5UNORM_PACK16 = 5,
        VK_FORMAT_R5G5B5A1UNORM_PACK16 = 6,
        VK_FORMAT_B5G5R5A1UNORM_PACK16 = 7,
        VK_FORMAT_A1R5G5B5UNORM_PACK16 = 8,
        VK_FORMAT_R8UNORM = 9,
        VK_FORMAT_R8SNORM = 10,
        VK_FORMAT_R8USCALED = 11,
        VK_FORMAT_R8SSCALED = 12,
        VK_FORMAT_R8UINT = 13,
        VK_FORMAT_R8SINT = 14,
        VK_FORMAT_R8SRGB = 15,
        VK_FORMAT_R8G8UNORM = 16,
        VK_FORMAT_R8G8SNORM = 17,
        VK_FORMAT_R8G8USCALED = 18,
        VK_FORMAT_R8G8SSCALED = 19,
        VK_FORMAT_R8G8UINT = 20,
        VK_FORMAT_R8G8SINT = 21,
        VK_FORMAT_R8G8SRGB = 22,
        VK_FORMAT_R8G8B8UNORM = 23,
        VK_FORMAT_R8G8B8SNORM = 24,
        VK_FORMAT_R8G8B8USCALED = 25,
        VK_FORMAT_R8G8B8SSCALED = 26,
        VK_FORMAT_R8G8B8UINT = 27,
        VK_FORMAT_R8G8B8SINT = 28,
        VK_FORMAT_R8G8B8SRGB = 29,
        VK_FORMAT_B8G8R8UNORM = 30,
        VK_FORMAT_B8G8R8SNORM = 31,
        VK_FORMAT_B8G8R8USCALED = 32,
        VK_FORMAT_B8G8R8SSCALED = 33,
        VK_FORMAT_B8G8R8UINT = 34,
        VK_FORMAT_B8G8R8SINT = 35,
        VK_FORMAT_B8G8R8SRGB = 36,
        VK_FORMAT_R8G8B8A8UNORM = 37,
        VK_FORMAT_R8G8B8A8SNORM = 38,
        VK_FORMAT_R8G8B8A8USCALED = 39,
        VK_FORMAT_R8G8B8A8SSCALED = 40,
        VK_FORMAT_R8G8B8A8UINT = 41,
        VK_FORMAT_R8G8B8A8SINT = 42,
        VK_FORMAT_R8G8B8A8SRGB = 43,
        VK_FORMAT_B8G8R8A8UNORM = 44,
        VK_FORMAT_B8G8R8A8SNORM = 45,
        VK_FORMAT_B8G8R8A8USCALED = 46,
        VK_FORMAT_B8G8R8A8SSCALED = 47,
        VK_FORMAT_B8G8R8A8UINT = 48,
        VK_FORMAT_B8G8R8A8SINT = 49,
        VK_FORMAT_B8G8R8A8SRGB = 50,
        VK_FORMAT_A8B8G8R8UNORM_PACK32 = 51,
        VK_FORMAT_A8B8G8R8SNORM_PACK32 = 52,
        VK_FORMAT_A8B8G8R8USCALED_PACK32 = 53,
        VK_FORMAT_A8B8G8R8SSCALED_PACK32 = 54,
        VK_FORMAT_A8B8G8R8UINT_PACK32 = 55,
        VK_FORMAT_A8B8G8R8SINT_PACK32 = 56,
        VK_FORMAT_A8B8G8R8SRGB_PACK32 = 57,
        VK_FORMAT_A2R10G10B10UNORM_PACK32 = 58,
        VK_FORMAT_A2R10G10B10SNORM_PACK32 = 59,
        VK_FORMAT_A2R10G10B10USCALED_PACK32 = 60,
        VK_FORMAT_A2R10G10B10SSCALED_PACK32 = 61,
        VK_FORMAT_A2R10G10B10UINT_PACK32 = 62,
        VK_FORMAT_A2R10G10B10SINT_PACK32 = 63,
        VK_FORMAT_A2B10G10R10UNORM_PACK32 = 64,
        VK_FORMAT_A2B10G10R10SNORM_PACK32 = 65,
        VK_FORMAT_A2B10G10R10USCALED_PACK32 = 66,
        VK_FORMAT_A2B10G10R10SSCALED_PACK32 = 67,
        VK_FORMAT_A2B10G10R10UINT_PACK32 = 68,
        VK_FORMAT_A2B10G10R10SINT_PACK32 = 69,
        VK_FORMAT_R16UNORM = 70,
        VK_FORMAT_R16SNORM = 71,
        VK_FORMAT_R16USCALED = 72,
        VK_FORMAT_R16SSCALED = 73,
        VK_FORMAT_R16UINT = 74,
        VK_FORMAT_R16SINT = 75,
        VK_FORMAT_R16SFLOAT = 76,
        VK_FORMAT_R16G16UNORM = 77,
        VK_FORMAT_R16G16SNORM = 78,
        VK_FORMAT_R16G16USCALED = 79,
        VK_FORMAT_R16G16SSCALED = 80,
        VK_FORMAT_R16G16UINT = 81,
        VK_FORMAT_R16G16SINT = 82,
        VK_FORMAT_R16G16SFLOAT = 83,
        VK_FORMAT_R16G16B16UNORM = 84,
        VK_FORMAT_R16G16B16SNORM = 85,
        VK_FORMAT_R16G16B16USCALED = 86,
        VK_FORMAT_R16G16B16SSCALED = 87,
        VK_FORMAT_R16G16B16UINT = 88,
        VK_FORMAT_R16G16B16SINT = 89,
        VK_FORMAT_R16G16B16SFLOAT = 90,
        VK_FORMAT_R16G16B16A16UNORM = 91,
        VK_FORMAT_R16G16B16A16SNORM = 92,
        VK_FORMAT_R16G16B16A16USCALED = 93,
        VK_FORMAT_R16G16B16A16SSCALED = 94,
        VK_FORMAT_R16G16B16A16UINT = 95,
        VK_FORMAT_R16G16B16A16SINT = 96,
        VK_FORMAT_R16G16B16A16SFLOAT = 97,
        VK_FORMAT_R32UINT = 98,
        VK_FORMAT_R32SINT = 99,
        VK_FORMAT_R32SFLOAT = 100,
        VK_FORMAT_R32G32UINT = 101,
        VK_FORMAT_R32G32SINT = 102,
        VK_FORMAT_R32G32SFLOAT = 103,
        VK_FORMAT_R32G32B32UINT = 104,
        VK_FORMAT_R32G32B32SINT = 105,
        VK_FORMAT_R32G32B32SFLOAT = 106,
        VK_FORMAT_R32G32B32A32UINT = 107,
        VK_FORMAT_R32G32B32A32SINT = 108,
        VK_FORMAT_R32G32B32A32SFLOAT = 109,
        VK_FORMAT_R64UINT = 110,
        VK_FORMAT_R64SINT = 111,
        VK_FORMAT_R64SFLOAT = 112,
        VK_FORMAT_R64G64UINT = 113,
        VK_FORMAT_R64G64SINT = 114,
        VK_FORMAT_R64G64SFLOAT = 115,
        VK_FORMAT_R64G64B64UINT = 116,
        VK_FORMAT_R64G64B64SINT = 117,
        VK_FORMAT_R64G64B64SFLOAT = 118,
        VK_FORMAT_R64G64B64A64UINT = 119,
        VK_FORMAT_R64G64B64A64SINT = 120,
        VK_FORMAT_R64G64B64A64SFLOAT = 121,
        VK_FORMAT_B10G11R11UFLOAT_PACK32 = 122,
        VK_FORMAT_E5B9G9R9UFLOAT_PACK32 = 123,
        VK_FORMAT_D16UNORM = 124,
        VK_FORMAT_X8D24UNORM_PACK32 = 125,
        VK_FORMAT_D32SFLOAT = 126,
        VK_FORMAT_S8UINT = 127,
        VK_FORMAT_D16UNORM_S8UINT = 128,
        VK_FORMAT_D24UNORM_S8UINT = 129,
        VK_FORMAT_D32SFLOAT_S8UINT = 130,
        VK_FORMAT_BC1RGB_UNORM_BLOCK = 131,
        VK_FORMAT_BC1RGB_SRGB_BLOCK = 132,
        VK_FORMAT_BC1RGBA_UNORM_BLOCK = 133,
        VK_FORMAT_BC1RGBA_SRGB_BLOCK = 134,
        VK_FORMAT_BC2UNORM_BLOCK = 135,
        VK_FORMAT_BC2SRGB_BLOCK = 136,
        VK_FORMAT_BC3UNORM_BLOCK = 137,
        VK_FORMAT_BC3SRGB_BLOCK = 138,
        VK_FORMAT_BC4UNORM_BLOCK = 139,
        VK_FORMAT_BC4SNORM_BLOCK = 140,
        VK_FORMAT_BC5UNORM_BLOCK = 141,
        VK_FORMAT_BC5SNORM_BLOCK = 142,
        VK_FORMAT_BC6H_UFLOAT_BLOCK = 143,
        VK_FORMAT_BC6H_SFLOAT_BLOCK = 144,
        VK_FORMAT_BC7UNORM_BLOCK = 145,
        VK_FORMAT_BC7SRGB_BLOCK = 146,
        VK_FORMAT_ETC2R8G8B8UNORM_BLOCK = 147,
        VK_FORMAT_ETC2R8G8B8SRGB_BLOCK = 148,
        VK_FORMAT_ETC2R8G8B8A1UNORM_BLOCK = 149,
        VK_FORMAT_ETC2R8G8B8A1SRGB_BLOCK = 150,
        VK_FORMAT_ETC2R8G8B8A8UNORM_BLOCK = 151,
        VK_FORMAT_ETC2R8G8B8A8SRGB_BLOCK = 152,
        VK_FORMAT_EAC_R11UNORM_BLOCK = 153,
        VK_FORMAT_EAC_R11SNORM_BLOCK = 154,
        VK_FORMAT_EAC_R11G11UNORM_BLOCK = 155,
        VK_FORMAT_EAC_R11G11SNORM_BLOCK = 156,
        VK_FORMAT_ASTC_4x4UNORM_BLOCK = 157,
        VK_FORMAT_ASTC_4x4SRGB_BLOCK = 158,
        VK_FORMAT_ASTC_5x4UNORM_BLOCK = 159,
        VK_FORMAT_ASTC_5x4SRGB_BLOCK = 160,
        VK_FORMAT_ASTC_5x5UNORM_BLOCK = 161,
        VK_FORMAT_ASTC_5x5SRGB_BLOCK = 162,
        VK_FORMAT_ASTC_6x5UNORM_BLOCK = 163,
        VK_FORMAT_ASTC_6x5SRGB_BLOCK = 164,
        VK_FORMAT_ASTC_6x6UNORM_BLOCK = 165,
        VK_FORMAT_ASTC_6x6SRGB_BLOCK = 166,
        VK_FORMAT_ASTC_8x5UNORM_BLOCK = 167,
        VK_FORMAT_ASTC_8x5SRGB_BLOCK = 168,
        VK_FORMAT_ASTC_8x6UNORM_BLOCK = 169,
        VK_FORMAT_ASTC_8x6SRGB_BLOCK = 170,
        VK_FORMAT_ASTC_8x8UNORM_BLOCK = 171,
        VK_FORMAT_ASTC_8x8SRGB_BLOCK = 172,
        VK_FORMAT_ASTC_10x5UNORM_BLOCK = 173,
        VK_FORMAT_ASTC_10x5SRGB_BLOCK = 174,
        VK_FORMAT_ASTC_10x6UNORM_BLOCK = 175,
        VK_FORMAT_ASTC_10x6SRGB_BLOCK = 176,
        VK_FORMAT_ASTC_10x8UNORM_BLOCK = 177,
        VK_FORMAT_ASTC_10x8SRGB_BLOCK = 178,
        VK_FORMAT_ASTC_10x10UNORM_BLOCK = 179,
        VK_FORMAT_ASTC_10x10SRGB_BLOCK = 180,
        VK_FORMAT_ASTC_12x10UNORM_BLOCK = 181,
        VK_FORMAT_ASTC_12x10SRGB_BLOCK = 182,
        VK_FORMAT_ASTC_12x12UNORM_BLOCK = 183,
        VK_FORMAT_ASTC_12x12SRGB_BLOCK = 184,
        VK_FORMAT_G8B8G8R8_422UNORM = 1000156000,
        VK_FORMAT_B8G8R8G8_422UNORM = 1000156001,
        VK_FORMAT_G8B8R8_3PLANE_420UNORM = 1000156002,
        VK_FORMAT_G8B8R8_2PLANE_420UNORM = 1000156003,
        VK_FORMAT_G8B8R8_3PLANE_422UNORM = 1000156004,
        VK_FORMAT_G8B8R8_2PLANE_422UNORM = 1000156005,
        VK_FORMAT_G8B8R8_3PLANE_444UNORM = 1000156006,
        VK_FORMAT_R10X6UNORM_PACK16 = 1000156007,
        VK_FORMAT_R10X6G10X6UNORM_2PACK16 = 1000156008,
        VK_FORMAT_R10X6G10X6B10X6A10X6UNORM_4PACK16 = 1000156009,
        VK_FORMAT_G10X6B10X6G10X6R10X6_422UNORM_4PACK16 = 1000156010,
        VK_FORMAT_B10X6G10X6R10X6G10X6_422UNORM_4PACK16 = 1000156011,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_420UNORM_3PACK16 = 1000156012,
        VK_FORMAT_G10X6B10X6R10X6_2PLANE_420UNORM_3PACK16 = 1000156013,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_422UNORM_3PACK16 = 1000156014,
        VK_FORMAT_G10X6B10X6R10X6_2PLANE_422UNORM_3PACK16 = 1000156015,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_444UNORM_3PACK16 = 1000156016,
        VK_FORMAT_R12X4UNORM_PACK16 = 1000156017,
        VK_FORMAT_R12X4G12X4UNORM_2PACK16 = 1000156018,
        VK_FORMAT_R12X4G12X4B12X4A12X4UNORM_4PACK16 = 1000156019,
        VK_FORMAT_G12X4B12X4G12X4R12X4_422UNORM_4PACK16 = 1000156020,
        VK_FORMAT_B12X4G12X4R12X4G12X4_422UNORM_4PACK16 = 1000156021,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_420UNORM_3PACK16 = 1000156022,
        VK_FORMAT_G12X4B12X4R12X4_2PLANE_420UNORM_3PACK16 = 1000156023,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_422UNORM_3PACK16 = 1000156024,
        VK_FORMAT_G12X4B12X4R12X4_2PLANE_422UNORM_3PACK16 = 1000156025,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_444UNORM_3PACK16 = 1000156026,
        VK_FORMAT_G16B16G16R16_422UNORM = 1000156027,
        VK_FORMAT_B16G16R16G16_422UNORM = 1000156028,
        VK_FORMAT_G16B16R16_3PLANE_420UNORM = 1000156029,
        VK_FORMAT_G16B16R16_2PLANE_420UNORM = 1000156030,
        VK_FORMAT_G16B16R16_3PLANE_422UNORM = 1000156031,
        VK_FORMAT_G16B16R16_2PLANE_422UNORM = 1000156032,
        VK_FORMAT_G16B16R16_3PLANE_444UNORM = 1000156033,
        VK_FORMAT_PVRTC1_2BPP_UNORM_BLOCK_IMG = 1000054000,
        VK_FORMAT_PVRTC1_4BPP_UNORM_BLOCK_IMG = 1000054001,
        VK_FORMAT_PVRTC2_2BPP_UNORM_BLOCK_IMG = 1000054002,
        VK_FORMAT_PVRTC2_4BPP_UNORM_BLOCK_IMG = 1000054003,
        VK_FORMAT_PVRTC1_2BPP_SRGB_BLOCK_IMG = 1000054004,
        VK_FORMAT_PVRTC1_4BPP_SRGB_BLOCK_IMG = 1000054005,
        VK_FORMAT_PVRTC2_2BPP_SRGB_BLOCK_IMG = 1000054006,
        VK_FORMAT_PVRTC2_4BPP_SRGB_BLOCK_IMG = 1000054007,
        VK_FORMAT_ASTC_4x4SFLOAT_BLOCK_EXT = 1000066000,
        VK_FORMAT_ASTC_5x4SFLOAT_BLOCK_EXT = 1000066001,
        VK_FORMAT_ASTC_5x5SFLOAT_BLOCK_EXT = 1000066002,
        VK_FORMAT_ASTC_6x5SFLOAT_BLOCK_EXT = 1000066003,
        VK_FORMAT_ASTC_6x6SFLOAT_BLOCK_EXT = 1000066004,
        VK_FORMAT_ASTC_8x5SFLOAT_BLOCK_EXT = 1000066005,
        VK_FORMAT_ASTC_8x6SFLOAT_BLOCK_EXT = 1000066006,
        VK_FORMAT_ASTC_8x8SFLOAT_BLOCK_EXT = 1000066007,
        VK_FORMAT_ASTC_10x5SFLOAT_BLOCK_EXT = 1000066008,
        VK_FORMAT_ASTC_10x6SFLOAT_BLOCK_EXT = 1000066009,
        VK_FORMAT_ASTC_10x8SFLOAT_BLOCK_EXT = 1000066010,
        VK_FORMAT_ASTC_10x10SFLOAT_BLOCK_EXT = 1000066011,
        VK_FORMAT_ASTC_12x10SFLOAT_BLOCK_EXT = 1000066012,
        VK_FORMAT_ASTC_12x12SFLOAT_BLOCK_EXT = 1000066013,
        VK_FORMAT_G8B8R8_2PLANE_444UNORM_EXT = 1000330000,
        VK_FORMAT_G10X6B10X6R10X6_2PLANE_444UNORM_3PACK16EXT = 1000330001,
        VK_FORMAT_G12X4B12X4R12X4_2PLANE_444UNORM_3PACK16EXT = 1000330002,
        VK_FORMAT_G16B16R16_2PLANE_444UNORM_EXT = 1000330003,
        VK_FORMAT_A4R4G4B4UNORM_PACK16EXT = 1000340000,
        VK_FORMAT_A4B4G4R4UNORM_PACK16EXT = 1000340001,
        VK_FORMAT_G8B8G8R8_422UNORM_KHR = 1000156000,
        VK_FORMAT_B8G8R8G8_422UNORM_KHR = 1000156001,
        VK_FORMAT_G8B8R8_3PLANE_420UNORM_KHR = 1000156002,
        VK_FORMAT_G8B8R8_2PLANE_420UNORM_KHR = 1000156003,
        VK_FORMAT_G8B8R8_3PLANE_422UNORM_KHR = 1000156004,
        VK_FORMAT_G8B8R8_2PLANE_422UNORM_KHR = 1000156005,
        VK_FORMAT_G8B8R8_3PLANE_444UNORM_KHR = 1000156006,
        VK_FORMAT_R10X6UNORM_PACK16KHR = 1000156007,
        VK_FORMAT_R10X6G10X6UNORM_2PACK16KHR = 1000156008,
        VK_FORMAT_R10X6G10X6B10X6A10X6UNORM_4PACK16KHR = 1000156009,
        VK_FORMAT_G10X6B10X6G10X6R10X6_422UNORM_4PACK16KHR = 1000156010,
        VK_FORMAT_B10X6G10X6R10X6G10X6_422UNORM_4PACK16KHR = 1000156011,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_420UNORM_3PACK16KHR = 1000156012,
        VK_FORMAT_G10X6B10X6R10X6_2PLANE_420UNORM_3PACK16KHR = 1000156013,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_422UNORM_3PACK16KHR = 1000156014,
        VK_FORMAT_G10X6B10X6R10X6_2PLANE_422UNORM_3PACK16KHR = 1000156015,
        VK_FORMAT_G10X6B10X6R10X6_3PLANE_444UNORM_3PACK16KHR = 1000156016,
        VK_FORMAT_R12X4UNORM_PACK16KHR = 1000156017,
        VK_FORMAT_R12X4G12X4UNORM_2PACK16KHR = 1000156018,
        VK_FORMAT_R12X4G12X4B12X4A12X4UNORM_4PACK16KHR = 1000156019,
        VK_FORMAT_G12X4B12X4G12X4R12X4_422UNORM_4PACK16KHR = 1000156020,
        VK_FORMAT_B12X4G12X4R12X4G12X4_422UNORM_4PACK16KHR = 1000156021,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_420UNORM_3PACK16KHR = 1000156022,
        VK_FORMAT_G12X4B12X4R12X4_2PLANE_420UNORM_3PACK16KHR = 1000156023,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_422UNORM_3PACK16KHR = 1000156024,
        VK_FORMAT_G12X4B12X4R12X4_2PLANE_422UNORM_3PACK16KHR = 1000156025,
        VK_FORMAT_G12X4B12X4R12X4_3PLANE_444UNORM_3PACK16KHR = 1000156026,
        VK_FORMAT_G16B16G16R16_422UNORM_KHR = 1000156027,
        VK_FORMAT_B16G16R16G16_422UNORM_KHR = 1000156028,
        VK_FORMAT_G16B16R16_3PLANE_420UNORM_KHR = 1000156029,
        VK_FORMAT_G16B16R16_2PLANE_420UNORM_KHR = 1000156030,
        VK_FORMAT_G16B16R16_3PLANE_422UNORM_KHR = 1000156031,
        VK_FORMAT_G16B16R16_2PLANE_422UNORM_KHR = 1000156032,
        VK_FORMAT_G16B16R16_3PLANE_444UNORM_KHR = 1000156033,
        VK_FORMAT_MAX_ENUM = 2147483647
    }

    public enum VkColorSpaceKHR
    {
        VK_COLOR_SPACE_SRGB_NONLINEAR_KHR = 0,
        VK_COLOR_SPACE_DISPLAY_P3NONLINEAR_EXT = 1000104001,
        VK_COLOR_SPACE_EXTENDED_SRGB_LINEAR_EXT = 1000104002,
        VK_COLOR_SPACE_DISPLAY_P3LINEAR_EXT = 1000104003,
        VK_COLOR_SPACE_DCI_P3NONLINEAR_EXT = 1000104004,
        VK_COLOR_SPACE_BT709LINEAR_EXT = 1000104005,
        VK_COLOR_SPACE_BT709NONLINEAR_EXT = 1000104006,
        VK_COLOR_SPACE_BT2020LINEAR_EXT = 1000104007,
        VK_COLOR_SPACE_HDR10ST2084EXT = 1000104008,
        VK_COLOR_SPACE_DOLBYVISION_EXT = 1000104009,
        VK_COLOR_SPACE_HDR10HLG_EXT = 1000104010,
        VK_COLOR_SPACE_ADOBERGB_LINEAR_EXT = 1000104011,
        VK_COLOR_SPACE_ADOBERGB_NONLINEAR_EXT = 1000104012,
        VK_COLOR_SPACE_PASS_THROUGH_EXT = 1000104013,
        VK_COLOR_SPACE_EXTENDED_SRGB_NONLINEAR_EXT = 1000104014,
        VK_COLOR_SPACE_DISPLAY_NATIVE_AMD = 1000213000,
        VK_COLORSPACE_SRGB_NONLINEAR_KHR = 0,
        VK_COLOR_SPACE_DCI_P3LINEAR_EXT = 1000104003,
        VK_COLOR_SPACE_MAX_ENUM_KHR = 2147483647
    }

    public enum VkPresentModeKHR
    {
        VK_PRESENT_MODE_IMMEDIATE_KHR = 0,
        VK_PRESENT_MODE_MAILBOX_KHR = 1,
        VK_PRESENT_MODE_FIFO_KHR = 2,
        VK_PRESENT_MODE_FIFO_RELAXED_KHR = 3,
        VK_PRESENT_MODE_SHARED_DEMAND_REFRESH_KHR = 1000111000,
        VK_PRESENT_MODE_SHARED_CONTINUOUS_REFRESH_KHR = 1000111001,
        VK_PRESENT_MODE_MAX_ENUM_KHR = 2147483647
    }

    public enum VkSampleCountFlagBits
    {
        VK_SAMPLE_COUNT_1BIT = 1,
        VK_SAMPLE_COUNT_2BIT = 2,
        VK_SAMPLE_COUNT_4BIT = 4,
        VK_SAMPLE_COUNT_8BIT = 8,
        VK_SAMPLE_COUNT_16BIT = 16,
        VK_SAMPLE_COUNT_32BIT = 32,
        VK_SAMPLE_COUNT_64BIT = 64,
        VK_SAMPLE_COUNT_FLAG_BITS_MAX_ENUM = 2147483647
    }

    public enum VkResult
    {
        VK_SUCCESS = 0,
        VK_NOT_READY = 1,
        VK_TIMEOUT = 2,
        VK_EVENT_SET = 3,
        VK_EVENT_RESET = 4,
        VK_INCOMPLETE = 5,
        VK_ERROR_OUT_OF_HOST_MEMORY = -1,
        VK_ERROR_OUT_OF_DEVICE_MEMORY = -2,
        VK_ERROR_INITIALIZATION_FAILED = -3,
        VK_ERROR_DEVICE_LOST = -4,
        VK_ERROR_MEMORY_MAP_FAILED = -5,
        VK_ERROR_LAYER_NOT_PRESENT = -6,
        VK_ERROR_EXTENSION_NOT_PRESENT = -7,
        VK_ERROR_FEATURE_NOT_PRESENT = -8,
        VK_ERROR_INCOMPATIBLE_DRIVER = -9,
        VK_ERROR_TOO_MANY_OBJECTS = -10,
        VK_ERROR_FORMAT_NOT_SUPPORTED = -11,
        VK_ERROR_FRAGMENTED_POOL = -12,
        VK_ERROR_UNKNOWN = -13,
        VK_ERROR_OUT_OF_POOL_MEMORY = -1000069000,
        VK_ERROR_INVALID_EXTERNAL_HANDLE = -1000072003,
        VK_ERROR_FRAGMENTATION = -1000161000,
        VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS = -1000257000,
        VK_ERROR_SURFACE_LOST_KHR = -1000000000,
        VK_ERROR_NATIVE_WINDOW_IN_USE_KHR = -1000000001,
        VK_SUBOPTIMAL_KHR = 1000001003,
        VK_ERROR_OUT_OF_DATE_KHR = -1000001004,
        VK_ERROR_INCOMPATIBLE_DISPLAY_KHR = -1000003001,
        VK_ERROR_VALIDATION_FAILED_EXT = -1000011001,
        VK_ERROR_INVALID_SHADER_NV = -1000012000,
        VK_ERROR_INVALID_DRM_FORMAT_MODIFIER_PLANE_LAYOUT_EXT = -1000158000,
        VK_ERROR_NOT_PERMITTED_EXT = -1000174001,
        VK_ERROR_FULL_SCREEN_EXCLUSIVE_MODE_LOST_EXT = -1000255000,
        VK_THREAD_IDLE_KHR = 1000268000,
        VK_THREAD_DONE_KHR = 1000268001,
        VK_OPERATION_DEFERRED_KHR = 1000268002,
        VK_OPERATION_NOT_DEFERRED_KHR = 1000268003,
        VK_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
        VK_ERROR_OUT_OF_POOL_MEMORY_KHR = -1000069000,
        VK_ERROR_INVALID_EXTERNAL_HANDLE_KHR = -1000072003,
        VK_ERROR_FRAGMENTATION_EXT = -1000161000,
        VK_ERROR_INVALID_DEVICE_ADDRESS_EXT = -1000257000,
        VK_ERROR_INVALID_OPAQUE_CAPTURE_ADDRESS_KHR = -1000257000,
        VK_ERROR_PIPELINE_COMPILE_REQUIRED_EXT = 1000297000,
        VK_RESULT_MAX_ENUM = 2147483647
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr PFN_vkAllocationFunction(__IntPtr pUserData, IntPtr size, IntPtr alignment, global::DearImguiSharp.VkSystemAllocationScope allocationScope);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr PFN_vkReallocationFunction(__IntPtr pUserData, __IntPtr pOriginal, IntPtr size, IntPtr alignment, global::DearImguiSharp.VkSystemAllocationScope allocationScope);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFN_vkFreeFunction(__IntPtr pUserData, __IntPtr pMemory);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFN_vkInternalAllocationNotification(__IntPtr pUserData, IntPtr size, global::DearImguiSharp.VkInternalAllocationType allocationType, global::DearImguiSharp.VkSystemAllocationScope allocationScope);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFN_vkInternalFreeNotification(__IntPtr pUserData, IntPtr size, global::DearImguiSharp.VkInternalAllocationType allocationType, global::DearImguiSharp.VkSystemAllocationScope allocationScope);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void PFN_vkVoidFunction();

    public unsafe partial class VkBufferT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkBufferT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkBufferT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkBufferT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkBufferT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkBufferT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkBufferT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkBufferT(native.ToPointer(), skipVTables);
        }

        internal static VkBufferT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkBufferT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkBufferT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkBufferT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkBufferT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkBufferT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkImageT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkImageT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkImageT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkImageT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkImageT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkImageT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkImageT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkImageT(native.ToPointer(), skipVTables);
        }

        internal static VkImageT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkImageT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkImageT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkImageT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkImageT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkImageT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkInstanceT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkInstanceT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkInstanceT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkInstanceT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkInstanceT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkInstanceT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkInstanceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkInstanceT(native.ToPointer(), skipVTables);
        }

        internal static VkInstanceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkInstanceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkInstanceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkInstanceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkInstanceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkInstanceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkPhysicalDeviceT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPhysicalDeviceT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPhysicalDeviceT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkPhysicalDeviceT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkPhysicalDeviceT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkPhysicalDeviceT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkPhysicalDeviceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkPhysicalDeviceT(native.ToPointer(), skipVTables);
        }

        internal static VkPhysicalDeviceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkPhysicalDeviceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkPhysicalDeviceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkPhysicalDeviceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkPhysicalDeviceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkPhysicalDeviceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkDeviceT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDeviceT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDeviceT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkDeviceT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkDeviceT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkDeviceT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkDeviceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkDeviceT(native.ToPointer(), skipVTables);
        }

        internal static VkDeviceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkDeviceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkDeviceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkDeviceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkDeviceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkDeviceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkQueueT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkQueueT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkQueueT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkQueueT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkQueueT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkQueueT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkQueueT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkQueueT(native.ToPointer(), skipVTables);
        }

        internal static VkQueueT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkQueueT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkQueueT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkQueueT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkQueueT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkQueueT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkSemaphoreT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSemaphoreT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSemaphoreT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkSemaphoreT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkSemaphoreT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkSemaphoreT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkSemaphoreT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkSemaphoreT(native.ToPointer(), skipVTables);
        }

        internal static VkSemaphoreT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkSemaphoreT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkSemaphoreT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkSemaphoreT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkSemaphoreT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSemaphoreT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkCommandBufferT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkCommandBufferT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkCommandBufferT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkCommandBufferT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkCommandBufferT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkCommandBufferT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkCommandBufferT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkCommandBufferT(native.ToPointer(), skipVTables);
        }

        internal static VkCommandBufferT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkCommandBufferT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkCommandBufferT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkCommandBufferT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkCommandBufferT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkCommandBufferT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkFenceT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkFenceT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkFenceT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkFenceT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkFenceT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkFenceT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkFenceT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkFenceT(native.ToPointer(), skipVTables);
        }

        internal static VkFenceT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkFenceT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkFenceT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkFenceT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkFenceT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkFenceT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkDeviceMemoryT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDeviceMemoryT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDeviceMemoryT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkDeviceMemoryT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkDeviceMemoryT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkDeviceMemoryT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkDeviceMemoryT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkDeviceMemoryT(native.ToPointer(), skipVTables);
        }

        internal static VkDeviceMemoryT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkDeviceMemoryT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkDeviceMemoryT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkDeviceMemoryT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkDeviceMemoryT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkDeviceMemoryT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkEventT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkEventT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkEventT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkEventT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkEventT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkEventT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkEventT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkEventT(native.ToPointer(), skipVTables);
        }

        internal static VkEventT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkEventT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkEventT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkEventT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkEventT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkEventT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkQueryPoolT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkQueryPoolT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkQueryPoolT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkQueryPoolT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkQueryPoolT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkQueryPoolT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkQueryPoolT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkQueryPoolT(native.ToPointer(), skipVTables);
        }

        internal static VkQueryPoolT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkQueryPoolT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkQueryPoolT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkQueryPoolT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkQueryPoolT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkQueryPoolT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkBufferViewT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkBufferViewT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkBufferViewT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkBufferViewT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkBufferViewT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkBufferViewT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkBufferViewT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkBufferViewT(native.ToPointer(), skipVTables);
        }

        internal static VkBufferViewT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkBufferViewT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkBufferViewT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkBufferViewT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkBufferViewT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkBufferViewT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkImageViewT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkImageViewT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkImageViewT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkImageViewT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkImageViewT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkImageViewT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkImageViewT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkImageViewT(native.ToPointer(), skipVTables);
        }

        internal static VkImageViewT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkImageViewT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkImageViewT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkImageViewT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkImageViewT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkImageViewT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkShaderModuleT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkShaderModuleT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkShaderModuleT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkShaderModuleT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkShaderModuleT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkShaderModuleT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkShaderModuleT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkShaderModuleT(native.ToPointer(), skipVTables);
        }

        internal static VkShaderModuleT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkShaderModuleT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkShaderModuleT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkShaderModuleT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkShaderModuleT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkShaderModuleT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkPipelineCacheT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineCacheT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineCacheT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkPipelineCacheT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkPipelineCacheT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkPipelineCacheT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkPipelineCacheT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkPipelineCacheT(native.ToPointer(), skipVTables);
        }

        internal static VkPipelineCacheT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkPipelineCacheT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkPipelineCacheT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkPipelineCacheT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkPipelineCacheT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkPipelineCacheT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkPipelineLayoutT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineLayoutT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineLayoutT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkPipelineLayoutT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkPipelineLayoutT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkPipelineLayoutT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkPipelineLayoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkPipelineLayoutT(native.ToPointer(), skipVTables);
        }

        internal static VkPipelineLayoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkPipelineLayoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkPipelineLayoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkPipelineLayoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkPipelineLayoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkPipelineLayoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkPipelineT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkPipelineT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkPipelineT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkPipelineT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkPipelineT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkPipelineT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkPipelineT(native.ToPointer(), skipVTables);
        }

        internal static VkPipelineT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkPipelineT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkPipelineT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkPipelineT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkPipelineT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkPipelineT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkRenderPassT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkRenderPassT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkRenderPassT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkRenderPassT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkRenderPassT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkRenderPassT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkRenderPassT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkRenderPassT(native.ToPointer(), skipVTables);
        }

        internal static VkRenderPassT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkRenderPassT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkRenderPassT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkRenderPassT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkRenderPassT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkRenderPassT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkDescriptorSetLayoutT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetLayoutT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetLayoutT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkDescriptorSetLayoutT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetLayoutT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkDescriptorSetLayoutT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkDescriptorSetLayoutT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkDescriptorSetLayoutT(native.ToPointer(), skipVTables);
        }

        internal static VkDescriptorSetLayoutT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkDescriptorSetLayoutT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkDescriptorSetLayoutT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkDescriptorSetLayoutT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkDescriptorSetLayoutT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkDescriptorSetLayoutT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkSamplerT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSamplerT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSamplerT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkSamplerT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkSamplerT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkSamplerT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkSamplerT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkSamplerT(native.ToPointer(), skipVTables);
        }

        internal static VkSamplerT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkSamplerT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkSamplerT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkSamplerT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkSamplerT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSamplerT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkDescriptorSetT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkDescriptorSetT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkDescriptorSetT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkDescriptorSetT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkDescriptorSetT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkDescriptorSetT(native.ToPointer(), skipVTables);
        }

        internal static VkDescriptorSetT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkDescriptorSetT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkDescriptorSetT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkDescriptorSetT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkDescriptorSetT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkDescriptorSetT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkDescriptorPoolT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorPoolT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkDescriptorPoolT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkDescriptorPoolT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkDescriptorPoolT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkDescriptorPoolT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkDescriptorPoolT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkDescriptorPoolT(native.ToPointer(), skipVTables);
        }

        internal static VkDescriptorPoolT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkDescriptorPoolT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkDescriptorPoolT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkDescriptorPoolT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkDescriptorPoolT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkDescriptorPoolT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkFramebufferT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkFramebufferT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkFramebufferT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkFramebufferT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkFramebufferT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkFramebufferT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkFramebufferT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkFramebufferT(native.ToPointer(), skipVTables);
        }

        internal static VkFramebufferT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkFramebufferT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkFramebufferT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkFramebufferT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkFramebufferT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkFramebufferT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkCommandPoolT
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkCommandPoolT>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkCommandPoolT>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkCommandPoolT managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkCommandPoolT>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkCommandPoolT managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkCommandPoolT __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkCommandPoolT(native.ToPointer(), skipVTables);
        }

        internal static VkCommandPoolT __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkCommandPoolT)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkCommandPoolT __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkCommandPoolT(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkCommandPoolT(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkCommandPoolT(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkSurfaceKHR_T
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSurfaceKHR_T>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSurfaceKHR_T>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkSurfaceKHR_T managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkSurfaceKHR_T>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkSurfaceKHR_T managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkSurfaceKHR_T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkSurfaceKHR_T(native.ToPointer(), skipVTables);
        }

        internal static VkSurfaceKHR_T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkSurfaceKHR_T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkSurfaceKHR_T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkSurfaceKHR_T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkSurfaceKHR_T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSurfaceKHR_T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkSwapchainKHR_T
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSwapchainKHR_T>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSwapchainKHR_T>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkSwapchainKHR_T managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkSwapchainKHR_T>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkSwapchainKHR_T managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkSwapchainKHR_T __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkSwapchainKHR_T(native.ToPointer(), skipVTables);
        }

        internal static VkSwapchainKHR_T __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkSwapchainKHR_T)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkSwapchainKHR_T __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkSwapchainKHR_T(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkSwapchainKHR_T(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSwapchainKHR_T(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class VkAllocationCallbacks : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public __IntPtr pUserData;
            public __IntPtr pfnAllocation;
            public __IntPtr pfnReallocation;
            public __IntPtr pfnFree;
            public __IntPtr pfnInternalAllocation;
            public __IntPtr pfnInternalFree;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0VkAllocationCallbacks@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkAllocationCallbacks>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkAllocationCallbacks>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkAllocationCallbacks managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkAllocationCallbacks>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkAllocationCallbacks managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkAllocationCallbacks __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkAllocationCallbacks(native.ToPointer(), skipVTables);
        }

        internal static VkAllocationCallbacks __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkAllocationCallbacks)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkAllocationCallbacks __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkAllocationCallbacks(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkAllocationCallbacks(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkAllocationCallbacks(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VkAllocationCallbacks()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkAllocationCallbacks.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkAllocationCallbacks(global::DearImguiSharp.VkAllocationCallbacks _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkAllocationCallbacks.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.VkAllocationCallbacks.__Internal*) __Instance) = *((global::DearImguiSharp.VkAllocationCallbacks.__Internal*) _0.__Instance);
        }

        ~VkAllocationCallbacks()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr PUserData
        {
            get
            {
                return ((__Internal*)__Instance)->pUserData;
            }

            set
            {
                ((__Internal*)__Instance)->pUserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.PFN_vkAllocationFunction PfnAllocation
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pfnAllocation;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.PFN_vkAllocationFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.PFN_vkAllocationFunction));
            }

            set
            {
                ((__Internal*)__Instance)->pfnAllocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.PFN_vkReallocationFunction PfnReallocation
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pfnReallocation;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.PFN_vkReallocationFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.PFN_vkReallocationFunction));
            }

            set
            {
                ((__Internal*)__Instance)->pfnReallocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.PFN_vkFreeFunction PfnFree
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pfnFree;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.PFN_vkFreeFunction) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.PFN_vkFreeFunction));
            }

            set
            {
                ((__Internal*)__Instance)->pfnFree = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.PFN_vkInternalAllocationNotification PfnInternalAllocation
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pfnInternalAllocation;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.PFN_vkInternalAllocationNotification) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.PFN_vkInternalAllocationNotification));
            }

            set
            {
                ((__Internal*)__Instance)->pfnInternalAllocation = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.PFN_vkInternalFreeNotification PfnInternalFree
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->pfnInternalFree;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.PFN_vkInternalFreeNotification) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.PFN_vkInternalFreeNotification));
            }

            set
            {
                ((__Internal*)__Instance)->pfnInternalFree = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial struct VkClearColorValue
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public fixed float float32[4];

            [FieldOffset(0)]
            public fixed int int32[4];

            [FieldOffset(0)]
            public fixed uint uint32[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0VkClearColorValue@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private VkClearColorValue.__Internal __instance;
        internal VkClearColorValue.__Internal __Instance => __instance;

        internal static VkClearColorValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkClearColorValue(native.ToPointer(), skipVTables);
        }

        internal static VkClearColorValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkClearColorValue(native, skipVTables);
        }

        private VkClearColorValue(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private VkClearColorValue(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::DearImguiSharp.VkClearColorValue.__Internal*) native;
        }

        public VkClearColorValue(global::DearImguiSharp.VkClearColorValue _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public float[] Float32
        {
            get
            {
                fixed (float* __arrPtr = __instance.float32)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<float>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (float* __arrPtr = __instance.float32)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public int[] Int32
        {
            get
            {
                fixed (int* __arrPtr = __instance.int32)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<int>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (int* __arrPtr = __instance.int32)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }

        public uint[] Uint32
        {
            get
            {
                fixed (uint* __arrPtr = __instance.uint32)
                {
                    return CppSharp.Runtime.MarshalUtil.GetArray<uint>(__arrPtr, 4);
                }
            }

            set
            {
                fixed (uint* __arrPtr = __instance.uint32)
                {
                    if (value != null)
                    {
                        for (int i = 0; i < 4; i++)
                            __arrPtr[i] = value[i];
                    }
                }
            }
        }
    }

    public unsafe partial class VkClearDepthStencilValue : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float depth;
            public uint stencil;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0VkClearDepthStencilValue@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkClearDepthStencilValue>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkClearDepthStencilValue>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkClearDepthStencilValue managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkClearDepthStencilValue>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkClearDepthStencilValue managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkClearDepthStencilValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkClearDepthStencilValue(native.ToPointer(), skipVTables);
        }

        internal static VkClearDepthStencilValue __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkClearDepthStencilValue)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkClearDepthStencilValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkClearDepthStencilValue(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkClearDepthStencilValue(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkClearDepthStencilValue(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VkClearDepthStencilValue()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkClearDepthStencilValue.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkClearDepthStencilValue(global::DearImguiSharp.VkClearDepthStencilValue _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkClearDepthStencilValue.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.VkClearDepthStencilValue.__Internal*) __Instance) = *((global::DearImguiSharp.VkClearDepthStencilValue.__Internal*) _0.__Instance);
        }

        ~VkClearDepthStencilValue()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Depth
        {
            get
            {
                return ((__Internal*)__Instance)->depth;
            }

            set
            {
                ((__Internal*)__Instance)->depth = value;
            }
        }

        public uint Stencil
        {
            get
            {
                return ((__Internal*)__Instance)->stencil;
            }

            set
            {
                ((__Internal*)__Instance)->stencil = value;
            }
        }
    }

    public unsafe partial struct VkClearValue
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::DearImguiSharp.VkClearColorValue.__Internal color;

            [FieldOffset(0)]
            public global::DearImguiSharp.VkClearDepthStencilValue.__Internal depthStencil;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0VkClearValue@@QEAA@AEBT0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        private VkClearValue.__Internal __instance;
        internal VkClearValue.__Internal __Instance => __instance;

        internal static VkClearValue __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkClearValue(native.ToPointer(), skipVTables);
        }

        internal static VkClearValue __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkClearValue(native, skipVTables);
        }

        private VkClearValue(__Internal native, bool skipVTables = false)
            : this()
        {
            __instance = native;
        }

        private VkClearValue(void* native, bool skipVTables = false) : this()
        {
            __instance = *(global::DearImguiSharp.VkClearValue.__Internal*) native;
        }

        public VkClearValue(global::DearImguiSharp.VkClearValue _0)
            : this()
        {
            var ____arg0 = _0.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            fixed (__Internal* __instancePtr = &__instance)
            {
                __Internal.cctor(new __IntPtr(__instancePtr), __arg0);
            }
        }

        public global::DearImguiSharp.VkClearColorValue Color;

        public global::DearImguiSharp.VkClearDepthStencilValue DepthStencil
        {
            get
            {
                return global::DearImguiSharp.VkClearDepthStencilValue.__CreateInstance(__instance.depthStencil);
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                __instance.depthStencil = *(global::DearImguiSharp.VkClearDepthStencilValue.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class VkSurfaceFormatKHR : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.VkFormat format;
            public global::DearImguiSharp.VkColorSpaceKHR colorSpace;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0VkSurfaceFormatKHR@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSurfaceFormatKHR>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.VkSurfaceFormatKHR>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.VkSurfaceFormatKHR managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.VkSurfaceFormatKHR>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.VkSurfaceFormatKHR managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static VkSurfaceFormatKHR __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new VkSurfaceFormatKHR(native.ToPointer(), skipVTables);
        }

        internal static VkSurfaceFormatKHR __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (VkSurfaceFormatKHR)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static VkSurfaceFormatKHR __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new VkSurfaceFormatKHR(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private VkSurfaceFormatKHR(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSurfaceFormatKHR(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public VkSurfaceFormatKHR()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkSurfaceFormatKHR.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public VkSurfaceFormatKHR(global::DearImguiSharp.VkSurfaceFormatKHR _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.VkSurfaceFormatKHR.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.VkSurfaceFormatKHR.__Internal*) __Instance) = *((global::DearImguiSharp.VkSurfaceFormatKHR.__Internal*) _0.__Instance);
        }

        ~VkSurfaceFormatKHR()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.VkFormat Format
        {
            get
            {
                return ((__Internal*)__Instance)->format;
            }

            set
            {
                ((__Internal*)__Instance)->format = value;
            }
        }

        public global::DearImguiSharp.VkColorSpaceKHR ColorSpace
        {
            get
            {
                return ((__Internal*)__Instance)->colorSpace;
            }

            set
            {
                ((__Internal*)__Instance)->colorSpace = value;
            }
        }
    }

    public enum ImGuiInputEventType
    {
        None = 0,
        MousePos = 1,
        MouseWheel = 2,
        MouseButton = 3,
        MouseViewport = 4,
        Key = 5,
        Text = 6,
        Focus = 7,
        COUNT = 8
    }

    public enum ImGuiInputSource
    {
        None = 0,
        Mouse = 1,
        Keyboard = 2,
        Gamepad = 3,
        Clipboard = 4,
        Nav = 5,
        COUNT = 6
    }

    public enum ImGuiNavLayer
    {
        Main = 0,
        Menu = 1,
        COUNT = 2
    }

    public enum ImGuiDockNodeState
    {
        Unknown = 0,
        HostWindowHiddenBecauseSingleWindow = 1,
        HostWindowHiddenBecauseWindowsAreResizing = 2,
        HostWindowVisible = 3
    }

    public enum ImGuiAxis
    {
        None = -1,
        X = 0,
        Y = 1
    }

    public enum ImGuiContextHookType
    {
        NewFramePre = 0,
        NewFramePost = 1,
        EndFramePre = 2,
        EndFramePost = 3,
        RenderPre = 4,
        RenderPost = 5,
        Shutdown = 6,
        PendingRemoval = 7
    }

    public enum ImGuiLogType
    {
        None = 0,
        TTY = 1,
        File = 2,
        Buffer = 3,
        Clipboard = 4
    }

    public enum ImGuiWindowFlags
    {
        None = 0,
        NoTitleBar = 1,
        NoResize = 2,
        NoMove = 4,
        NoScrollbar = 8,
        NoScrollWithMouse = 16,
        NoCollapse = 32,
        AlwaysAutoResize = 64,
        NoBackground = 128,
        NoSavedSettings = 256,
        NoMouseInputs = 512,
        MenuBar = 1024,
        HorizontalScrollbar = 2048,
        NoFocusOnAppearing = 4096,
        NoBringToFrontOnFocus = 8192,
        AlwaysVerticalScrollbar = 16384,
        AlwaysHorizontalScrollbar = 32768,
        AlwaysUseWindowPadding = 65536,
        NoNavInputs = 262144,
        NoNavFocus = 524288,
        UnsavedDocument = 1048576,
        NoDocking = 2097152,
        NoNav = 786432,
        NoDecoration = 43,
        NoInputs = 786944,
        NavFlattened = 8388608,
        ChildWindow = 16777216,
        Tooltip = 33554432,
        Popup = 67108864,
        Modal = 134217728,
        ChildMenu = 268435456,
        DockNodeHost = 536870912
    }

    [Flags]
    public enum ImGuiInputTextFlags
    {
        None = 0,
        CharsDecimal = 1,
        CharsHexadecimal = 2,
        CharsUppercase = 4,
        CharsNoBlank = 8,
        AutoSelectAll = 16,
        EnterReturnsTrue = 32,
        CallbackCompletion = 64,
        CallbackHistory = 128,
        CallbackAlways = 256,
        CallbackCharFilter = 512,
        AllowTabInput = 1024,
        CtrlEnterForNewLine = 2048,
        NoHorizontalScroll = 4096,
        AlwaysOverwrite = 8192,
        ReadOnly = 16384,
        Password = 32768,
        NoUndoRedo = 65536,
        CharsScientific = 131072,
        CallbackResize = 262144,
        CallbackEdit = 524288
    }

    public enum ImGuiTreeNodeFlags
    {
        None = 0,
        Selected = 1,
        Framed = 2,
        AllowItemOverlap = 4,
        NoTreePushOnOpen = 8,
        NoAutoOpenOnLog = 16,
        DefaultOpen = 32,
        OpenOnDoubleClick = 64,
        OpenOnArrow = 128,
        Leaf = 256,
        Bullet = 512,
        FramePadding = 1024,
        SpanAvailWidth = 2048,
        SpanFullWidth = 4096,
        NavLeftJumpsBackHere = 8192,
        CollapsingHeader = 26
    }

    public enum ImGuiPopupFlags
    {
        None = 0,
        MouseButtonLeft = 0,
        MouseButtonRight = 1,
        MouseButtonMiddle = 2,
        MouseButtonMask = 31,
        MouseButtonDefault = 1,
        NoOpenOverExistingPopup = 32,
        NoOpenOverItems = 64,
        AnyPopupId = 128,
        AnyPopupLevel = 256,
        AnyPopup = 384
    }

    [Flags]
    public enum ImGuiSelectableFlags
    {
        None = 0,
        DontClosePopups = 1,
        SpanAllColumns = 2,
        AllowDoubleClick = 4,
        Disabled = 8,
        AllowItemOverlap = 16
    }

    public enum ImGuiComboFlags
    {
        None = 0,
        PopupAlignLeft = 1,
        HeightSmall = 2,
        HeightRegular = 4,
        HeightLarge = 8,
        HeightLargest = 16,
        NoArrowButton = 32,
        NoPreview = 64,
        HeightMask = 30
    }

    public enum ImGuiTabBarFlags
    {
        None = 0,
        Reorderable = 1,
        AutoSelectNewTabs = 2,
        TabListPopupButton = 4,
        NoCloseWithMiddleMouseButton = 8,
        NoTabListScrollingButtons = 16,
        NoTooltip = 32,
        FittingPolicyResizeDown = 64,
        FittingPolicyScroll = 128,
        FittingPolicyMask = 192,
        FittingPolicyDefault = 64
    }

    [Flags]
    public enum ImGuiTabItemFlags
    {
        None = 0,
        UnsavedDocument = 1,
        SetSelected = 2,
        NoCloseWithMiddleMouseButton = 4,
        NoPushId = 8,
        NoTooltip = 16,
        NoReorder = 32,
        Leading = 64,
        Trailing = 128
    }

    public enum ImGuiTableFlags
    {
        None = 0,
        Resizable = 1,
        Reorderable = 2,
        Hideable = 4,
        Sortable = 8,
        NoSavedSettings = 16,
        ContextMenuInBody = 32,
        RowBg = 64,
        BordersInnerH = 128,
        BordersOuterH = 256,
        BordersInnerV = 512,
        BordersOuterV = 1024,
        BordersH = 384,
        BordersV = 1536,
        BordersInner = 640,
        BordersOuter = 1280,
        Borders = 1920,
        NoBordersInBody = 2048,
        NoBordersInBodyUntilResize = 4096,
        SizingFixedFit = 8192,
        SizingFixedSame = 16384,
        SizingStretchProp = 24576,
        SizingStretchSame = 32768,
        NoHostExtendX = 65536,
        NoHostExtendY = 131072,
        NoKeepColumnsVisible = 262144,
        PreciseWidths = 524288,
        NoClip = 1048576,
        PadOuterX = 2097152,
        NoPadOuterX = 4194304,
        NoPadInnerX = 8388608,
        ScrollX = 16777216,
        ScrollY = 33554432,
        SortMulti = 67108864,
        SortTristate = 134217728,
        SizingMask = 57344
    }

    public enum ImGuiTableColumnFlags
    {
        None = 0,
        Disabled = 1,
        DefaultHide = 2,
        DefaultSort = 4,
        WidthStretch = 8,
        WidthFixed = 16,
        NoResize = 32,
        NoReorder = 64,
        NoHide = 128,
        NoClip = 256,
        NoSort = 512,
        NoSortAscending = 1024,
        NoSortDescending = 2048,
        NoHeaderLabel = 4096,
        NoHeaderWidth = 8192,
        PreferSortAscending = 16384,
        PreferSortDescending = 32768,
        IndentEnable = 65536,
        IndentDisable = 131072,
        IsEnabled = 16777216,
        IsVisible = 33554432,
        IsSorted = 67108864,
        IsHovered = 134217728,
        WidthMask = 24,
        IndentMask = 196608,
        StatusMask = 251658240,
        NoDirectResize = 1073741824
    }

    public enum ImGuiTableRowFlags
    {
        None = 0,
        Headers = 1
    }

    public enum ImGuiTableBgTarget
    {
        None = 0,
        RowBg0 = 1,
        RowBg1 = 2,
        CellBg = 3
    }

    public enum ImGuiFocusedFlags
    {
        None = 0,
        ChildWindows = 1,
        RootWindow = 2,
        AnyWindow = 4,
        NoPopupHierarchy = 8,
        DockHierarchy = 16,
        RootAndChildWindows = 3
    }

    public enum ImGuiHoveredFlags
    {
        None = 0,
        ChildWindows = 1,
        RootWindow = 2,
        AnyWindow = 4,
        NoPopupHierarchy = 8,
        DockHierarchy = 16,
        AllowWhenBlockedByPopup = 32,
        AllowWhenBlockedByActiveItem = 128,
        AllowWhenOverlapped = 256,
        AllowWhenDisabled = 512,
        NoNavOverride = 1024,
        RectOnly = 416,
        RootAndChildWindows = 3
    }

    [Flags]
    public enum ImGuiDockNodeFlags
    {
        None = 0,
        KeepAliveOnly = 1,
        NoDockingInCentralNode = 4,
        PassthruCentralNode = 8,
        NoSplit = 16,
        NoResize = 32,
        AutoHideTabBar = 64
    }

    public enum ImGuiDragDropFlags
    {
        None = 0,
        SourceNoPreviewTooltip = 1,
        SourceNoDisableHover = 2,
        SourceNoHoldToOpenOthers = 4,
        SourceAllowNullID = 8,
        SourceExtern = 16,
        SourceAutoExpirePayload = 32,
        AcceptBeforeDelivery = 1024,
        AcceptNoDrawDefaultRect = 2048,
        AcceptNoPreviewTooltip = 4096,
        AcceptPeekOnly = 3072
    }

    public enum ImGuiDataType
    {
        S8 = 0,
        U8 = 1,
        S16 = 2,
        U16 = 3,
        S32 = 4,
        U32 = 5,
        S64 = 6,
        U64 = 7,
        Float = 8,
        Double = 9,
        COUNT = 10
    }

    public enum ImGuiDir
    {
        None = -1,
        Left = 0,
        Right = 1,
        Up = 2,
        Down = 3,
        COUNT = 4
    }

    public enum ImGuiSortDirection
    {
        None = 0,
        Ascending = 1,
        Descending = 2
    }

    public enum ImGuiKey
    {
        None = 0,
        Tab = 512,
        LeftArrow = 513,
        RightArrow = 514,
        UpArrow = 515,
        DownArrow = 516,
        PageUp = 517,
        PageDown = 518,
        Home = 519,
        End = 520,
        Insert = 521,
        Delete = 522,
        Backspace = 523,
        Space = 524,
        Enter = 525,
        Escape = 526,
        LeftCtrl = 527,
        LeftShift = 528,
        LeftAlt = 529,
        LeftSuper = 530,
        RightCtrl = 531,
        RightShift = 532,
        RightAlt = 533,
        RightSuper = 534,
        Menu = 535,
        Zero = 536,
        One = 537,
        Two = 538,
        Three = 539,
        Four = 540,
        Five = 541,
        Six = 542,
        Seven = 543,
        Eight = 544,
        Nine = 545,
        A = 546,
        B = 547,
        C = 548,
        D = 549,
        E = 550,
        F = 551,
        G = 552,
        H = 553,
        I = 554,
        J = 555,
        K = 556,
        L = 557,
        M = 558,
        N = 559,
        O = 560,
        P = 561,
        Q = 562,
        R = 563,
        S = 564,
        T = 565,
        U = 566,
        V = 567,
        W = 568,
        X = 569,
        Y = 570,
        Z = 571,
        F1 = 572,
        F2 = 573,
        F3 = 574,
        F4 = 575,
        F5 = 576,
        F6 = 577,
        F7 = 578,
        F8 = 579,
        F9 = 580,
        F10 = 581,
        F11 = 582,
        F12 = 583,
        Apostrophe = 584,
        Comma = 585,
        Minus = 586,
        Period = 587,
        Slash = 588,
        Semicolon = 589,
        Equal = 590,
        LeftBracket = 591,
        Backslash = 592,
        RightBracket = 593,
        GraveAccent = 594,
        CapsLock = 595,
        ScrollLock = 596,
        NumLock = 597,
        PrintScreen = 598,
        Pause = 599,
        Keypad0 = 600,
        Keypad1 = 601,
        Keypad2 = 602,
        Keypad3 = 603,
        Keypad4 = 604,
        Keypad5 = 605,
        Keypad6 = 606,
        Keypad7 = 607,
        Keypad8 = 608,
        Keypad9 = 609,
        KeypadDecimal = 610,
        KeypadDivide = 611,
        KeypadMultiply = 612,
        KeypadSubtract = 613,
        KeypadAdd = 614,
        KeypadEnter = 615,
        KeypadEqual = 616,
        GamepadStart = 617,
        GamepadBack = 618,
        GamepadFaceUp = 619,
        GamepadFaceDown = 620,
        GamepadFaceLeft = 621,
        GamepadFaceRight = 622,
        GamepadDpadUp = 623,
        GamepadDpadDown = 624,
        GamepadDpadLeft = 625,
        GamepadDpadRight = 626,
        GamepadL1 = 627,
        GamepadR1 = 628,
        GamepadL2 = 629,
        GamepadR2 = 630,
        GamepadL3 = 631,
        GamepadR3 = 632,
        GamepadLStickUp = 633,
        GamepadLStickDown = 634,
        GamepadLStickLeft = 635,
        GamepadLStickRight = 636,
        GamepadRStickUp = 637,
        GamepadRStickDown = 638,
        GamepadRStickLeft = 639,
        GamepadRStickRight = 640,
        ModCtrl = 641,
        ModShift = 642,
        ModAlt = 643,
        ModSuper = 644,
        COUNT = 645,
        NamedKeyBEGIN = 512,
        NamedKeyEND = 645,
        NamedKeyCOUNT = 133,
        KeysDataSIZE = 645,
        KeysDataOFFSET = 0
    }

    [Flags]
    public enum ImGuiModFlags
    {
        None = 0,
        Ctrl = 1,
        Shift = 2,
        Alt = 4,
        Super = 8
    }

    public enum ImGuiNavInput
    {
        Activate = 0,
        Cancel = 1,
        Input = 2,
        Menu = 3,
        DpadLeft = 4,
        DpadRight = 5,
        DpadUp = 6,
        DpadDown = 7,
        LStickLeft = 8,
        LStickRight = 9,
        LStickUp = 10,
        LStickDown = 11,
        FocusPrev = 12,
        FocusNext = 13,
        TweakSlow = 14,
        TweakFast = 15,
        KeyLeft = 16,
        KeyRight = 17,
        KeyUp = 18,
        KeyDown = 19,
        COUNT = 20
    }

    [Flags]
    public enum ImGuiConfigFlags
    {
        None = 0,
        NavEnableKeyboard = 1,
        NavEnableGamepad = 2,
        NavEnableSetMousePos = 4,
        NavNoCaptureKeyboard = 8,
        NoMouse = 16,
        NoMouseCursorChange = 32,
        DockingEnable = 64,
        ViewportsEnable = 1024,
        DpiEnableScaleViewports = 16384,
        DpiEnableScaleFonts = 32768,
        IsSRGB = 1048576,
        IsTouchScreen = 2097152
    }

    [Flags]
    public enum ImGuiBackendFlags
    {
        None = 0,
        HasGamepad = 1,
        HasMouseCursors = 2,
        HasSetMousePos = 4,
        RendererHasVtxOffset = 8,
        PlatformHasViewports = 1024,
        HasMouseHoveredViewport = 2048,
        RendererHasViewports = 4096
    }

    public enum ImGuiCol
    {
        Text = 0,
        TextDisabled = 1,
        WindowBg = 2,
        ChildBg = 3,
        PopupBg = 4,
        Border = 5,
        BorderShadow = 6,
        FrameBg = 7,
        FrameBgHovered = 8,
        FrameBgActive = 9,
        TitleBg = 10,
        TitleBgActive = 11,
        TitleBgCollapsed = 12,
        MenuBarBg = 13,
        ScrollbarBg = 14,
        ScrollbarGrab = 15,
        ScrollbarGrabHovered = 16,
        ScrollbarGrabActive = 17,
        CheckMark = 18,
        SliderGrab = 19,
        SliderGrabActive = 20,
        Button = 21,
        ButtonHovered = 22,
        ButtonActive = 23,
        Header = 24,
        HeaderHovered = 25,
        HeaderActive = 26,
        Separator = 27,
        SeparatorHovered = 28,
        SeparatorActive = 29,
        ResizeGrip = 30,
        ResizeGripHovered = 31,
        ResizeGripActive = 32,
        Tab = 33,
        TabHovered = 34,
        TabActive = 35,
        TabUnfocused = 36,
        TabUnfocusedActive = 37,
        DockingPreview = 38,
        DockingEmptyBg = 39,
        PlotLines = 40,
        PlotLinesHovered = 41,
        PlotHistogram = 42,
        PlotHistogramHovered = 43,
        TableHeaderBg = 44,
        TableBorderStrong = 45,
        TableBorderLight = 46,
        TableRowBg = 47,
        TableRowBgAlt = 48,
        TextSelectedBg = 49,
        DragDropTarget = 50,
        NavHighlight = 51,
        NavWindowingHighlight = 52,
        NavWindowingDimBg = 53,
        ModalWindowDimBg = 54,
        COUNT = 55
    }

    public enum ImGuiStyleVar
    {
        Alpha = 0,
        DisabledAlpha = 1,
        WindowPadding = 2,
        WindowRounding = 3,
        WindowBorderSize = 4,
        WindowMinSize = 5,
        WindowTitleAlign = 6,
        ChildRounding = 7,
        ChildBorderSize = 8,
        PopupRounding = 9,
        PopupBorderSize = 10,
        FramePadding = 11,
        FrameRounding = 12,
        FrameBorderSize = 13,
        ItemSpacing = 14,
        ItemInnerSpacing = 15,
        IndentSpacing = 16,
        CellPadding = 17,
        ScrollbarSize = 18,
        ScrollbarRounding = 19,
        GrabMinSize = 20,
        GrabRounding = 21,
        TabRounding = 22,
        ButtonTextAlign = 23,
        SelectableTextAlign = 24,
        COUNT = 25
    }

    public enum ImGuiButtonFlags
    {
        None = 0,
        MouseButtonLeft = 1,
        MouseButtonRight = 2,
        MouseButtonMiddle = 4,
        MouseButtonMask = 7,
        MouseButtonDefault = 1
    }

    public enum ImGuiColorEditFlags
    {
        None = 0,
        NoAlpha = 2,
        NoPicker = 4,
        NoOptions = 8,
        NoSmallPreview = 16,
        NoInputs = 32,
        NoTooltip = 64,
        NoLabel = 128,
        NoSidePreview = 256,
        NoDragDrop = 512,
        NoBorder = 1024,
        AlphaBar = 65536,
        AlphaPreview = 131072,
        AlphaPreviewHalf = 262144,
        HDR = 524288,
        DisplayRGB = 1048576,
        DisplayHSV = 2097152,
        DisplayHex = 4194304,
        Uint8 = 8388608,
        Float = 16777216,
        PickerHueBar = 33554432,
        PickerHueWheel = 67108864,
        InputRGB = 134217728,
        InputHSV = 268435456,
        DefaultOptions = 177209344,
        DisplayMask = 7340032,
        DataTypeMask = 25165824,
        PickerMask = 100663296,
        InputMask = 402653184
    }

    public enum ImGuiSliderFlags
    {
        None = 0,
        AlwaysClamp = 16,
        Logarithmic = 32,
        NoRoundToFormat = 64,
        NoInput = 128,
        InvalidMask = 1879048207
    }

    public enum ImGuiMouseButton
    {
        Left = 0,
        Right = 1,
        Middle = 2,
        COUNT = 5
    }

    public enum ImGuiMouseCursor
    {
        None = -1,
        Arrow = 0,
        TextInput = 1,
        ResizeAll = 2,
        ResizeNS = 3,
        ResizeEW = 4,
        ResizeNESW = 5,
        ResizeNWSE = 6,
        Hand = 7,
        NotAllowed = 8,
        COUNT = 9
    }

    [Flags]
    public enum ImGuiCond
    {
        None = 0,
        Always = 1,
        Once = 2,
        FirstUseEver = 4,
        Appearing = 8
    }

    public enum ImDrawFlags
    {
        ImDrawFlagsNone = 0,
        ImDrawFlagsClosed = 1,
        ImDrawFlagsRoundCornersTopLeft = 16,
        ImDrawFlagsRoundCornersTopRight = 32,
        ImDrawFlagsRoundCornersBottomLeft = 64,
        ImDrawFlagsRoundCornersBottomRight = 128,
        ImDrawFlagsRoundCornersNone = 256,
        ImDrawFlagsRoundCornersTop = 48,
        ImDrawFlagsRoundCornersBottom = 192,
        ImDrawFlagsRoundCornersLeft = 80,
        ImDrawFlagsRoundCornersRight = 160,
        ImDrawFlagsRoundCornersAll = 240,
        ImDrawFlagsRoundCornersDefault = 240,
        ImDrawFlagsRoundCornersMask = 496
    }

    [Flags]
    public enum ImDrawListFlags
    {
        ImDrawListFlagsNone = 0,
        ImDrawListFlagsAntiAliasedLines = 1,
        ImDrawListFlagsAntiAliasedLinesUseTex = 2,
        ImDrawListFlagsAntiAliasedFill = 4,
        ImDrawListFlagsAllowVtxOffset = 8
    }

    [Flags]
    public enum ImFontAtlasFlags
    {
        ImFontAtlasFlagsNone = 0,
        ImFontAtlasFlagsNoPowerOfTwoHeight = 1,
        ImFontAtlasFlagsNoMouseCursors = 2,
        ImFontAtlasFlagsNoBakedLines = 4
    }

    [Flags]
    public enum ImGuiViewportFlags
    {
        None = 0,
        IsPlatformWindow = 1,
        IsPlatformMonitor = 2,
        OwnedByApp = 4,
        NoDecoration = 8,
        NoTaskBarIcon = 16,
        NoFocusOnAppearing = 32,
        NoFocusOnClick = 64,
        NoInputs = 128,
        NoRendererClear = 256,
        TopMost = 512,
        Minimized = 1024,
        NoAutoMerge = 2048,
        CanHostOtherWindows = 4096
    }

    [Flags]
    public enum ImGuiItemFlags
    {
        None = 0,
        NoTabStop = 1,
        ButtonRepeat = 2,
        Disabled = 4,
        NoNav = 8,
        NoNavDefaultFocus = 16,
        SelectableDontClosePopup = 32,
        MixedValue = 64,
        ReadOnly = 128,
        Inputable = 256
    }

    [Flags]
    public enum ImGuiItemStatusFlags
    {
        None = 0,
        HoveredRect = 1,
        HasDisplayRect = 2,
        Edited = 4,
        ToggledSelection = 8,
        ToggledOpen = 16,
        HasDeactivated = 32,
        Deactivated = 64,
        HoveredWindow = 128,
        FocusedByTabbing = 256
    }

    [Flags]
    public enum ImGuiInputTextFlagsPrivate
    {
        ImGuiInputTextFlagsMultiline = 67108864,
        ImGuiInputTextFlagsNoMarkEdited = 134217728,
        ImGuiInputTextFlagsMergedItem = 268435456
    }

    public enum ImGuiButtonFlagsPrivate
    {
        ImGuiButtonFlagsPressedOnClick = 16,
        ImGuiButtonFlagsPressedOnClickRelease = 32,
        ImGuiButtonFlagsPressedOnClickReleaseAnywhere = 64,
        ImGuiButtonFlagsPressedOnRelease = 128,
        ImGuiButtonFlagsPressedOnDoubleClick = 256,
        ImGuiButtonFlagsPressedOnDragDropHold = 512,
        ImGuiButtonFlagsRepeat = 1024,
        ImGuiButtonFlagsFlattenChildren = 2048,
        ImGuiButtonFlagsAllowItemOverlap = 4096,
        ImGuiButtonFlagsDontClosePopups = 8192,
        ImGuiButtonFlagsAlignTextBaseLine = 32768,
        ImGuiButtonFlagsNoKeyModifiers = 65536,
        ImGuiButtonFlagsNoHoldingActiveId = 131072,
        ImGuiButtonFlagsNoNavFocus = 262144,
        ImGuiButtonFlagsNoHoveredOnFocus = 524288,
        ImGuiButtonFlagsPressedOnMask = 1008,
        ImGuiButtonFlagsPressedOnDefault = 32
    }

    [Flags]
    public enum ImGuiComboFlagsPrivate
    {
        ImGuiComboFlagsCustomPreview = 1048576
    }

    [Flags]
    public enum ImGuiSliderFlagsPrivate
    {
        ImGuiSliderFlagsVertical = 1048576,
        ImGuiSliderFlagsReadOnly = 2097152
    }

    [Flags]
    public enum ImGuiSelectableFlagsPrivate
    {
        ImGuiSelectableFlagsNoHoldingActiveID = 1048576,
        ImGuiSelectableFlagsSelectOnNav = 2097152,
        ImGuiSelectableFlagsSelectOnClick = 4194304,
        ImGuiSelectableFlagsSelectOnRelease = 8388608,
        ImGuiSelectableFlagsSpanAvailWidth = 16777216,
        ImGuiSelectableFlagsDrawHoveredWhenHeld = 33554432,
        ImGuiSelectableFlagsSetNavIdOnHover = 67108864,
        ImGuiSelectableFlagsNoPadWithHalfSpacing = 134217728
    }

    [Flags]
    public enum ImGuiTreeNodeFlagsPrivate
    {
        ImGuiTreeNodeFlagsClipLabelForTrailingButton = 1048576
    }

    [Flags]
    public enum ImGuiSeparatorFlags
    {
        None = 0,
        Horizontal = 1,
        Vertical = 2,
        SpanAllColumns = 4
    }

    public enum ImGuiTextFlags
    {
        None = 0,
        NoWidthForLargeClippedText = 1
    }

    public enum ImGuiTooltipFlags
    {
        None = 0,
        OverridePreviousTooltip = 1
    }

    public enum ImGuiLayoutType
    {
        Horizontal = 0,
        Vertical = 1
    }

    public enum ImGuiPlotType
    {
        Lines = 0,
        Histogram = 1
    }

    public enum ImGuiPopupPositionPolicy
    {
        Default = 0,
        ComboBox = 1,
        Tooltip = 2
    }

    public enum ImGuiDataTypePrivate
    {
        ImGuiDataTypeString = 11,
        ImGuiDataTypePointer = 12,
        ImGuiDataTypeID = 13
    }

    [Flags]
    public enum ImGuiNextWindowDataFlags
    {
        None = 0,
        HasPos = 1,
        HasSize = 2,
        HasContentSize = 4,
        HasCollapsed = 8,
        HasSizeConstraint = 16,
        HasFocus = 32,
        HasBgAlpha = 64,
        HasScroll = 128,
        HasViewport = 256,
        HasDock = 512,
        HasWindowClass = 1024
    }

    public enum ImGuiNextItemDataFlags
    {
        None = 0,
        HasWidth = 1,
        HasOpen = 2
    }

    public enum ImGuiKeyPrivate
    {
        ImGuiKeyLegacyNativeKeyBEGIN = 0,
        ImGuiKeyLegacyNativeKeyEND = 512,
        ImGuiKeyGamepadBEGIN = 617,
        ImGuiKeyGamepadEND = 641
    }

    public enum ImGuiNavReadMode
    {
        Down = 0,
        Pressed = 1,
        Released = 2,
        Repeat = 3,
        RepeatSlow = 4,
        RepeatFast = 5
    }

    [Flags]
    public enum ImGuiActivateFlags
    {
        None = 0,
        PreferInput = 1,
        PreferTweak = 2,
        TryToPreserveState = 4
    }

    public enum ImGuiScrollFlags
    {
        None = 0,
        KeepVisibleEdgeX = 1,
        KeepVisibleEdgeY = 2,
        KeepVisibleCenterX = 4,
        KeepVisibleCenterY = 8,
        AlwaysCenterX = 16,
        AlwaysCenterY = 32,
        NoScrollParent = 64,
        MaskX_ = 21,
        MaskY_ = 42
    }

    [Flags]
    public enum ImGuiNavHighlightFlags
    {
        None = 0,
        TypeDefault = 1,
        TypeThin = 2,
        AlwaysDraw = 4,
        NoRounding = 8
    }

    [Flags]
    public enum ImGuiNavDirSourceFlags
    {
        None = 0,
        RawKeyboard = 1,
        Keyboard = 2,
        PadDPad = 4,
        PadLStick = 8
    }

    [Flags]
    public enum ImGuiNavMoveFlags
    {
        None = 0,
        LoopX = 1,
        LoopY = 2,
        WrapX = 4,
        WrapY = 8,
        AllowCurrentNavId = 16,
        AlsoScoreVisibleSet = 32,
        ScrollToEdgeY = 64,
        Forwarded = 128,
        DebugNoResult = 256,
        FocusApi = 512,
        Tabbing = 1024,
        Activate = 2048,
        DontSetNavHighlight = 4096
    }

    [Flags]
    public enum ImGuiOldColumnFlags
    {
        None = 0,
        NoBorder = 1,
        NoResize = 2,
        NoPreserveWidths = 4,
        NoForceWithinWindow = 8,
        GrowParentContentsSize = 16
    }

    public enum ImGuiDockNodeFlagsPrivate
    {
        ImGuiDockNodeFlagsDockSpace = 1024,
        ImGuiDockNodeFlagsCentralNode = 2048,
        ImGuiDockNodeFlagsNoTabBar = 4096,
        ImGuiDockNodeFlagsHiddenTabBar = 8192,
        ImGuiDockNodeFlagsNoWindowMenuButton = 16384,
        ImGuiDockNodeFlagsNoCloseButton = 32768,
        ImGuiDockNodeFlagsNoDocking = 65536,
        ImGuiDockNodeFlagsNoDockingSplitMe = 131072,
        ImGuiDockNodeFlagsNoDockingSplitOther = 262144,
        ImGuiDockNodeFlagsNoDockingOverMe = 524288,
        ImGuiDockNodeFlagsNoDockingOverOther = 1048576,
        ImGuiDockNodeFlagsNoDockingOverEmpty = 2097152,
        ImGuiDockNodeFlagsNoResizeX = 4194304,
        ImGuiDockNodeFlagsNoResizeY = 8388608,
        ImGuiDockNodeFlagsSharedFlagsInheritMask = -1,
        ImGuiDockNodeFlagsNoResizeFlagsMask = 12582944,
        ImGuiDockNodeFlagsLocalFlagsMask = 12713072,
        ImGuiDockNodeFlagsLocalFlagsTransferMask = 12712048,
        ImGuiDockNodeFlagsSavedFlagsMask = 12712992
    }

    public enum ImGuiDataAuthority
    {
        Auto = 0,
        DockNode = 1,
        Window = 2
    }

    public enum ImGuiWindowDockStyleCol
    {
        Text = 0,
        Tab = 1,
        TabHovered = 2,
        TabActive = 3,
        TabUnfocused = 4,
        TabUnfocusedActive = 5,
        COUNT = 6
    }

    public enum ImGuiDebugLogFlags
    {
        None = 0,
        EventActiveId = 1,
        EventFocus = 2,
        EventPopup = 4,
        EventNav = 8,
        EventIO = 16,
        EventDocking = 32,
        EventViewport = 64,
        EventMask = 127,
        OutputToTTY = 1024
    }

    [Flags]
    public enum ImGuiTabBarFlagsPrivate
    {
        ImGuiTabBarFlagsDockNode = 1048576,
        ImGuiTabBarFlagsIsFocused = 2097152,
        ImGuiTabBarFlagsSaveSettings = 4194304
    }

    public enum ImGuiTabItemFlagsPrivate
    {
        ImGuiTabItemFlagsSectionMask = 192,
        ImGuiTabItemFlagsNoCloseButton = 1048576,
        ImGuiTabItemFlagsButton = 2097152,
        ImGuiTabItemFlagsUnsorted = 4194304,
        ImGuiTabItemFlagsPreview = 8388608
    }

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImDrawCallback(__IntPtr parent_list, __IntPtr cmd);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiSizeCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiContextHookCallback(__IntPtr ctx, __IntPtr hook);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate int ImGuiInputTextCallback(__IntPtr data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate __IntPtr ImGuiMemAllocFunc(IntPtr sz, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiMemFreeFunc(__IntPtr ptr, __IntPtr user_data);

    [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
    public unsafe delegate void ImGuiErrorLogCallback(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

    public unsafe partial class ImGuiDockRequest
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockRequest>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockRequest>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDockRequest managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDockRequest>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDockRequest managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDockRequest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDockRequest(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDockRequest __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDockRequest)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDockRequest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDockRequest(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDockRequest(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockRequest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGuiDockNodeSettings
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockNodeSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockNodeSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDockNodeSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDockNodeSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDockNodeSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDockNodeSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDockNodeSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDockNodeSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDockNodeSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDockNodeSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDockNodeSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDockNodeSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockNodeSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGuiTableColumnsSettings
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnsSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnsSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableColumnsSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnsSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableColumnsSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnsSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnsSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnsSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnsSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnsSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnsSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnsSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnsSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float x;
            public float y;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr IhImVec2ihVec2(__IntPtr __instance);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec2>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec2>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVec2 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVec2>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVec2 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2(global::DearImguiSharp.ImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVec2.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec2.__Internal*) _0.__Instance);
        }

        ~ImVec2()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public global::DearImguiSharp.ImVec2ih IhImVec2ihVec2
        {
            get
            {
                var __ret = __Internal.IhImVec2ihVec2(__Instance);
                var __result0 = global::DearImguiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }
    }

    public unsafe partial class ImVector_const_charPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_const_charPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_const_charPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_const_charPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVector_const_charPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVector_const_charPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVector_const_charPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_const_charPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_const_charPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVector_const_charPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_const_charPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_const_charPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_const_charPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_const_charPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_const_charPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_const_charPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_const_charPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_const_charPtr(global::DearImguiSharp.ImVector_const_charPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_const_charPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVector_const_charPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_const_charPtr.__Internal*) _0.__Instance);
        }

        ~ImVector_const_charPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }
    }

    public unsafe partial class ImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public float x;
            public float y;
            public float z;
            public float w;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec4>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec4>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVec4 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVec4>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVec4 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec4(global::DearImguiSharp.ImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVec4.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec4.__Internal*) _0.__Instance);
        }

        ~ImVec4()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public float Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }

        public float Z
        {
            get
            {
                return ((__Internal*)__Instance)->z;
            }

            set
            {
                ((__Internal*)__Instance)->z = value;
            }
        }

        public float W
        {
            get
            {
                return ((__Internal*)__Instance)->w;
            }

            set
            {
                ((__Internal*)__Instance)->w = value;
            }
        }
    }

    public unsafe partial class ImGuiStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1080)]
        public partial struct __Internal
        {
            public float Alpha;
            public float DisabledAlpha;
            public global::DearImguiSharp.ImVec2.__Internal WindowPadding;
            public float WindowRounding;
            public float WindowBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal WindowMinSize;
            public global::DearImguiSharp.ImVec2.__Internal WindowTitleAlign;
            public int WindowMenuButtonPosition;
            public float ChildRounding;
            public float ChildBorderSize;
            public float PopupRounding;
            public float PopupBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal FramePadding;
            public float FrameRounding;
            public float FrameBorderSize;
            public global::DearImguiSharp.ImVec2.__Internal ItemSpacing;
            public global::DearImguiSharp.ImVec2.__Internal ItemInnerSpacing;
            public global::DearImguiSharp.ImVec2.__Internal CellPadding;
            public global::DearImguiSharp.ImVec2.__Internal TouchExtraPadding;
            public float IndentSpacing;
            public float ColumnsMinSpacing;
            public float ScrollbarSize;
            public float ScrollbarRounding;
            public float GrabMinSize;
            public float GrabRounding;
            public float LogSliderDeadzone;
            public float TabRounding;
            public float TabBorderSize;
            public float TabMinWidthForCloseButton;
            public int ColorButtonPosition;
            public global::DearImguiSharp.ImVec2.__Internal ButtonTextAlign;
            public global::DearImguiSharp.ImVec2.__Internal SelectableTextAlign;
            public global::DearImguiSharp.ImVec2.__Internal DisplayWindowPadding;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySafeAreaPadding;
            public float MouseCursorScale;
            public byte AntiAliasedLines;
            public byte AntiAliasedLinesUseTex;
            public byte AntiAliasedFill;
            public float CurveTessellationTol;
            public float CircleTessellationMaxError;
            public fixed byte Colors[880];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStyle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStyle>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStyle>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStyle managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStyle>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStyle managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyle(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyle(global::DearImguiSharp.ImGuiStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStyle.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStyle.__Internal*) _0.__Instance);
        }

        ~ImGuiStyle()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->Alpha;
            }

            set
            {
                ((__Internal*)__Instance)->Alpha = value;
            }
        }

        public float DisabledAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledAlpha = value;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowMinSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowMinSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowMinSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowTitleAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowTitleAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowTitleAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int WindowMenuButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->WindowMenuButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->WindowMenuButtonPosition = value;
            }
        }

        public float ChildRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ChildRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ChildRounding = value;
            }
        }

        public float ChildBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->ChildBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->ChildBorderSize = value;
            }
        }

        public float PopupRounding
        {
            get
            {
                return ((__Internal*)__Instance)->PopupRounding;
            }

            set
            {
                ((__Internal*)__Instance)->PopupRounding = value;
            }
        }

        public float PopupBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->PopupBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->PopupBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 FramePadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float FrameRounding
        {
            get
            {
                return ((__Internal*)__Instance)->FrameRounding;
            }

            set
            {
                ((__Internal*)__Instance)->FrameRounding = value;
            }
        }

        public float FrameBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->FrameBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->FrameBorderSize = value;
            }
        }

        public global::DearImguiSharp.ImVec2 ItemSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ItemInnerSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemInnerSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemInnerSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CellPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CellPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CellPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 TouchExtraPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TouchExtraPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TouchExtraPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float IndentSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->IndentSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->IndentSpacing = value;
            }
        }

        public float ColumnsMinSpacing
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsMinSpacing;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsMinSpacing = value;
            }
        }

        public float ScrollbarSize
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarSize;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarSize = value;
            }
        }

        public float ScrollbarRounding
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarRounding;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarRounding = value;
            }
        }

        public float GrabMinSize
        {
            get
            {
                return ((__Internal*)__Instance)->GrabMinSize;
            }

            set
            {
                ((__Internal*)__Instance)->GrabMinSize = value;
            }
        }

        public float GrabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->GrabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->GrabRounding = value;
            }
        }

        public float LogSliderDeadzone
        {
            get
            {
                return ((__Internal*)__Instance)->LogSliderDeadzone;
            }

            set
            {
                ((__Internal*)__Instance)->LogSliderDeadzone = value;
            }
        }

        public float TabRounding
        {
            get
            {
                return ((__Internal*)__Instance)->TabRounding;
            }

            set
            {
                ((__Internal*)__Instance)->TabRounding = value;
            }
        }

        public float TabBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->TabBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->TabBorderSize = value;
            }
        }

        public float TabMinWidthForCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->TabMinWidthForCloseButton;
            }

            set
            {
                ((__Internal*)__Instance)->TabMinWidthForCloseButton = value;
            }
        }

        public int ColorButtonPosition
        {
            get
            {
                return ((__Internal*)__Instance)->ColorButtonPosition;
            }

            set
            {
                ((__Internal*)__Instance)->ColorButtonPosition = value;
            }
        }

        public global::DearImguiSharp.ImVec2 ButtonTextAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ButtonTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ButtonTextAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SelectableTextAlign
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SelectableTextAlign));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SelectableTextAlign = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayWindowPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayWindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayWindowPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySafeAreaPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySafeAreaPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySafeAreaPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float MouseCursorScale
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursorScale;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursorScale = value;
            }
        }

        public bool AntiAliasedLines
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLines != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLines = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedLinesUseTex
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedLinesUseTex != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedLinesUseTex = (byte) (value ? 1 : 0);
            }
        }

        public bool AntiAliasedFill
        {
            get
            {
                return ((__Internal*)__Instance)->AntiAliasedFill != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AntiAliasedFill = (byte) (value ? 1 : 0);
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleTessellationMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleTessellationMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleTessellationMaxError = value;
            }
        }

        public global::DearImguiSharp.ImVec4[] Colors
        {
            get
            {
                global::DearImguiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->Colors != null)
                {
                    __value = new global::DearImguiSharp.ImVec4[55];
                    for (int i = 0; i < 55; i++)
                        __value[i] = global::DearImguiSharp.ImVec4.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->Colors[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 55)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 55; i++)
                        *(global::DearImguiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->Colors[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)] = *(global::DearImguiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiKeyData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte Down;
            public float DownDuration;
            public float DownDurationPrev;
            public float AnalogValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiKeyData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiKeyData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiKeyData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiKeyData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiKeyData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiKeyData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiKeyData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiKeyData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiKeyData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiKeyData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiKeyData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiKeyData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiKeyData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiKeyData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiKeyData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiKeyData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiKeyData(global::DearImguiSharp.ImGuiKeyData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiKeyData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiKeyData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiKeyData.__Internal*) _0.__Instance);
        }

        ~ImGuiKeyData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }

        public float DownDuration
        {
            get
            {
                return ((__Internal*)__Instance)->DownDuration;
            }

            set
            {
                ((__Internal*)__Instance)->DownDuration = value;
            }
        }

        public float DownDurationPrev
        {
            get
            {
                return ((__Internal*)__Instance)->DownDurationPrev;
            }

            set
            {
                ((__Internal*)__Instance)->DownDurationPrev = value;
            }
        }

        public float AnalogValue
        {
            get
            {
                return ((__Internal*)__Instance)->AnalogValue;
            }

            set
            {
                ((__Internal*)__Instance)->AnalogValue = value;
            }
        }
    }

    public unsafe partial class ImVectorImWchar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImWchar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImWchar>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImWchar>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImWchar managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImWchar>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImWchar managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImWchar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImWchar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImWchar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImWchar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImWchar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImWchar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImWchar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImWchar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImWchar(global::DearImguiSharp.ImVectorImWchar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImWchar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImWchar.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImWchar.__Internal*) _0.__Instance);
        }

        ~ImVectorImWchar()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 14344)]
        public partial struct __Internal
        {
            public int ConfigFlags;
            public int BackendFlags;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySize;
            public float DeltaTime;
            public float IniSavingRate;
            public __IntPtr IniFilename;
            public __IntPtr LogFilename;
            public float MouseDoubleClickTime;
            public float MouseDoubleClickMaxDist;
            public float MouseDragThreshold;
            public float KeyRepeatDelay;
            public float KeyRepeatRate;
            public __IntPtr UserData;
            public __IntPtr Fonts;
            public float FontGlobalScale;
            public byte FontAllowUserScaling;
            public __IntPtr FontDefault;
            public global::DearImguiSharp.ImVec2.__Internal DisplayFramebufferScale;
            public byte ConfigDockingNoSplit;
            public byte ConfigDockingWithShift;
            public byte ConfigDockingAlwaysTabBar;
            public byte ConfigDockingTransparentPayload;
            public byte ConfigViewportsNoAutoMerge;
            public byte ConfigViewportsNoTaskBarIcon;
            public byte ConfigViewportsNoDecoration;
            public byte ConfigViewportsNoDefaultParent;
            public byte MouseDrawCursor;
            public byte ConfigMacOSXBehaviors;
            public byte ConfigInputTrickleEventQueue;
            public byte ConfigInputTextCursorBlink;
            public byte ConfigDragClickToInputText;
            public byte ConfigWindowsResizeFromEdges;
            public byte ConfigWindowsMoveFromTitleBarOnly;
            public float ConfigMemoryCompactTimer;
            public __IntPtr BackendPlatformName;
            public __IntPtr BackendRendererName;
            public __IntPtr BackendPlatformUserData;
            public __IntPtr BackendRendererUserData;
            public __IntPtr BackendLanguageUserData;
            public __IntPtr GetClipboardTextFn;
            public __IntPtr SetClipboardTextFn;
            public __IntPtr ClipboardUserData;
            public __IntPtr SetPlatformImeDataFn;
            public __IntPtr _UnusedPadding;
            public byte WantCaptureMouse;
            public byte WantCaptureKeyboard;
            public byte WantTextInput;
            public byte WantSetMousePos;
            public byte WantSaveIniSettings;
            public byte NavActive;
            public byte NavVisible;
            public float Framerate;
            public int MetricsRenderVertices;
            public int MetricsRenderIndices;
            public int MetricsRenderWindows;
            public int MetricsActiveWindows;
            public int MetricsActiveAllocations;
            public global::DearImguiSharp.ImVec2.__Internal MouseDelta;
            public fixed int KeyMap[645];
            public fixed byte KeysDown[645];
            public global::DearImguiSharp.ImVec2.__Internal MousePos;
            public fixed byte MouseDown[5];
            public float MouseWheel;
            public float MouseWheelH;
            public uint MouseHoveredViewport;
            public byte KeyCtrl;
            public byte KeyShift;
            public byte KeyAlt;
            public byte KeySuper;
            public fixed float NavInputs[20];
            public int KeyMods;
            public fixed byte KeysData[10320];
            public byte WantCaptureMouseUnlessPopupClose;
            public global::DearImguiSharp.ImVec2.__Internal MousePosPrev;
            public fixed byte MouseClickedPos[40];
            public fixed double MouseClickedTime[5];
            public fixed byte MouseClicked[5];
            public fixed byte MouseDoubleClicked[5];
            public fixed ushort MouseClickedCount[5];
            public fixed ushort MouseClickedLastCount[5];
            public fixed byte MouseReleased[5];
            public fixed byte MouseDownOwned[5];
            public fixed byte MouseDownOwnedUnlessPopupClose[5];
            public fixed float MouseDownDuration[5];
            public fixed float MouseDownDurationPrev[5];
            public fixed byte MouseDragMaxDistanceAbs[40];
            public fixed float MouseDragMaxDistanceSqr[5];
            public fixed float NavInputsDownDuration[20];
            public fixed float NavInputsDownDurationPrev[20];
            public float PenPressure;
            public byte AppFocusLost;
            public byte AppAcceptingEvents;
            public sbyte BackendUsingLegacyKeyArrays;
            public byte BackendUsingLegacyNavInputArray;
            public ushort InputQueueSurrogate;
            public global::DearImguiSharp.ImVectorImWchar.__Internal InputQueueCharacters;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiIO>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiIO>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiIO managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiIO>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiIO managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool __IniFilename_OwnsNativeMemory = false;
        private bool __LogFilename_OwnsNativeMemory = false;
        private bool __BackendPlatformName_OwnsNativeMemory = false;
        private bool __BackendRendererName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiIO(global::DearImguiSharp.ImGuiIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiIO.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiIO.__Internal*) _0.__Instance);
            if (_0.__IniFilename_OwnsNativeMemory)
                this.IniFilename = _0.IniFilename;
            if (_0.__LogFilename_OwnsNativeMemory)
                this.LogFilename = _0.LogFilename;
            if (_0.__BackendPlatformName_OwnsNativeMemory)
                this.BackendPlatformName = _0.BackendPlatformName;
            if (_0.__BackendRendererName_OwnsNativeMemory)
                this.BackendRendererName = _0.BackendRendererName;
        }

        ~ImGuiIO()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__IniFilename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->IniFilename);
            if (__LogFilename_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogFilename);
            if (__BackendPlatformName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendPlatformName);
            if (__BackendRendererName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendRendererName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int ConfigFlags
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlags;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlags = value;
            }
        }

        public int BackendFlags
        {
            get
            {
                return ((__Internal*)__Instance)->BackendFlags;
            }

            set
            {
                ((__Internal*)__Instance)->BackendFlags = value;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DeltaTime
        {
            get
            {
                return ((__Internal*)__Instance)->DeltaTime;
            }

            set
            {
                ((__Internal*)__Instance)->DeltaTime = value;
            }
        }

        public float IniSavingRate
        {
            get
            {
                return ((__Internal*)__Instance)->IniSavingRate;
            }

            set
            {
                ((__Internal*)__Instance)->IniSavingRate = value;
            }
        }

        public string IniFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->IniFilename);
            }

            set
            {
                if (__IniFilename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->IniFilename);
                __IniFilename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->IniFilename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->IniFilename = (__IntPtr) __bytePtr0;
            }
        }

        public string LogFilename
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogFilename);
            }

            set
            {
                if (__LogFilename_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogFilename);
                __LogFilename_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogFilename = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogFilename = (__IntPtr) __bytePtr0;
            }
        }

        public float MouseDoubleClickTime
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickTime;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickTime = value;
            }
        }

        public float MouseDoubleClickMaxDist
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDoubleClickMaxDist;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDoubleClickMaxDist = value;
            }
        }

        public float MouseDragThreshold
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDragThreshold;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDragThreshold = value;
            }
        }

        public float KeyRepeatDelay
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatDelay;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatDelay = value;
            }
        }

        public float KeyRepeatRate
        {
            get
            {
                return ((__Internal*)__Instance)->KeyRepeatRate;
            }

            set
            {
                ((__Internal*)__Instance)->KeyRepeatRate = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImFontAtlas Fonts
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->Fonts, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Fonts = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontGlobalScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontGlobalScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontGlobalScale = value;
            }
        }

        public bool FontAllowUserScaling
        {
            get
            {
                return ((__Internal*)__Instance)->FontAllowUserScaling != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAllowUserScaling = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImFont FontDefault
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->FontDefault, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDefault = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayFramebufferScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayFramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayFramebufferScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool ConfigDockingNoSplit
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingNoSplit != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingNoSplit = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDockingWithShift
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingWithShift != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingWithShift = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDockingAlwaysTabBar
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingAlwaysTabBar != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingAlwaysTabBar = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDockingTransparentPayload
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDockingTransparentPayload != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDockingTransparentPayload = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoAutoMerge
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoAutoMerge != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoAutoMerge = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoTaskBarIcon
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoTaskBarIcon != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoTaskBarIcon = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoDecoration
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoDecoration != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoDecoration = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigViewportsNoDefaultParent
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigViewportsNoDefaultParent != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigViewportsNoDefaultParent = (byte) (value ? 1 : 0);
            }
        }

        public bool MouseDrawCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseDrawCursor != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseDrawCursor = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigMacOSXBehaviors
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMacOSXBehaviors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMacOSXBehaviors = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTrickleEventQueue
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTrickleEventQueue != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTrickleEventQueue = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigInputTextCursorBlink
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigInputTextCursorBlink != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigInputTextCursorBlink = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigDragClickToInputText
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDragClickToInputText != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDragClickToInputText = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsResizeFromEdges
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsResizeFromEdges = (byte) (value ? 1 : 0);
            }
        }

        public bool ConfigWindowsMoveFromTitleBarOnly
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigWindowsMoveFromTitleBarOnly = (byte) (value ? 1 : 0);
            }
        }

        public float ConfigMemoryCompactTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigMemoryCompactTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigMemoryCompactTimer = value;
            }
        }

        public string BackendPlatformName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendPlatformName);
            }

            set
            {
                if (__BackendPlatformName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendPlatformName);
                __BackendPlatformName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->BackendPlatformName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->BackendPlatformName = (__IntPtr) __bytePtr0;
            }
        }

        public string BackendRendererName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->BackendRendererName);
            }

            set
            {
                if (__BackendRendererName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->BackendRendererName);
                __BackendRendererName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->BackendRendererName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->BackendRendererName = (__IntPtr) __bytePtr0;
            }
        }

        public __IntPtr BackendPlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendPlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendPlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendRendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendRendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendRendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr BackendLanguageUserData
        {
            get
            {
                return ((__Internal*)__Instance)->BackendLanguageUserData;
            }

            set
            {
                ((__Internal*)__Instance)->BackendLanguageUserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr GetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->GetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->GetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_string8 SetClipboardTextFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetClipboardTextFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->SetClipboardTextFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr ClipboardUserData
        {
            get
            {
                return ((__Internal*)__Instance)->ClipboardUserData;
            }

            set
            {
                ((__Internal*)__Instance)->ClipboardUserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr SetPlatformImeDataFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SetPlatformImeDataFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->SetPlatformImeDataFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UnusedPadding
        {
            get
            {
                return ((__Internal*)__Instance)->_UnusedPadding;
            }

            set
            {
                ((__Internal*)__Instance)->_UnusedPadding = (__IntPtr) value;
            }
        }

        public bool WantCaptureMouse
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouse != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouse = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCaptureKeyboard
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboard != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboard = (byte) (value ? 1 : 0);
            }
        }

        public bool WantTextInput
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInput = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSetMousePos
        {
            get
            {
                return ((__Internal*)__Instance)->WantSetMousePos != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSetMousePos = (byte) (value ? 1 : 0);
            }
        }

        public bool WantSaveIniSettings
        {
            get
            {
                return ((__Internal*)__Instance)->WantSaveIniSettings != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantSaveIniSettings = (byte) (value ? 1 : 0);
            }
        }

        public bool NavActive
        {
            get
            {
                return ((__Internal*)__Instance)->NavActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavActive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavVisible
        {
            get
            {
                return ((__Internal*)__Instance)->NavVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavVisible = (byte) (value ? 1 : 0);
            }
        }

        public float Framerate
        {
            get
            {
                return ((__Internal*)__Instance)->Framerate;
            }

            set
            {
                ((__Internal*)__Instance)->Framerate = value;
            }
        }

        public int MetricsRenderVertices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderVertices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderVertices = value;
            }
        }

        public int MetricsRenderIndices
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderIndices;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderIndices = value;
            }
        }

        public int MetricsRenderWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsRenderWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsRenderWindows = value;
            }
        }

        public int MetricsActiveWindows
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveWindows;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveWindows = value;
            }
        }

        public int MetricsActiveAllocations
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsActiveAllocations;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsActiveAllocations = value;
            }
        }

        public global::DearImguiSharp.ImVec2 MouseDelta
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseDelta));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseDelta = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int[] KeyMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->KeyMap, 645);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 645; i++)
                        ((__Internal*)__Instance)->KeyMap[i] = value[i];
                }
            }
        }

        public bool[] KeysDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->KeysDown, 645);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 645; i++)
                        ((__Internal*)__Instance)->KeysDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public global::DearImguiSharp.ImVec2 MousePos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool[] MouseDown
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDown, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDown[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float MouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheel;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheel = value;
            }
        }

        public float MouseWheelH
        {
            get
            {
                return ((__Internal*)__Instance)->MouseWheelH;
            }

            set
            {
                ((__Internal*)__Instance)->MouseWheelH = value;
            }
        }

        public uint MouseHoveredViewport
        {
            get
            {
                return ((__Internal*)__Instance)->MouseHoveredViewport;
            }

            set
            {
                ((__Internal*)__Instance)->MouseHoveredViewport = value;
            }
        }

        public bool KeyCtrl
        {
            get
            {
                return ((__Internal*)__Instance)->KeyCtrl != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyCtrl = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyShift
        {
            get
            {
                return ((__Internal*)__Instance)->KeyShift != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyShift = (byte) (value ? 1 : 0);
            }
        }

        public bool KeyAlt
        {
            get
            {
                return ((__Internal*)__Instance)->KeyAlt != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeyAlt = (byte) (value ? 1 : 0);
            }
        }

        public bool KeySuper
        {
            get
            {
                return ((__Internal*)__Instance)->KeySuper != 0;
            }

            set
            {
                ((__Internal*)__Instance)->KeySuper = (byte) (value ? 1 : 0);
            }
        }

        public float[] NavInputs
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputs, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputs[i] = value[i];
                }
            }
        }

        public int KeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->KeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->KeyMods = value;
            }
        }

        public global::DearImguiSharp.ImGuiKeyData[] KeysData
        {
            get
            {
                global::DearImguiSharp.ImGuiKeyData[] __value = null;
                if (((__Internal*)__Instance)->KeysData != null)
                {
                    __value = new global::DearImguiSharp.ImGuiKeyData[645];
                    for (int i = 0; i < 645; i++)
                        __value[i] = global::DearImguiSharp.ImGuiKeyData.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImGuiKeyData.__Internal*)&(((__Internal*)__Instance)->KeysData[i * sizeof(global::DearImguiSharp.ImGuiKeyData.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 645)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 645; i++)
                        *(global::DearImguiSharp.ImGuiKeyData.__Internal*) &((__Internal*)__Instance)->KeysData[i * sizeof(global::DearImguiSharp.ImGuiKeyData.__Internal)] = *(global::DearImguiSharp.ImGuiKeyData.__Internal*)value[i].__Instance;
                }
            }
        }

        public bool WantCaptureMouseUnlessPopupClose
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouseUnlessPopupClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouseUnlessPopupClose = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 MousePosPrev
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePosPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePosPrev = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2[] MouseClickedPos
        {
            get
            {
                global::DearImguiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseClickedPos != null)
                {
                    __value = new global::DearImguiSharp.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::DearImguiSharp.ImVec2.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::DearImguiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseClickedPos[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)] = *(global::DearImguiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public double[] MouseClickedTime
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<double>(((__Internal*)__Instance)->MouseClickedTime, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedTime[i] = value[i];
                }
            }
        }

        public bool[] MouseClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDoubleClicked
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDoubleClicked, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDoubleClicked[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public ushort[] MouseClickedCount
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->MouseClickedCount, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedCount[i] = value[i];
                }
            }
        }

        public ushort[] MouseClickedLastCount
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->MouseClickedLastCount, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseClickedLastCount[i] = value[i];
                }
            }
        }

        public bool[] MouseReleased
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseReleased, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseReleased[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwned
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwned, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwned[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public bool[] MouseDownOwnedUnlessPopupClose
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<bool>(((__Internal*)__Instance)->MouseDownOwnedUnlessPopupClose, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownOwnedUnlessPopupClose[i] = (byte)(value[i] ? 1 : 0);
                }
            }
        }

        public float[] MouseDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDuration, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDuration[i] = value[i];
                }
            }
        }

        public float[] MouseDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDownDurationPrev, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDownDurationPrev[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImVec2[] MouseDragMaxDistanceAbs
        {
            get
            {
                global::DearImguiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->MouseDragMaxDistanceAbs != null)
                {
                    __value = new global::DearImguiSharp.ImVec2[5];
                    for (int i = 0; i < 5; i++)
                        __value[i] = global::DearImguiSharp.ImVec2.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 5)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 5; i++)
                        *(global::DearImguiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->MouseDragMaxDistanceAbs[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)] = *(global::DearImguiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float[] MouseDragMaxDistanceSqr
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->MouseDragMaxDistanceSqr, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->MouseDragMaxDistanceSqr[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDuration
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDuration, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputsDownDuration[i] = value[i];
                }
            }
        }

        public float[] NavInputsDownDurationPrev
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->NavInputsDownDurationPrev, 20);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 20; i++)
                        ((__Internal*)__Instance)->NavInputsDownDurationPrev[i] = value[i];
                }
            }
        }

        public float PenPressure
        {
            get
            {
                return ((__Internal*)__Instance)->PenPressure;
            }

            set
            {
                ((__Internal*)__Instance)->PenPressure = value;
            }
        }

        public bool AppFocusLost
        {
            get
            {
                return ((__Internal*)__Instance)->AppFocusLost != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AppFocusLost = (byte) (value ? 1 : 0);
            }
        }

        public bool AppAcceptingEvents
        {
            get
            {
                return ((__Internal*)__Instance)->AppAcceptingEvents != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AppAcceptingEvents = (byte) (value ? 1 : 0);
            }
        }

        public sbyte BackendUsingLegacyKeyArrays
        {
            get
            {
                return ((__Internal*)__Instance)->BackendUsingLegacyKeyArrays;
            }

            set
            {
                ((__Internal*)__Instance)->BackendUsingLegacyKeyArrays = value;
            }
        }

        public bool BackendUsingLegacyNavInputArray
        {
            get
            {
                return ((__Internal*)__Instance)->BackendUsingLegacyNavInputArray != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackendUsingLegacyNavInputArray = (byte) (value ? 1 : 0);
            }
        }

        public ushort InputQueueSurrogate
        {
            get
            {
                return ((__Internal*)__Instance)->InputQueueSurrogate;
            }

            set
            {
                ((__Internal*)__Instance)->InputQueueSurrogate = value;
            }
        }

        public global::DearImguiSharp.ImVectorImWchar InputQueueCharacters
        {
            get
            {
                return global::DearImguiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputQueueCharacters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputQueueCharacters = *(global::DearImguiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiInputTextCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public int EventFlag;
            public int Flags;
            public __IntPtr UserData;
            public ushort EventChar;
            public int EventKey;
            public __IntPtr Buf;
            public int BufTextLen;
            public int BufSize;
            public byte BufDirty;
            public int CursorPos;
            public int SelectionStart;
            public int SelectionEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputTextCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextCallbackData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextCallbackData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputTextCallbackData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextCallbackData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputTextCallbackData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputTextCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputTextCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextCallbackData(global::DearImguiSharp.ImGuiInputTextCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputTextCallbackData.__Internal*) _0.__Instance);
        }

        ~ImGuiInputTextCallbackData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int EventFlag
        {
            get
            {
                return ((__Internal*)__Instance)->EventFlag;
            }

            set
            {
                ((__Internal*)__Instance)->EventFlag = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public ushort EventChar
        {
            get
            {
                return ((__Internal*)__Instance)->EventChar;
            }

            set
            {
                ((__Internal*)__Instance)->EventChar = value;
            }
        }

        public int EventKey
        {
            get
            {
                return ((__Internal*)__Instance)->EventKey;
            }

            set
            {
                ((__Internal*)__Instance)->EventKey = value;
            }
        }

        public sbyte* Buf
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Buf;
            }

            set
            {
                ((__Internal*)__Instance)->Buf = (__IntPtr) value;
            }
        }

        public int BufTextLen
        {
            get
            {
                return ((__Internal*)__Instance)->BufTextLen;
            }

            set
            {
                ((__Internal*)__Instance)->BufTextLen = value;
            }
        }

        public int BufSize
        {
            get
            {
                return ((__Internal*)__Instance)->BufSize;
            }

            set
            {
                ((__Internal*)__Instance)->BufSize = value;
            }
        }

        public bool BufDirty
        {
            get
            {
                return ((__Internal*)__Instance)->BufDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BufDirty = (byte) (value ? 1 : 0);
            }
        }

        public int CursorPos
        {
            get
            {
                return ((__Internal*)__Instance)->CursorPos;
            }

            set
            {
                ((__Internal*)__Instance)->CursorPos = value;
            }
        }

        public int SelectionStart
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionStart;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionStart = value;
            }
        }

        public int SelectionEnd
        {
            get
            {
                return ((__Internal*)__Instance)->SelectionEnd;
            }

            set
            {
                ((__Internal*)__Instance)->SelectionEnd = value;
            }
        }
    }

    public unsafe partial class ImGuiSizeCallbackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public __IntPtr UserData;
            public global::DearImguiSharp.ImVec2.__Internal Pos;
            public global::DearImguiSharp.ImVec2.__Internal CurrentSize;
            public global::DearImguiSharp.ImVec2.__Internal DesiredSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiSizeCallbackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiSizeCallbackData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiSizeCallbackData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiSizeCallbackData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiSizeCallbackData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiSizeCallbackData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiSizeCallbackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSizeCallbackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiSizeCallbackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiSizeCallbackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSizeCallbackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSizeCallbackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSizeCallbackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSizeCallbackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSizeCallbackData(global::DearImguiSharp.ImGuiSizeCallbackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSizeCallbackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiSizeCallbackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiSizeCallbackData.__Internal*) _0.__Instance);
        }

        ~ImGuiSizeCallbackData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CurrentSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DesiredSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DesiredSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DesiredSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindowClass : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public uint ClassId;
            public uint ParentViewportId;
            public int ViewportFlagsOverrideSet;
            public int ViewportFlagsOverrideClear;
            public int TabItemFlagsOverrideSet;
            public int DockNodeFlagsOverrideSet;
            public byte DockingAlwaysTabBar;
            public byte DockingAllowUnclassed;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowClass@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowClass>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowClass>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindowClass managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindowClass>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindowClass managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowClass __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowClass(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowClass __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowClass)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowClass __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowClass(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowClass(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowClass(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowClass()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowClass.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowClass(global::DearImguiSharp.ImGuiWindowClass _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowClass.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindowClass.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindowClass.__Internal*) _0.__Instance);
        }

        ~ImGuiWindowClass()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ClassId
        {
            get
            {
                return ((__Internal*)__Instance)->ClassId;
            }

            set
            {
                ((__Internal*)__Instance)->ClassId = value;
            }
        }

        public uint ParentViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ParentViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ParentViewportId = value;
            }
        }

        public int ViewportFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportFlagsOverrideSet = value;
            }
        }

        public int ViewportFlagsOverrideClear
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportFlagsOverrideClear;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportFlagsOverrideClear = value;
            }
        }

        public int TabItemFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->TabItemFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->TabItemFlagsOverrideSet = value;
            }
        }

        public int DockNodeFlagsOverrideSet
        {
            get
            {
                return ((__Internal*)__Instance)->DockNodeFlagsOverrideSet;
            }

            set
            {
                ((__Internal*)__Instance)->DockNodeFlagsOverrideSet = value;
            }
        }

        public bool DockingAlwaysTabBar
        {
            get
            {
                return ((__Internal*)__Instance)->DockingAlwaysTabBar != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockingAlwaysTabBar = (byte) (value ? 1 : 0);
            }
        }

        public bool DockingAllowUnclassed
        {
            get
            {
                return ((__Internal*)__Instance)->DockingAllowUnclassed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockingAllowUnclassed = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiPayload : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 64)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public int DataSize;
            public uint SourceId;
            public uint SourceParentId;
            public int DataFrameCount;
            public fixed sbyte DataType[33];
            public byte Preview;
            public byte Delivery;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPayload@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPayload>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPayload>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPayload managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPayload>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPayload managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPayload __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPayload(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPayload __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPayload)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPayload __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPayload(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPayload(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPayload(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPayload()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPayload(global::DearImguiSharp.ImGuiPayload _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPayload.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPayload.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPayload.__Internal*) _0.__Instance);
        }

        ~ImGuiPayload()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Data
        {
            get
            {
                return ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public int DataSize
        {
            get
            {
                return ((__Internal*)__Instance)->DataSize;
            }

            set
            {
                ((__Internal*)__Instance)->DataSize = value;
            }
        }

        public uint SourceId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceId = value;
            }
        }

        public uint SourceParentId
        {
            get
            {
                return ((__Internal*)__Instance)->SourceParentId;
            }

            set
            {
                ((__Internal*)__Instance)->SourceParentId = value;
            }
        }

        public int DataFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DataFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DataFrameCount = value;
            }
        }

        public sbyte[] DataType
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->DataType, 33);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 33; i++)
                        ((__Internal*)__Instance)->DataType[i] = value[i];
                }
            }
        }

        public bool Preview
        {
            get
            {
                return ((__Internal*)__Instance)->Preview != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Preview = (byte) (value ? 1 : 0);
            }
        }

        public bool Delivery
        {
            get
            {
                return ((__Internal*)__Instance)->Delivery != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Delivery = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public uint ColumnUserID;
            public short ColumnIndex;
            public short SortOrder;
            public int SortDirection;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSortSpecs>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSortSpecs>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableColumnSortSpecs managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSortSpecs>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableColumnSortSpecs managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSortSpecs(global::DearImguiSharp.ImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        ~ImGuiTableColumnSortSpecs()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ColumnUserID
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnUserID;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnUserID = value;
            }
        }

        public short ColumnIndex
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnIndex;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnIndex = value;
            }
        }

        public short SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public int SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Specs;
            public int SpecsCount;
            public byte SpecsDirty;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableSortSpecs>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableSortSpecs>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableSortSpecs managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableSortSpecs>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableSortSpecs managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSortSpecs(global::DearImguiSharp.ImGuiTableSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableSortSpecs.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableSortSpecs.__Internal*) _0.__Instance);
        }

        ~ImGuiTableSortSpecs()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiTableColumnSortSpecs Specs
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Specs, false);
                return __result0;
            }
        }

        public int SpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsCount = value;
            }
        }

        public bool SpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SpecsDirty = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiOnceUponAFrame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public int RefFrame;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOnceUponAFrame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOnceUponAFrame>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOnceUponAFrame>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiOnceUponAFrame managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiOnceUponAFrame>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiOnceUponAFrame managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOnceUponAFrame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOnceUponAFrame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOnceUponAFrame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOnceUponAFrame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOnceUponAFrame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOnceUponAFrame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOnceUponAFrame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOnceUponAFrame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOnceUponAFrame(global::DearImguiSharp.ImGuiOnceUponAFrame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiOnceUponAFrame.__Internal*) _0.__Instance);
        }

        ~ImGuiOnceUponAFrame()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int RefFrame
        {
            get
            {
                return ((__Internal*)__Instance)->RefFrame;
            }

            set
            {
                ((__Internal*)__Instance)->RefFrame = value;
            }
        }
    }

    public unsafe partial class ImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr b;
            public __IntPtr e;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextRange>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextRange>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTextRange managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTextRange>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTextRange managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool __b_OwnsNativeMemory = false;
        private bool __e_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextRange(global::DearImguiSharp.ImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTextRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextRange.__Internal*) _0.__Instance);
            if (_0.__b_OwnsNativeMemory)
                this.B = _0.B;
            if (_0.__e_OwnsNativeMemory)
                this.E = _0.E;
        }

        ~ImGuiTextRange()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__b_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->b);
            if (__e_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->e);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string B
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->b);
            }

            set
            {
                if (__b_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->b);
                __b_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->b = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->b = (__IntPtr) __bytePtr0;
            }
        }

        public string E
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->e);
            }

            set
            {
                if (__e_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->e);
                __e_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->e = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->e = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTextRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTextRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTextRange>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTextRange>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTextRange managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTextRange>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTextRange managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTextRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTextRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTextRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTextRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTextRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTextRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTextRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTextRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTextRange(global::DearImguiSharp.ImVectorImGuiTextRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTextRange()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTextRange Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTextFilter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 280)]
        public partial struct __Internal
        {
            public fixed sbyte InputBuf[256];
            public global::DearImguiSharp.ImVectorImGuiTextRange.__Internal Filters;
            public int CountGrep;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextFilter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextFilter>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextFilter>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTextFilter managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTextFilter>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTextFilter managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTextFilter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextFilter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextFilter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextFilter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextFilter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextFilter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextFilter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextFilter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextFilter(global::DearImguiSharp.ImGuiTextFilter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextFilter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTextFilter.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextFilter.__Internal*) _0.__Instance);
        }

        ~ImGuiTextFilter()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte[] InputBuf
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->InputBuf, 256);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 256; i++)
                        ((__Internal*)__Instance)->InputBuf[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImVectorImGuiTextRange Filters
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTextRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Filters));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Filters = *(global::DearImguiSharp.ImVectorImGuiTextRange.__Internal*) value.__Instance;
            }
        }

        public int CountGrep
        {
            get
            {
                return ((__Internal*)__Instance)->CountGrep;
            }

            set
            {
                ((__Internal*)__Instance)->CountGrep = value;
            }
        }
    }

    public unsafe partial class ImVector_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_char>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_char>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVector_char managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVector_char>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVector_char managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_char(native.ToPointer(), skipVTables);
        }

        internal static ImVector_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_char(global::DearImguiSharp.ImVector_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVector_char.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_char.__Internal*) _0.__Instance);
        }

        ~ImVector_char()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiTextBuffer : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTextBuffer@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_appendf", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Appendf(__IntPtr __instance, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextBuffer>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTextBuffer>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTextBuffer managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTextBuffer>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTextBuffer managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTextBuffer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTextBuffer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTextBuffer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTextBuffer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTextBuffer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTextBuffer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextBuffer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTextBuffer()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTextBuffer(global::DearImguiSharp.ImGuiTextBuffer _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTextBuffer.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTextBuffer.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTextBuffer.__Internal*) _0.__Instance);
        }

        ~ImGuiTextBuffer()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public void Appendf(string fmt)
        {
            __Internal.Appendf(__Instance, fmt);
        }

        public global::DearImguiSharp.ImVector_char Buf
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 16)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint key;

            [FieldOffset(8)]
            public int val_i;

            [FieldOffset(8)]
            public float val_f;

            [FieldOffset(8)]
            public __IntPtr val_p;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStoragePair>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStoragePair>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStoragePair managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStoragePair>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStoragePair managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStoragePair(global::DearImguiSharp.ImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStoragePair.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStoragePair.__Internal*) _0.__Instance);
        }

        ~ImGuiStoragePair()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Key
        {
            get
            {
                return ((__Internal*)__Instance)->key;
            }

            set
            {
                ((__Internal*)__Instance)->key = value;
            }
        }

        public int ValI
        {
            get
            {
                return ((__Internal*)__Instance)->val_i;
            }

            set
            {
                ((__Internal*)__Instance)->val_i = value;
            }
        }

        public float ValF
        {
            get
            {
                return ((__Internal*)__Instance)->val_f;
            }

            set
            {
                ((__Internal*)__Instance)->val_f = value;
            }
        }

        public __IntPtr ValP
        {
            get
            {
                return ((__Internal*)__Instance)->val_p;
            }

            set
            {
                ((__Internal*)__Instance)->val_p = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStoragePair : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStoragePair@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStoragePair>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStoragePair>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiStoragePair managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStoragePair>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiStoragePair managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStoragePair __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStoragePair __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStoragePair)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStoragePair __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStoragePair(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStoragePair(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStoragePair(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStoragePair()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStoragePair(global::DearImguiSharp.ImVectorImGuiStoragePair _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiStoragePair()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiStoragePair Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStorage>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStorage>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStorage managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStorage>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStorage managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStorage(global::DearImguiSharp.ImGuiStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStorage.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStorage.__Internal*) _0.__Instance);
        }

        ~ImGuiStorage()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImGuiStoragePair Data
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiStoragePair.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Data));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Data = *(global::DearImguiSharp.ImVectorImGuiStoragePair.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiListClipper : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public int DisplayStart;
            public int DisplayEnd;
            public int ItemsCount;
            public float ItemsHeight;
            public float StartPosY;
            public __IntPtr TempData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipper@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipper>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipper>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiListClipper managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiListClipper>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiListClipper managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipper __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipper __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipper)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipper __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipper(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipper(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipper(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipper()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipper(global::DearImguiSharp.ImGuiListClipper _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipper.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiListClipper.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiListClipper.__Internal*) _0.__Instance);
        }

        ~ImGuiListClipper()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int DisplayStart
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayStart;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayStart = value;
            }
        }

        public int DisplayEnd
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayEnd = value;
            }
        }

        public int ItemsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsCount = value;
            }
        }

        public float ItemsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsHeight = value;
            }
        }

        public float StartPosY
        {
            get
            {
                return ((__Internal*)__Instance)->StartPosY;
            }

            set
            {
                ((__Internal*)__Instance)->StartPosY = value;
            }
        }

        public __IntPtr TempData
        {
            get
            {
                return ((__Internal*)__Instance)->TempData;
            }

            set
            {
                ((__Internal*)__Instance)->TempData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImColor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal Value;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImColor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImColor>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImColor>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImColor managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImColor>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImColor managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImColor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImColor(native.ToPointer(), skipVTables);
        }

        internal static ImColor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImColor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImColor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImColor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImColor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImColor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImColor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImColor(global::DearImguiSharp.ImColor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImColor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImColor.__Internal*) __Instance) = *((global::DearImguiSharp.ImColor.__Internal*) _0.__Instance);
        }

        ~ImColor()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 Value
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Value));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Value = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;
            public uint IdxOffset;
            public uint ElemCount;
            public __IntPtr UserCallback;
            public __IntPtr UserCallbackData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawCmd>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawCmd>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawCmd managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawCmd>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawCmd managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmd(global::DearImguiSharp.ImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawCmd.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawCmd.__Internal*) _0.__Instance);
        }

        ~ImDrawCmd()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }

        public uint IdxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->IdxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->IdxOffset = value;
            }
        }

        public uint ElemCount
        {
            get
            {
                return ((__Internal*)__Instance)->ElemCount;
            }

            set
            {
                ((__Internal*)__Instance)->ElemCount = value;
            }
        }

        public global::DearImguiSharp.ImDrawCallback UserCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->UserCallback;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.ImDrawCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.ImDrawCallback));
            }

            set
            {
                ((__Internal*)__Instance)->UserCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserCallbackData
        {
            get
            {
                return ((__Internal*)__Instance)->UserCallbackData;
            }

            set
            {
                ((__Internal*)__Instance)->UserCallbackData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal pos;
            public global::DearImguiSharp.ImVec2.__Internal uv;
            public uint col;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawVert>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawVert>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawVert managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawVert>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawVert managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawVert(global::DearImguiSharp.ImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawVert.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawVert.__Internal*) _0.__Instance);
        }

        ~ImDrawVert()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Uv
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->uv));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->uv = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public uint Col
        {
            get
            {
                return ((__Internal*)__Instance)->col;
            }

            set
            {
                ((__Internal*)__Instance)->col = value;
            }
        }
    }

    public unsafe partial class ImDrawCmdHeader : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec4.__Internal ClipRect;
            public __IntPtr TextureId;
            public uint VtxOffset;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawCmdHeader@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawCmdHeader>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawCmdHeader>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawCmdHeader managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawCmdHeader>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawCmdHeader managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawCmdHeader __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native.ToPointer(), skipVTables);
        }

        internal static ImDrawCmdHeader __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawCmdHeader)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawCmdHeader __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawCmdHeader(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawCmdHeader(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmdHeader(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawCmdHeader()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawCmdHeader(global::DearImguiSharp.ImDrawCmdHeader _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawCmdHeader.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawCmdHeader.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawCmdHeader.__Internal*) _0.__Instance);
        }

        ~ImDrawCmdHeader()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec4 ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public __IntPtr TextureId
        {
            get
            {
                return ((__Internal*)__Instance)->TextureId;
            }

            set
            {
                ((__Internal*)__Instance)->TextureId = (__IntPtr) value;
            }
        }

        public uint VtxOffset
        {
            get
            {
                return ((__Internal*)__Instance)->VtxOffset;
            }

            set
            {
                ((__Internal*)__Instance)->VtxOffset = value;
            }
        }
    }

    public unsafe partial class ImVectorImDrawCmd : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawCmd@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawCmd>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawCmd>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImDrawCmd managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawCmd>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImDrawCmd managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawCmd __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawCmd __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawCmd)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawCmd __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawCmd(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawCmd(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawCmd(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawCmd()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawCmd(global::DearImguiSharp.ImVectorImDrawCmd _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawCmd.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) _0.__Instance);
        }

        ~ImVectorImDrawCmd()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawCmd Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawCmd.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawIdx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawIdx>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawIdx>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImDrawIdx managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawIdx>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImDrawIdx managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawIdx(global::DearImguiSharp.ImVectorImDrawIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) _0.__Instance);
        }

        ~ImVectorImDrawIdx()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public ushort* Data
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImDrawCmd.__Internal _CmdBuffer;
            public global::DearImguiSharp.ImVectorImDrawIdx.__Internal _IdxBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawChannel>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawChannel>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawChannel managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawChannel>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawChannel managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawChannel(global::DearImguiSharp.ImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawChannel.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawChannel.__Internal*) _0.__Instance);
        }

        ~ImDrawChannel()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdBuffer = *(global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_IdxBuffer = *(global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawChannel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawChannel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawChannel>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawChannel>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImDrawChannel managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawChannel>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImDrawChannel managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawChannel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawChannel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawChannel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawChannel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawChannel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawChannel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawChannel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawChannel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawChannel(global::DearImguiSharp.ImVectorImDrawChannel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawChannel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) _0.__Instance);
        }

        ~ImVectorImDrawChannel()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawChannel Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawChannel.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSplitter : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public int _Current;
            public int _Count;
            public global::DearImguiSharp.ImVectorImDrawChannel.__Internal _Channels;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawListSplitter@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawListSplitter>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawListSplitter>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawListSplitter managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawListSplitter>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawListSplitter managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawListSplitter __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSplitter __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawListSplitter)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawListSplitter __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSplitter(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSplitter(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSplitter(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSplitter()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSplitter(global::DearImguiSharp.ImDrawListSplitter _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSplitter.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawListSplitter.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawListSplitter.__Internal*) _0.__Instance);
        }

        ~ImDrawListSplitter()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->_Current;
            }

            set
            {
                ((__Internal*)__Instance)->_Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->_Count;
            }

            set
            {
                ((__Internal*)__Instance)->_Count = value;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawChannel Channels
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawChannel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Channels));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Channels = *(global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImDrawVert : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawVert@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawVert>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawVert>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImDrawVert managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawVert>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImDrawVert managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawVert __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawVert __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawVert)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawVert __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawVert(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawVert(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawVert(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawVert()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawVert(global::DearImguiSharp.ImVectorImDrawVert _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawVert.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImDrawVert.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawVert.__Internal*) _0.__Instance);
        }

        ~ImVectorImDrawVert()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawVert Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImVec4 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImVec4@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImVec4>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImVec4>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImVec4 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImVec4>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImVec4 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec4 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec4 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImVec4)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImVec4 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec4(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec4(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec4(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec4()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec4(global::DearImguiSharp.ImVectorImVec4 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec4.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImVec4.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImVec4.__Internal*) _0.__Instance);
        }

        ~ImVectorImVec4()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImVec4 Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImTextureID : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImTextureID@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImTextureID>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImTextureID>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImTextureID managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImTextureID>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImTextureID managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImTextureID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImTextureID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImTextureID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImTextureID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImTextureID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImTextureID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImTextureID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImTextureID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImTextureID(global::DearImguiSharp.ImVectorImTextureID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImTextureID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImTextureID.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImTextureID.__Internal*) _0.__Instance);
        }

        ~ImVectorImTextureID()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }
    }

    public unsafe partial class ImVectorImVec2 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImVec2@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImVec2>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImVec2>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImVec2 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImVec2>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImVec2 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImVec2 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImVec2 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImVec2)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImVec2 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImVec2(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImVec2(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec2(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImVec2()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImVec2(global::DearImguiSharp.ImVectorImVec2 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImVec2.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImVec2.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImVec2.__Internal*) _0.__Instance);
        }

        ~ImVectorImVec2()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 200)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImDrawCmd.__Internal CmdBuffer;
            public global::DearImguiSharp.ImVectorImDrawIdx.__Internal IdxBuffer;
            public global::DearImguiSharp.ImVectorImDrawVert.__Internal VtxBuffer;
            public int Flags;
            public uint _VtxCurrentIdx;
            public __IntPtr _Data;
            public __IntPtr _OwnerName;
            public __IntPtr _VtxWritePtr;
            public __IntPtr _IdxWritePtr;
            public global::DearImguiSharp.ImVectorImVec4.__Internal _ClipRectStack;
            public global::DearImguiSharp.ImVectorImTextureID.__Internal _TextureIdStack;
            public global::DearImguiSharp.ImVectorImVec2.__Internal _Path;
            public global::DearImguiSharp.ImDrawCmdHeader.__Internal _CmdHeader;
            public global::DearImguiSharp.ImDrawListSplitter.__Internal _Splitter;
            public float _FringeScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawList@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawList>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawList>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawList managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawList>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawList managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool ___OwnerName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImDrawList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawList(native.ToPointer(), skipVTables);
        }

        internal static ImDrawList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawList(global::DearImguiSharp.ImDrawList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawList.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawList.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawList.__Internal*) _0.__Instance);
            if (_0.___OwnerName_OwnsNativeMemory)
                this.OwnerName = _0.OwnerName;
        }

        ~ImDrawList()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (___OwnerName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->_OwnerName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImDrawCmd CmdBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawCmd.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CmdBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CmdBuffer = *(global::DearImguiSharp.ImVectorImDrawCmd.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawIdx IdxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IdxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IdxBuffer = *(global::DearImguiSharp.ImVectorImDrawIdx.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawVert VtxBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawVert.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->VtxBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->VtxBuffer = *(global::DearImguiSharp.ImVectorImDrawVert.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint VtxCurrentIdx
        {
            get
            {
                return ((__Internal*)__Instance)->_VtxCurrentIdx;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxCurrentIdx = value;
            }
        }

        public global::DearImguiSharp.ImDrawListSharedData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawListSharedData.__GetOrCreateInstance(((__Internal*)__Instance)->_Data, false);
                return __result0;
            }
        }

        public string OwnerName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->_OwnerName);
            }

            set
            {
                if (___OwnerName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->_OwnerName);
                ___OwnerName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->_OwnerName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->_OwnerName = (__IntPtr) __bytePtr0;
            }
        }

        public global::DearImguiSharp.ImDrawVert VtxWritePtr
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawVert.__GetOrCreateInstance(((__Internal*)__Instance)->_VtxWritePtr, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->_VtxWritePtr = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public ushort* IdxWritePtr
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->_IdxWritePtr;
            }

            set
            {
                ((__Internal*)__Instance)->_IdxWritePtr = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVectorImVec4 ClipRectStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_ClipRectStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_ClipRectStack = *(global::DearImguiSharp.ImVectorImVec4.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImTextureID TextureIdStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImTextureID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_TextureIdStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_TextureIdStack = *(global::DearImguiSharp.ImVectorImTextureID.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImVec2 Path
        {
            get
            {
                return global::DearImguiSharp.ImVectorImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Path));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Path = *(global::DearImguiSharp.ImVectorImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawCmdHeader CmdHeader
        {
            get
            {
                return global::DearImguiSharp.ImDrawCmdHeader.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_CmdHeader));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_CmdHeader = *(global::DearImguiSharp.ImDrawCmdHeader.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawListSplitter Splitter
        {
            get
            {
                return global::DearImguiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_Splitter = *(global::DearImguiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public float FringeScale
        {
            get
            {
                return ((__Internal*)__Instance)->_FringeScale;
            }

            set
            {
                ((__Internal*)__Instance)->_FringeScale = value;
            }
        }
    }

    public unsafe partial class ImDrawData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public byte Valid;
            public int CmdListsCount;
            public int TotalIdxCount;
            public int TotalVtxCount;
            public __IntPtr CmdLists;
            public global::DearImguiSharp.ImVec2.__Internal DisplayPos;
            public global::DearImguiSharp.ImVec2.__Internal DisplaySize;
            public global::DearImguiSharp.ImVec2.__Internal FramebufferScale;
            public __IntPtr OwnerViewport;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawData(global::DearImguiSharp.ImDrawData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawData.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawData.__Internal*) _0.__Instance);
        }

        ~ImDrawData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Valid
        {
            get
            {
                return ((__Internal*)__Instance)->Valid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Valid = (byte) (value ? 1 : 0);
            }
        }

        public int CmdListsCount
        {
            get
            {
                return ((__Internal*)__Instance)->CmdListsCount;
            }

            set
            {
                ((__Internal*)__Instance)->CmdListsCount = value;
            }
        }

        public int TotalIdxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalIdxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalIdxCount = value;
            }
        }

        public int TotalVtxCount
        {
            get
            {
                return ((__Internal*)__Instance)->TotalVtxCount;
            }

            set
            {
                ((__Internal*)__Instance)->TotalVtxCount = value;
            }
        }

        public global::DearImguiSharp.ImDrawList CmdLists
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->CmdLists, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->CmdLists = new __IntPtr(&__value);
            }
        }

        public global::DearImguiSharp.ImVec2 DisplayPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 DisplaySize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplaySize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplaySize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 FramebufferScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramebufferScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramebufferScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiViewport OwnerViewport
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(((__Internal*)__Instance)->OwnerViewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->OwnerViewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            public __IntPtr FontData;
            public int FontDataSize;
            public byte FontDataOwnedByAtlas;
            public int FontNo;
            public float SizePixels;
            public int OversampleH;
            public int OversampleV;
            public byte PixelSnapH;
            public global::DearImguiSharp.ImVec2.__Internal GlyphExtraSpacing;
            public global::DearImguiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr GlyphRanges;
            public float GlyphMinAdvanceX;
            public float GlyphMaxAdvanceX;
            public byte MergeMode;
            public uint FontBuilderFlags;
            public float RasterizerMultiply;
            public ushort EllipsisChar;
            public fixed sbyte Name[40];
            public __IntPtr DstFont;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontConfig>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontConfig>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontConfig managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontConfig>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontConfig managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontConfig(global::DearImguiSharp.ImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontConfig.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontConfig.__Internal*) _0.__Instance);
        }

        ~ImFontConfig()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr FontData
        {
            get
            {
                return ((__Internal*)__Instance)->FontData;
            }

            set
            {
                ((__Internal*)__Instance)->FontData = (__IntPtr) value;
            }
        }

        public int FontDataSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataSize = value;
            }
        }

        public bool FontDataOwnedByAtlas
        {
            get
            {
                return ((__Internal*)__Instance)->FontDataOwnedByAtlas != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontDataOwnedByAtlas = (byte) (value ? 1 : 0);
            }
        }

        public int FontNo
        {
            get
            {
                return ((__Internal*)__Instance)->FontNo;
            }

            set
            {
                ((__Internal*)__Instance)->FontNo = value;
            }
        }

        public float SizePixels
        {
            get
            {
                return ((__Internal*)__Instance)->SizePixels;
            }

            set
            {
                ((__Internal*)__Instance)->SizePixels = value;
            }
        }

        public int OversampleH
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleH;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleH = value;
            }
        }

        public int OversampleV
        {
            get
            {
                return ((__Internal*)__Instance)->OversampleV;
            }

            set
            {
                ((__Internal*)__Instance)->OversampleV = value;
            }
        }

        public bool PixelSnapH
        {
            get
            {
                return ((__Internal*)__Instance)->PixelSnapH != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PixelSnapH = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphExtraSpacing
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphExtraSpacing));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphExtraSpacing = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public ushort* GlyphRanges
        {
            get
            {
                return (ushort*) ((__Internal*)__Instance)->GlyphRanges;
            }
        }

        public float GlyphMinAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMinAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMinAdvanceX = value;
            }
        }

        public float GlyphMaxAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphMaxAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphMaxAdvanceX = value;
            }
        }

        public bool MergeMode
        {
            get
            {
                return ((__Internal*)__Instance)->MergeMode != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MergeMode = (byte) (value ? 1 : 0);
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public float RasterizerMultiply
        {
            get
            {
                return ((__Internal*)__Instance)->RasterizerMultiply;
            }

            set
            {
                ((__Internal*)__Instance)->RasterizerMultiply = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public sbyte[] Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Name, 40);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 40; i++)
                        ((__Internal*)__Instance)->Name[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImFont DstFont
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->DstFont, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DstFont = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 40)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint Colored;

            [FieldOffset(0)]
            public uint Visible;

            [FieldOffset(0)]
            public uint Codepoint;

            [FieldOffset(4)]
            public float AdvanceX;

            [FieldOffset(8)]
            public float X0;

            [FieldOffset(12)]
            public float Y0;

            [FieldOffset(16)]
            public float X1;

            [FieldOffset(20)]
            public float Y1;

            [FieldOffset(24)]
            public float U0;

            [FieldOffset(28)]
            public float V0;

            [FieldOffset(32)]
            public float U1;

            [FieldOffset(36)]
            public float V1;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontGlyph>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontGlyph>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontGlyph managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontGlyph>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontGlyph managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyph(global::DearImguiSharp.ImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontGlyph.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontGlyph.__Internal*) _0.__Instance);
        }

        ~ImFontGlyph()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Colored
        {
            get
            {
                return ((__Internal*)__Instance)->Colored;
            }

            set
            {
                ((__Internal*)__Instance)->Colored = value;
            }
        }

        public uint Visible
        {
            get
            {
                return ((__Internal*)__Instance)->Visible;
            }

            set
            {
                ((__Internal*)__Instance)->Visible = value;
            }
        }

        public uint Codepoint
        {
            get
            {
                return ((__Internal*)__Instance)->Codepoint;
            }

            set
            {
                ((__Internal*)__Instance)->Codepoint = value;
            }
        }

        public float AdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->AdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->AdvanceX = value;
            }
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->X0;
            }

            set
            {
                ((__Internal*)__Instance)->X0 = value;
            }
        }

        public float Y0
        {
            get
            {
                return ((__Internal*)__Instance)->Y0;
            }

            set
            {
                ((__Internal*)__Instance)->Y0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->X1;
            }

            set
            {
                ((__Internal*)__Instance)->X1 = value;
            }
        }

        public float Y1
        {
            get
            {
                return ((__Internal*)__Instance)->Y1;
            }

            set
            {
                ((__Internal*)__Instance)->Y1 = value;
            }
        }

        public float U0
        {
            get
            {
                return ((__Internal*)__Instance)->U0;
            }

            set
            {
                ((__Internal*)__Instance)->U0 = value;
            }
        }

        public float V0
        {
            get
            {
                return ((__Internal*)__Instance)->V0;
            }

            set
            {
                ((__Internal*)__Instance)->V0 = value;
            }
        }

        public float U1
        {
            get
            {
                return ((__Internal*)__Instance)->U1;
            }

            set
            {
                ((__Internal*)__Instance)->U1 = value;
            }
        }

        public float V1
        {
            get
            {
                return ((__Internal*)__Instance)->V1;
            }

            set
            {
                ((__Internal*)__Instance)->V1 = value;
            }
        }
    }

    public unsafe partial class ImVectorImU32 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImU32@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImU32>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImU32>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImU32 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImU32>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImU32 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImU32 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImU32(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImU32 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImU32)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImU32 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImU32(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImU32(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImU32(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImU32()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImU32(global::DearImguiSharp.ImVectorImU32 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImU32.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImU32.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImU32.__Internal*) _0.__Instance);
        }

        ~ImVectorImU32()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImFontGlyphRangesBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImU32.__Internal UsedChars;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontGlyphRangesBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontGlyphRangesBuilder>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontGlyphRangesBuilder>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontGlyphRangesBuilder managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontGlyphRangesBuilder>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontGlyphRangesBuilder managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontGlyphRangesBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImFontGlyphRangesBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontGlyphRangesBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontGlyphRangesBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontGlyphRangesBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontGlyphRangesBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyphRangesBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontGlyphRangesBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontGlyphRangesBuilder(global::DearImguiSharp.ImFontGlyphRangesBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontGlyphRangesBuilder.__Internal*) _0.__Instance);
        }

        ~ImFontGlyphRangesBuilder()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImU32 UsedChars
        {
            get
            {
                return global::DearImguiSharp.ImVectorImU32.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->UsedChars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->UsedChars = *(global::DearImguiSharp.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public ushort Width;
            public ushort Height;
            public ushort X;
            public ushort Y;
            public uint GlyphID;
            public float GlyphAdvanceX;
            public global::DearImguiSharp.ImVec2.__Internal GlyphOffset;
            public __IntPtr Font;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontAtlasCustomRect>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontAtlasCustomRect>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontAtlasCustomRect managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontAtlasCustomRect>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontAtlasCustomRect managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlasCustomRect(global::DearImguiSharp.ImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontAtlasCustomRect.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        ~ImFontAtlasCustomRect()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public ushort Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public ushort Height
        {
            get
            {
                return ((__Internal*)__Instance)->Height;
            }

            set
            {
                ((__Internal*)__Instance)->Height = value;
            }
        }

        public ushort X
        {
            get
            {
                return ((__Internal*)__Instance)->X;
            }

            set
            {
                ((__Internal*)__Instance)->X = value;
            }
        }

        public ushort Y
        {
            get
            {
                return ((__Internal*)__Instance)->Y;
            }

            set
            {
                ((__Internal*)__Instance)->Y = value;
            }
        }

        public uint GlyphID
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphID;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphID = value;
            }
        }

        public float GlyphAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->GlyphAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->GlyphAdvanceX = value;
            }
        }

        public global::DearImguiSharp.ImVec2 GlyphOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GlyphOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GlyphOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImFontPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImFontPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImFontPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontPtr(global::DearImguiSharp.ImVectorImFontPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImFontPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontPtr.__Internal*) _0.__Instance);
        }

        ~ImVectorImFontPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFont Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVectorImFontAtlasCustomRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontAtlasCustomRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontAtlasCustomRect>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontAtlasCustomRect>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImFontAtlasCustomRect managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImFontAtlasCustomRect>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImFontAtlasCustomRect managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontAtlasCustomRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontAtlasCustomRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontAtlasCustomRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontAtlasCustomRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontAtlasCustomRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontAtlasCustomRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontAtlasCustomRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontAtlasCustomRect(global::DearImguiSharp.ImVectorImFontAtlasCustomRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) _0.__Instance);
        }

        ~ImVectorImFontAtlasCustomRect()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontAtlasCustomRect Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImFontConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontConfig>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontConfig>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImFontConfig managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImFontConfig>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImFontConfig managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontConfig(global::DearImguiSharp.ImVectorImFontConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImFontConfig.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontConfig.__Internal*) _0.__Instance);
        }

        ~ImVectorImFontConfig()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontConfig Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFontAtlas : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1168)]
        public partial struct __Internal
        {
            public int Flags;
            public __IntPtr TexID;
            public int TexDesiredWidth;
            public int TexGlyphPadding;
            public byte Locked;
            public byte TexReady;
            public byte TexPixelsUseColors;
            public __IntPtr TexPixelsAlpha8;
            public __IntPtr TexPixelsRGBA32;
            public int TexWidth;
            public int TexHeight;
            public global::DearImguiSharp.ImVec2.__Internal TexUvScale;
            public global::DearImguiSharp.ImVec2.__Internal TexUvWhitePixel;
            public global::DearImguiSharp.ImVectorImFontPtr.__Internal Fonts;
            public global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal CustomRects;
            public global::DearImguiSharp.ImVectorImFontConfig.__Internal ConfigData;
            public fixed byte TexUvLines[1024];
            public __IntPtr FontBuilderIO;
            public uint FontBuilderFlags;
            public int PackIdMouseCursors;
            public int PackIdLines;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontAtlas@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontAtlas>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontAtlas>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontAtlas managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontAtlas>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontAtlas managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontAtlas __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontAtlas(native.ToPointer(), skipVTables);
        }

        internal static ImFontAtlas __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontAtlas)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontAtlas __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontAtlas(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontAtlas(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlas(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontAtlas()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontAtlas(global::DearImguiSharp.ImFontAtlas _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontAtlas.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontAtlas.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontAtlas.__Internal*) _0.__Instance);
        }

        ~ImFontAtlas()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr TexID
        {
            get
            {
                return ((__Internal*)__Instance)->TexID;
            }

            set
            {
                ((__Internal*)__Instance)->TexID = (__IntPtr) value;
            }
        }

        public int TexDesiredWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexDesiredWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexDesiredWidth = value;
            }
        }

        public int TexGlyphPadding
        {
            get
            {
                return ((__Internal*)__Instance)->TexGlyphPadding;
            }

            set
            {
                ((__Internal*)__Instance)->TexGlyphPadding = value;
            }
        }

        public bool Locked
        {
            get
            {
                return ((__Internal*)__Instance)->Locked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Locked = (byte) (value ? 1 : 0);
            }
        }

        public bool TexReady
        {
            get
            {
                return ((__Internal*)__Instance)->TexReady != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TexReady = (byte) (value ? 1 : 0);
            }
        }

        public bool TexPixelsUseColors
        {
            get
            {
                return ((__Internal*)__Instance)->TexPixelsUseColors != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsUseColors = (byte) (value ? 1 : 0);
            }
        }

        public byte* TexPixelsAlpha8
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->TexPixelsAlpha8;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsAlpha8 = (__IntPtr) value;
            }
        }

        public uint* TexPixelsRGBA32
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->TexPixelsRGBA32;
            }

            set
            {
                ((__Internal*)__Instance)->TexPixelsRGBA32 = (__IntPtr) value;
            }
        }

        public int TexWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TexWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TexWidth = value;
            }
        }

        public int TexHeight
        {
            get
            {
                return ((__Internal*)__Instance)->TexHeight;
            }

            set
            {
                ((__Internal*)__Instance)->TexHeight = value;
            }
        }

        public global::DearImguiSharp.ImVec2 TexUvScale
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvScale));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvScale = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontPtr Fonts
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Fonts));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Fonts = *(global::DearImguiSharp.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontAtlasCustomRect CustomRects
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CustomRects));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CustomRects = *(global::DearImguiSharp.ImVectorImFontAtlasCustomRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontConfig ConfigData
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ConfigData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ConfigData = *(global::DearImguiSharp.ImVectorImFontConfig.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec4[] TexUvLines
        {
            get
            {
                global::DearImguiSharp.ImVec4[] __value = null;
                if (((__Internal*)__Instance)->TexUvLines != null)
                {
                    __value = new global::DearImguiSharp.ImVec4[64];
                    for (int i = 0; i < 64; i++)
                        __value[i] = global::DearImguiSharp.ImVec4.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVec4.__Internal*)&(((__Internal*)__Instance)->TexUvLines[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 64)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 64; i++)
                        *(global::DearImguiSharp.ImVec4.__Internal*) &((__Internal*)__Instance)->TexUvLines[i * sizeof(global::DearImguiSharp.ImVec4.__Internal)] = *(global::DearImguiSharp.ImVec4.__Internal*)value[i].__Instance;
                }
            }
        }

        public global::DearImguiSharp.ImFontBuilderIO FontBuilderIO
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontBuilderIO.__GetOrCreateInstance(((__Internal*)__Instance)->FontBuilderIO, false);
                return __result0;
            }
        }

        public uint FontBuilderFlags
        {
            get
            {
                return ((__Internal*)__Instance)->FontBuilderFlags;
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilderFlags = value;
            }
        }

        public int PackIdMouseCursors
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdMouseCursors;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdMouseCursors = value;
            }
        }

        public int PackIdLines
        {
            get
            {
                return ((__Internal*)__Instance)->PackIdLines;
            }

            set
            {
                ((__Internal*)__Instance)->PackIdLines = value;
            }
        }
    }

    public unsafe partial class ImVector_float : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_float@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_float>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_float>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVector_float managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVector_float>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVector_float managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_float __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_float(native.ToPointer(), skipVTables);
        }

        internal static ImVector_float __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_float)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_float __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_float(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_float(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_float(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_float()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_float(global::DearImguiSharp.ImVector_float _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_float.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVector_float.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_float.__Internal*) _0.__Instance);
        }

        ~ImVector_float()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public float* Data
        {
            get
            {
                return (float*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImFontGlyph : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImFontGlyph@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontGlyph>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImFontGlyph>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImFontGlyph managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImFontGlyph>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImFontGlyph managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImFontGlyph __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImFontGlyph __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImFontGlyph)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImFontGlyph __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImFontGlyph(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImFontGlyph(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontGlyph(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImFontGlyph()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImFontGlyph(global::DearImguiSharp.ImVectorImFontGlyph _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImFontGlyph.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) _0.__Instance);
        }

        ~ImVectorImFontGlyph()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImFontGlyph Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImFont : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_float.__Internal IndexAdvanceX;
            public float FallbackAdvanceX;
            public float FontSize;
            public global::DearImguiSharp.ImVectorImWchar.__Internal IndexLookup;
            public global::DearImguiSharp.ImVectorImFontGlyph.__Internal Glyphs;
            public __IntPtr FallbackGlyph;
            public __IntPtr ContainerAtlas;
            public __IntPtr ConfigData;
            public short ConfigDataCount;
            public ushort FallbackChar;
            public ushort EllipsisChar;
            public ushort DotChar;
            public byte DirtyLookupTables;
            public float Scale;
            public float Ascent;
            public float Descent;
            public int MetricsTotalSurface;
            public fixed byte Used4kPagesMap[2];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFont@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFont>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFont>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFont managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFont>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFont managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFont __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFont(native.ToPointer(), skipVTables);
        }

        internal static ImFont __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFont)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFont __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFont(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFont(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFont(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFont()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFont(global::DearImguiSharp.ImFont _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFont.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFont.__Internal*) __Instance) = *((global::DearImguiSharp.ImFont.__Internal*) _0.__Instance);
        }

        ~ImFont()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVector_float IndexAdvanceX
        {
            get
            {
                return global::DearImguiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexAdvanceX));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexAdvanceX = *(global::DearImguiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public float FallbackAdvanceX
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackAdvanceX;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackAdvanceX = value;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public global::DearImguiSharp.ImVectorImWchar IndexLookup
        {
            get
            {
                return global::DearImguiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IndexLookup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IndexLookup = *(global::DearImguiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontGlyph Glyphs
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontGlyph.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Glyphs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Glyphs = *(global::DearImguiSharp.ImVectorImFontGlyph.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFontGlyph FallbackGlyph
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(((__Internal*)__Instance)->FallbackGlyph, false);
                return __result0;
            }
        }

        public global::DearImguiSharp.ImFontAtlas ContainerAtlas
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(((__Internal*)__Instance)->ContainerAtlas, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ContainerAtlas = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFontConfig ConfigData
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(((__Internal*)__Instance)->ConfigData, false);
                return __result0;
            }
        }

        public short ConfigDataCount
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigDataCount;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigDataCount = value;
            }
        }

        public ushort FallbackChar
        {
            get
            {
                return ((__Internal*)__Instance)->FallbackChar;
            }

            set
            {
                ((__Internal*)__Instance)->FallbackChar = value;
            }
        }

        public ushort EllipsisChar
        {
            get
            {
                return ((__Internal*)__Instance)->EllipsisChar;
            }

            set
            {
                ((__Internal*)__Instance)->EllipsisChar = value;
            }
        }

        public ushort DotChar
        {
            get
            {
                return ((__Internal*)__Instance)->DotChar;
            }

            set
            {
                ((__Internal*)__Instance)->DotChar = value;
            }
        }

        public bool DirtyLookupTables
        {
            get
            {
                return ((__Internal*)__Instance)->DirtyLookupTables != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DirtyLookupTables = (byte) (value ? 1 : 0);
            }
        }

        public float Scale
        {
            get
            {
                return ((__Internal*)__Instance)->Scale;
            }

            set
            {
                ((__Internal*)__Instance)->Scale = value;
            }
        }

        public float Ascent
        {
            get
            {
                return ((__Internal*)__Instance)->Ascent;
            }

            set
            {
                ((__Internal*)__Instance)->Ascent = value;
            }
        }

        public float Descent
        {
            get
            {
                return ((__Internal*)__Instance)->Descent;
            }

            set
            {
                ((__Internal*)__Instance)->Descent = value;
            }
        }

        public int MetricsTotalSurface
        {
            get
            {
                return ((__Internal*)__Instance)->MetricsTotalSurface;
            }

            set
            {
                ((__Internal*)__Instance)->MetricsTotalSurface = value;
            }
        }

        public byte[] Used4kPagesMap
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Used4kPagesMap, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->Used4kPagesMap[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiViewport : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 96)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public global::DearImguiSharp.ImVec2.__Internal Pos;
            public global::DearImguiSharp.ImVec2.__Internal Size;
            public global::DearImguiSharp.ImVec2.__Internal WorkPos;
            public global::DearImguiSharp.ImVec2.__Internal WorkSize;
            public float DpiScale;
            public uint ParentViewportId;
            public __IntPtr DrawData;
            public __IntPtr RendererUserData;
            public __IntPtr PlatformUserData;
            public __IntPtr PlatformHandle;
            public __IntPtr PlatformHandleRaw;
            public byte PlatformRequestMove;
            public byte PlatformRequestResize;
            public byte PlatformRequestClose;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiViewport@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiViewport>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiViewport>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiViewport managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiViewport>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiViewport managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiViewport __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewport(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewport __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiViewport)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiViewport __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewport(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewport(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewport(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewport()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewport(global::DearImguiSharp.ImGuiViewport _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiViewport.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiViewport.__Internal*) _0.__Instance);
        }

        ~ImGuiViewport()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Size
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->DpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->DpiScale = value;
            }
        }

        public uint ParentViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ParentViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ParentViewportId = value;
            }
        }

        public global::DearImguiSharp.ImDrawData DrawData
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawData.__GetOrCreateInstance(((__Internal*)__Instance)->DrawData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public __IntPtr RendererUserData
        {
            get
            {
                return ((__Internal*)__Instance)->RendererUserData;
            }

            set
            {
                ((__Internal*)__Instance)->RendererUserData = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformUserData
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformUserData;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformUserData = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformHandle
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformHandle;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformHandle = (__IntPtr) value;
            }
        }

        public __IntPtr PlatformHandleRaw
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformHandleRaw;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformHandleRaw = (__IntPtr) value;
            }
        }

        public bool PlatformRequestMove
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestMove != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestMove = (byte) (value ? 1 : 0);
            }
        }

        public bool PlatformRequestResize
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestResize != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestResize = (byte) (value ? 1 : 0);
            }
        }

        public bool PlatformRequestClose
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformRequestClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformRequestClose = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImVectorImGuiPlatformMonitor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiPlatformMonitor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPlatformMonitor>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPlatformMonitor>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiPlatformMonitor managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPlatformMonitor>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiPlatformMonitor managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiPlatformMonitor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiPlatformMonitor(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiPlatformMonitor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiPlatformMonitor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiPlatformMonitor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiPlatformMonitor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPlatformMonitor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPlatformMonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiPlatformMonitor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPlatformMonitor(global::DearImguiSharp.ImVectorImGuiPlatformMonitor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiPlatformMonitor()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiPlatformMonitor Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiPlatformMonitor.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiViewportPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiViewportPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiViewportPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiViewportPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiViewportPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiViewportPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiViewportPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiViewportPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiViewportPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiViewportPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPtr(global::DearImguiSharp.ImVectorImGuiViewportPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiViewportPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiViewport Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImGuiPlatformIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 216)]
        public partial struct __Internal
        {
            public __IntPtr Platform_CreateWindow;
            public __IntPtr Platform_DestroyWindow;
            public __IntPtr Platform_ShowWindow;
            public __IntPtr Platform_SetWindowPos;
            public __IntPtr Platform_GetWindowPos;
            public __IntPtr Platform_SetWindowSize;
            public __IntPtr Platform_GetWindowSize;
            public __IntPtr Platform_SetWindowFocus;
            public __IntPtr Platform_GetWindowFocus;
            public __IntPtr Platform_GetWindowMinimized;
            public __IntPtr Platform_SetWindowTitle;
            public __IntPtr Platform_SetWindowAlpha;
            public __IntPtr Platform_UpdateWindow;
            public __IntPtr Platform_RenderWindow;
            public __IntPtr Platform_SwapBuffers;
            public __IntPtr Platform_GetWindowDpiScale;
            public __IntPtr Platform_OnChangedViewport;
            public __IntPtr Platform_CreateVkSurface;
            public __IntPtr Renderer_CreateWindow;
            public __IntPtr Renderer_DestroyWindow;
            public __IntPtr Renderer_SetWindowSize;
            public __IntPtr Renderer_RenderWindow;
            public __IntPtr Renderer_SwapBuffers;
            public global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal Monitors;
            public global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal Viewports;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPlatformIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformIO>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformIO>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPlatformIO managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformIO>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPlatformIO managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformIO(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPlatformIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPlatformIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPlatformIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformIO(global::DearImguiSharp.ImGuiPlatformIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPlatformIO.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPlatformIO.__Internal*) _0.__Instance);
        }

        ~ImGuiPlatformIO()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformCreateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_CreateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_CreateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformDestroyWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_DestroyWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_DestroyWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformShowWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_ShowWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_ShowWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal PlatformSetWindowPos
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowPos;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowPos = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr PlatformGetWindowPos
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowPos;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowPos = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal PlatformSetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr PlatformGetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_DearImguiSharp_ImVec2___Internal___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformSetWindowFocus
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowFocus;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_bool___IntPtr PlatformGetWindowFocus
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowFocus;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowFocus = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_bool___IntPtr PlatformGetWindowMinimized
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowMinimized;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowMinimized = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_string8 PlatformSetWindowTitle
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowTitle;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowTitle = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_float PlatformSetWindowAlpha
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SetWindowAlpha;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_float) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_float));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SetWindowAlpha = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformUpdateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_UpdateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_UpdateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr PlatformRenderWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_RenderWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_RenderWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr PlatformSwapBuffers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_SwapBuffers;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_SwapBuffers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_float___IntPtr PlatformGetWindowDpiScale
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_GetWindowDpiScale;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_float___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_float___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_GetWindowDpiScale = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr PlatformOnChangedViewport
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_OnChangedViewport;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_OnChangedViewport = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr PlatformCreateVkSurface
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Platform_CreateVkSurface;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_int___IntPtr_ulong___IntPtr_ulongPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Platform_CreateVkSurface = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr RendererCreateWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_CreateWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_CreateWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr RendererDestroyWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_DestroyWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_DestroyWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal RendererSetWindowSize
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_SetWindowSize;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr_DearImguiSharp_ImVec2___Internal));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_SetWindowSize = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr RendererRenderWindow
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_RenderWindow;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_RenderWindow = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr RendererSwapBuffers
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Renderer_SwapBuffers;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->Renderer_SwapBuffers = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.ImVectorImGuiPlatformMonitor Monitors
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Monitors));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Monitors = *(global::DearImguiSharp.ImVectorImGuiPlatformMonitor.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiViewportPtr Viewports
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiViewportPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Viewports));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Viewports = *(global::DearImguiSharp.ImVectorImGuiViewportPtr.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiPlatformMonitor : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 36)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal MainPos;
            public global::DearImguiSharp.ImVec2.__Internal MainSize;
            public global::DearImguiSharp.ImVec2.__Internal WorkPos;
            public global::DearImguiSharp.ImVec2.__Internal WorkSize;
            public float DpiScale;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPlatformMonitor@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformMonitor>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformMonitor>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPlatformMonitor managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformMonitor>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPlatformMonitor managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformMonitor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformMonitor(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformMonitor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPlatformMonitor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPlatformMonitor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformMonitor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPlatformMonitor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformMonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformMonitor()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformMonitor(global::DearImguiSharp.ImGuiPlatformMonitor _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformMonitor.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPlatformMonitor.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPlatformMonitor.__Internal*) _0.__Instance);
        }

        ~ImGuiPlatformMonitor()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 MainPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MainPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MainPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 MainSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MainSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MainSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float DpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->DpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->DpiScale = value;
            }
        }
    }

    public unsafe partial class ImGuiPlatformImeData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte WantVisible;
            public global::DearImguiSharp.ImVec2.__Internal InputPos;
            public float InputLineHeight;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPlatformImeData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformImeData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformImeData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPlatformImeData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPlatformImeData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPlatformImeData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPlatformImeData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPlatformImeData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPlatformImeData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPlatformImeData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPlatformImeData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPlatformImeData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPlatformImeData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformImeData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPlatformImeData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformImeData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPlatformImeData(global::DearImguiSharp.ImGuiPlatformImeData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPlatformImeData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPlatformImeData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPlatformImeData.__Internal*) _0.__Instance);
        }

        ~ImGuiPlatformImeData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool WantVisible
        {
            get
            {
                return ((__Internal*)__Instance)->WantVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantVisible = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 InputPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float InputLineHeight
        {
            get
            {
                return ((__Internal*)__Instance)->InputLineHeight;
            }

            set
            {
                ((__Internal*)__Instance)->InputLineHeight = value;
            }
        }
    }

    public unsafe partial class StbUndoRecord : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int @where;
            public int insert_length;
            public int delete_length;
            public int char_storage;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbUndoRecord@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbUndoRecord>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbUndoRecord>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.StbUndoRecord managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.StbUndoRecord>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.StbUndoRecord managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbUndoRecord __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoRecord(native.ToPointer(), skipVTables);
        }

        internal static StbUndoRecord __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbUndoRecord)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbUndoRecord __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoRecord(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoRecord(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoRecord(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoRecord()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoRecord(global::DearImguiSharp.StbUndoRecord _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbUndoRecord.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.StbUndoRecord.__Internal*) __Instance) = *((global::DearImguiSharp.StbUndoRecord.__Internal*) _0.__Instance);
        }

        ~StbUndoRecord()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Where
        {
            get
            {
                return ((__Internal*)__Instance)->@where;
            }

            set
            {
                ((__Internal*)__Instance)->@where = value;
            }
        }

        public int InsertLength
        {
            get
            {
                return ((__Internal*)__Instance)->insert_length;
            }

            set
            {
                ((__Internal*)__Instance)->insert_length = value;
            }
        }

        public int DeleteLength
        {
            get
            {
                return ((__Internal*)__Instance)->delete_length;
            }

            set
            {
                ((__Internal*)__Instance)->delete_length = value;
            }
        }

        public int CharStorage
        {
            get
            {
                return ((__Internal*)__Instance)->char_storage;
            }

            set
            {
                ((__Internal*)__Instance)->char_storage = value;
            }
        }
    }

    public unsafe partial class StbUndoState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3596)]
        public partial struct __Internal
        {
            public fixed byte undo_rec[1584];
            public fixed ushort undo_char[999];
            public short undo_point;
            public short redo_point;
            public int undo_char_point;
            public int redo_char_point;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbUndoState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbUndoState>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbUndoState>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.StbUndoState managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.StbUndoState>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.StbUndoState managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbUndoState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbUndoState(native.ToPointer(), skipVTables);
        }

        internal static StbUndoState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbUndoState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbUndoState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbUndoState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbUndoState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbUndoState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbUndoState(global::DearImguiSharp.StbUndoState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbUndoState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.StbUndoState.__Internal*) __Instance) = *((global::DearImguiSharp.StbUndoState.__Internal*) _0.__Instance);
        }

        ~StbUndoState()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.StbUndoRecord[] UndoRec
        {
            get
            {
                global::DearImguiSharp.StbUndoRecord[] __value = null;
                if (((__Internal*)__Instance)->undo_rec != null)
                {
                    __value = new global::DearImguiSharp.StbUndoRecord[99];
                    for (int i = 0; i < 99; i++)
                        __value[i] = global::DearImguiSharp.StbUndoRecord.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.StbUndoRecord.__Internal*)&(((__Internal*)__Instance)->undo_rec[i * sizeof(global::DearImguiSharp.StbUndoRecord.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 99)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 99; i++)
                        *(global::DearImguiSharp.StbUndoRecord.__Internal*) &((__Internal*)__Instance)->undo_rec[i * sizeof(global::DearImguiSharp.StbUndoRecord.__Internal)] = *(global::DearImguiSharp.StbUndoRecord.__Internal*)value[i].__Instance;
                }
            }
        }

        public ushort[] UndoChar
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->undo_char, 999);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 999; i++)
                        ((__Internal*)__Instance)->undo_char[i] = value[i];
                }
            }
        }

        public short UndoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_point = value;
            }
        }

        public short RedoPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_point = value;
            }
        }

        public int UndoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->undo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->undo_char_point = value;
            }
        }

        public int RedoCharPoint
        {
            get
            {
                return ((__Internal*)__Instance)->redo_char_point;
            }

            set
            {
                ((__Internal*)__Instance)->redo_char_point = value;
            }
        }
    }

    public unsafe partial class STB_TexteditState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3628)]
        public partial struct __Internal
        {
            public int cursor;
            public int select_start;
            public int select_end;
            public byte insert_mode;
            public int row_count_per_page;
            public byte cursor_at_end_of_line;
            public byte initialized;
            public byte has_preferred_x;
            public byte single_line;
            public byte padding1;
            public byte padding2;
            public byte padding3;
            public float preferred_x;
            public global::DearImguiSharp.StbUndoState.__Internal undostate;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0STB_TexteditState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.STB_TexteditState>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.STB_TexteditState>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.STB_TexteditState managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.STB_TexteditState>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.STB_TexteditState managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static STB_TexteditState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new STB_TexteditState(native.ToPointer(), skipVTables);
        }

        internal static STB_TexteditState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (STB_TexteditState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static STB_TexteditState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new STB_TexteditState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private STB_TexteditState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public STB_TexteditState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public STB_TexteditState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public STB_TexteditState(global::DearImguiSharp.STB_TexteditState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.STB_TexteditState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.STB_TexteditState.__Internal*) __Instance) = *((global::DearImguiSharp.STB_TexteditState.__Internal*) _0.__Instance);
        }

        ~STB_TexteditState()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Cursor
        {
            get
            {
                return ((__Internal*)__Instance)->cursor;
            }

            set
            {
                ((__Internal*)__Instance)->cursor = value;
            }
        }

        public int SelectStart
        {
            get
            {
                return ((__Internal*)__Instance)->select_start;
            }

            set
            {
                ((__Internal*)__Instance)->select_start = value;
            }
        }

        public int SelectEnd
        {
            get
            {
                return ((__Internal*)__Instance)->select_end;
            }

            set
            {
                ((__Internal*)__Instance)->select_end = value;
            }
        }

        public byte InsertMode
        {
            get
            {
                return ((__Internal*)__Instance)->insert_mode;
            }

            set
            {
                ((__Internal*)__Instance)->insert_mode = value;
            }
        }

        public int RowCountPerPage
        {
            get
            {
                return ((__Internal*)__Instance)->row_count_per_page;
            }

            set
            {
                ((__Internal*)__Instance)->row_count_per_page = value;
            }
        }

        public byte CursorAtEndOfLine
        {
            get
            {
                return ((__Internal*)__Instance)->cursor_at_end_of_line;
            }

            set
            {
                ((__Internal*)__Instance)->cursor_at_end_of_line = value;
            }
        }

        public byte Initialized
        {
            get
            {
                return ((__Internal*)__Instance)->initialized;
            }

            set
            {
                ((__Internal*)__Instance)->initialized = value;
            }
        }

        public byte HasPreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->has_preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->has_preferred_x = value;
            }
        }

        public byte SingleLine
        {
            get
            {
                return ((__Internal*)__Instance)->single_line;
            }

            set
            {
                ((__Internal*)__Instance)->single_line = value;
            }
        }

        public byte Padding1
        {
            get
            {
                return ((__Internal*)__Instance)->padding1;
            }

            set
            {
                ((__Internal*)__Instance)->padding1 = value;
            }
        }

        public byte Padding2
        {
            get
            {
                return ((__Internal*)__Instance)->padding2;
            }

            set
            {
                ((__Internal*)__Instance)->padding2 = value;
            }
        }

        public byte Padding3
        {
            get
            {
                return ((__Internal*)__Instance)->padding3;
            }

            set
            {
                ((__Internal*)__Instance)->padding3 = value;
            }
        }

        public float PreferredX
        {
            get
            {
                return ((__Internal*)__Instance)->preferred_x;
            }

            set
            {
                ((__Internal*)__Instance)->preferred_x = value;
            }
        }

        public global::DearImguiSharp.StbUndoState Undostate
        {
            get
            {
                return global::DearImguiSharp.StbUndoState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->undostate));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->undostate = *(global::DearImguiSharp.StbUndoState.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class StbTexteditRow : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public float x0;
            public float x1;
            public float baseline_y_delta;
            public float ymin;
            public float ymax;
            public int num_chars;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0StbTexteditRow@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbTexteditRow>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.StbTexteditRow>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.StbTexteditRow managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.StbTexteditRow>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.StbTexteditRow managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static StbTexteditRow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new StbTexteditRow(native.ToPointer(), skipVTables);
        }

        internal static StbTexteditRow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (StbTexteditRow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static StbTexteditRow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new StbTexteditRow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private StbTexteditRow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbTexteditRow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public StbTexteditRow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public StbTexteditRow(global::DearImguiSharp.StbTexteditRow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.StbTexteditRow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.StbTexteditRow.__Internal*) __Instance) = *((global::DearImguiSharp.StbTexteditRow.__Internal*) _0.__Instance);
        }

        ~StbTexteditRow()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X0
        {
            get
            {
                return ((__Internal*)__Instance)->x0;
            }

            set
            {
                ((__Internal*)__Instance)->x0 = value;
            }
        }

        public float X1
        {
            get
            {
                return ((__Internal*)__Instance)->x1;
            }

            set
            {
                ((__Internal*)__Instance)->x1 = value;
            }
        }

        public float BaselineYDelta
        {
            get
            {
                return ((__Internal*)__Instance)->baseline_y_delta;
            }

            set
            {
                ((__Internal*)__Instance)->baseline_y_delta = value;
            }
        }

        public float Ymin
        {
            get
            {
                return ((__Internal*)__Instance)->ymin;
            }

            set
            {
                ((__Internal*)__Instance)->ymin = value;
            }
        }

        public float Ymax
        {
            get
            {
                return ((__Internal*)__Instance)->ymax;
            }

            set
            {
                ((__Internal*)__Instance)->ymax = value;
            }
        }

        public int NumChars
        {
            get
            {
                return ((__Internal*)__Instance)->num_chars;
            }

            set
            {
                ((__Internal*)__Instance)->num_chars = value;
            }
        }
    }

    public unsafe partial class ImVec1 : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public float x;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec1@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec1>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec1>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVec1 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVec1>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVec1 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec1 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec1(native.ToPointer(), skipVTables);
        }

        internal static ImVec1 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec1)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec1 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec1(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec1(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec1(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec1()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec1.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec1(global::DearImguiSharp.ImVec1 _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec1.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVec1.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec1.__Internal*) _0.__Instance);
        }

        ~ImVec1()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }
    }

    public unsafe partial class ImVec2ih : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public short x;
            public short y;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVec2ih@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec2ih>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVec2ih>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVec2ih managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVec2ih>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVec2ih managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVec2ih __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVec2ih(native.ToPointer(), skipVTables);
        }

        internal static ImVec2ih __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVec2ih)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVec2ih __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVec2ih(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVec2ih(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2ih(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVec2ih()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVec2ih(global::DearImguiSharp.ImVec2ih _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVec2ih.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVec2ih.__Internal*) __Instance) = *((global::DearImguiSharp.ImVec2ih.__Internal*) _0.__Instance);
        }

        ~ImVec2ih()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short X
        {
            get
            {
                return ((__Internal*)__Instance)->x;
            }

            set
            {
                ((__Internal*)__Instance)->x = value;
            }
        }

        public short Y
        {
            get
            {
                return ((__Internal*)__Instance)->y;
            }

            set
            {
                ((__Internal*)__Instance)->y = value;
            }
        }
    }

    public unsafe partial class ImRect : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal Min;
            public global::DearImguiSharp.ImVec2.__Internal Max;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImRect@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImRect>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImRect>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImRect managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImRect>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImRect managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImRect __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImRect(native.ToPointer(), skipVTables);
        }

        internal static ImRect __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImRect)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImRect __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImRect(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImRect(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImRect(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImRect()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImRect(global::DearImguiSharp.ImRect _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImRect.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImRect.__Internal*) __Instance) = *((global::DearImguiSharp.ImRect.__Internal*) _0.__Instance);
        }

        ~ImRect()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 Min
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Min));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Min = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Max
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Max));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Max = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImBitVector : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImU32.__Internal Storage;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImBitVector@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImBitVector>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImBitVector>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImBitVector managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImBitVector>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImBitVector managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImBitVector __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImBitVector(native.ToPointer(), skipVTables);
        }

        internal static ImBitVector __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImBitVector)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImBitVector __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImBitVector(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImBitVector(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitVector(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImBitVector()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImBitVector.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitVector(global::DearImguiSharp.ImBitVector _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImBitVector.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImBitVector.__Internal*) __Instance) = *((global::DearImguiSharp.ImBitVector.__Internal*) _0.__Instance);
        }

        ~ImBitVector()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImU32 Storage
        {
            get
            {
                return global::DearImguiSharp.ImVectorImU32.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Storage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Storage = *(global::DearImguiSharp.ImVectorImU32.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImDrawListSharedData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 512)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal TexUvWhitePixel;
            public __IntPtr Font;
            public float FontSize;
            public float CurveTessellationTol;
            public float CircleSegmentMaxError;
            public global::DearImguiSharp.ImVec4.__Internal ClipRectFullscreen;
            public int InitialFlags;
            public fixed byte ArcFastVtx[384];
            public float ArcFastRadiusCutoff;
            public fixed byte CircleSegmentCounts[64];
            public __IntPtr TexUvLines;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawListSharedData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawListSharedData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawListSharedData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawListSharedData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawListSharedData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawListSharedData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawListSharedData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native.ToPointer(), skipVTables);
        }

        internal static ImDrawListSharedData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawListSharedData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawListSharedData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawListSharedData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawListSharedData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSharedData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawListSharedData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawListSharedData(global::DearImguiSharp.ImDrawListSharedData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawListSharedData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawListSharedData.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawListSharedData.__Internal*) _0.__Instance);
        }

        ~ImDrawListSharedData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 TexUvWhitePixel
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TexUvWhitePixel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TexUvWhitePixel = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public float CurveTessellationTol
        {
            get
            {
                return ((__Internal*)__Instance)->CurveTessellationTol;
            }

            set
            {
                ((__Internal*)__Instance)->CurveTessellationTol = value;
            }
        }

        public float CircleSegmentMaxError
        {
            get
            {
                return ((__Internal*)__Instance)->CircleSegmentMaxError;
            }

            set
            {
                ((__Internal*)__Instance)->CircleSegmentMaxError = value;
            }
        }

        public global::DearImguiSharp.ImVec4 ClipRectFullscreen
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRectFullscreen));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRectFullscreen = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public int InitialFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InitialFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InitialFlags = value;
            }
        }

        public global::DearImguiSharp.ImVec2[] ArcFastVtx
        {
            get
            {
                global::DearImguiSharp.ImVec2[] __value = null;
                if (((__Internal*)__Instance)->ArcFastVtx != null)
                {
                    __value = new global::DearImguiSharp.ImVec2[48];
                    for (int i = 0; i < 48; i++)
                        __value[i] = global::DearImguiSharp.ImVec2.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVec2.__Internal*)&(((__Internal*)__Instance)->ArcFastVtx[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 48)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 48; i++)
                        *(global::DearImguiSharp.ImVec2.__Internal*) &((__Internal*)__Instance)->ArcFastVtx[i * sizeof(global::DearImguiSharp.ImVec2.__Internal)] = *(global::DearImguiSharp.ImVec2.__Internal*)value[i].__Instance;
                }
            }
        }

        public float ArcFastRadiusCutoff
        {
            get
            {
                return ((__Internal*)__Instance)->ArcFastRadiusCutoff;
            }

            set
            {
                ((__Internal*)__Instance)->ArcFastRadiusCutoff = value;
            }
        }

        public byte[] CircleSegmentCounts
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->CircleSegmentCounts, 64);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 64; i++)
                        ((__Internal*)__Instance)->CircleSegmentCounts[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImVec4 TexUvLines
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(((__Internal*)__Instance)->TexUvLines, false);
                return __result0;
            }
        }
    }

    public unsafe partial class ImVectorImDrawListPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImDrawListPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawListPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawListPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImDrawListPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImDrawListPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImDrawListPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImDrawListPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImDrawListPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImDrawListPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImDrawListPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImDrawListPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImDrawListPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImDrawListPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawListPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImDrawListPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImDrawListPtr(global::DearImguiSharp.ImVectorImDrawListPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImDrawListPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImDrawListPtr.__Internal*) _0.__Instance);
        }

        ~ImVectorImDrawListPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImDrawList Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImDrawDataBuilder : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public fixed byte Layers[32];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImDrawDataBuilder@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawDataBuilder>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImDrawDataBuilder>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImDrawDataBuilder managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImDrawDataBuilder>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImDrawDataBuilder managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImDrawDataBuilder __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImDrawDataBuilder(native.ToPointer(), skipVTables);
        }

        internal static ImDrawDataBuilder __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImDrawDataBuilder)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImDrawDataBuilder __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImDrawDataBuilder(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImDrawDataBuilder(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawDataBuilder(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImDrawDataBuilder()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImDrawDataBuilder(global::DearImguiSharp.ImDrawDataBuilder _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImDrawDataBuilder.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImDrawDataBuilder.__Internal*) __Instance) = *((global::DearImguiSharp.ImDrawDataBuilder.__Internal*) _0.__Instance);
        }

        ~ImDrawDataBuilder()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImDrawListPtr[] Layers
        {
            get
            {
                global::DearImguiSharp.ImVectorImDrawListPtr[] __value = null;
                if (((__Internal*)__Instance)->Layers != null)
                {
                    __value = new global::DearImguiSharp.ImVectorImDrawListPtr[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::DearImguiSharp.ImVectorImDrawListPtr.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImVectorImDrawListPtr.__Internal*)&(((__Internal*)__Instance)->Layers[i * sizeof(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal*) &((__Internal*)__Instance)->Layers[i * sizeof(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal)] = *(global::DearImguiSharp.ImVectorImDrawListPtr.__Internal*)value[i].__Instance;
                }
            }
        }
    }

    public unsafe partial class ImGuiDataTypeTempStorage : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public fixed byte Data[8];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDataTypeTempStorage@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeTempStorage>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeTempStorage>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDataTypeTempStorage managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeTempStorage>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDataTypeTempStorage managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDataTypeTempStorage __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDataTypeTempStorage(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDataTypeTempStorage __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDataTypeTempStorage)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDataTypeTempStorage __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDataTypeTempStorage(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDataTypeTempStorage(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeTempStorage(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDataTypeTempStorage()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDataTypeTempStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeTempStorage(global::DearImguiSharp.ImGuiDataTypeTempStorage _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDataTypeTempStorage.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiDataTypeTempStorage.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiDataTypeTempStorage.__Internal*) _0.__Instance);
        }

        ~ImGuiDataTypeTempStorage()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public byte[] Data
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->Data, 8);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 8; i++)
                        ((__Internal*)__Instance)->Data[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiDataTypeInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public IntPtr Size;
            public __IntPtr Name;
            public __IntPtr PrintFmt;
            public __IntPtr ScanFmt;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDataTypeInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeInfo>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeInfo>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDataTypeInfo managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDataTypeInfo>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDataTypeInfo managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool __Name_OwnsNativeMemory = false;
        private bool __PrintFmt_OwnsNativeMemory = false;
        private bool __ScanFmt_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiDataTypeInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDataTypeInfo(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDataTypeInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDataTypeInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDataTypeInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDataTypeInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDataTypeInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDataTypeInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDataTypeInfo(global::DearImguiSharp.ImGuiDataTypeInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDataTypeInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiDataTypeInfo.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiDataTypeInfo.__Internal*) _0.__Instance);
            if (_0.__Name_OwnsNativeMemory)
                this.Name = _0.Name;
            if (_0.__PrintFmt_OwnsNativeMemory)
                this.PrintFmt = _0.PrintFmt;
            if (_0.__ScanFmt_OwnsNativeMemory)
                this.ScanFmt = _0.ScanFmt;
        }

        ~ImGuiDataTypeInfo()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__Name_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->Name);
            if (__PrintFmt_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->PrintFmt);
            if (__ScanFmt_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->ScanFmt);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public IntPtr Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public string Name
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->Name);
            }

            set
            {
                if (__Name_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->Name);
                __Name_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->Name = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->Name = (__IntPtr) __bytePtr0;
            }
        }

        public string PrintFmt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->PrintFmt);
            }

            set
            {
                if (__PrintFmt_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->PrintFmt);
                __PrintFmt_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->PrintFmt = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->PrintFmt = (__IntPtr) __bytePtr0;
            }
        }

        public string ScanFmt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->ScanFmt);
            }

            set
            {
                if (__ScanFmt_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->ScanFmt);
                __ScanFmt_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->ScanFmt = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->ScanFmt = (__IntPtr) __bytePtr0;
            }
        }
    }

    public unsafe partial class ImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public int Col;
            public global::DearImguiSharp.ImVec4.__Internal BackupValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiColorMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiColorMod>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiColorMod>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiColorMod managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiColorMod>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiColorMod managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiColorMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static ImGuiColorMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiColorMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiColorMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiColorMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiColorMod(global::DearImguiSharp.ImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiColorMod.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiColorMod.__Internal*) _0.__Instance);
        }

        ~ImGuiColorMod()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Col
        {
            get
            {
                return ((__Internal*)__Instance)->Col;
            }

            set
            {
                ((__Internal*)__Instance)->Col = value;
            }
        }

        public global::DearImguiSharp.ImVec4 BackupValue
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupValue));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupValue = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int VarIdx;

            [FieldOffset(4)]
            public fixed int BackupInt[2];

            [FieldOffset(4)]
            public fixed float BackupFloat[2];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStyleMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStyleMod>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStyleMod>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStyleMod managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStyleMod>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStyleMod managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStyleMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStyleMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStyleMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStyleMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStyleMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStyleMod(global::DearImguiSharp.ImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStyleMod.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStyleMod.__Internal*) _0.__Instance);
        }

        ~ImGuiStyleMod()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int VarIdx
        {
            get
            {
                return ((__Internal*)__Instance)->VarIdx;
            }

            set
            {
                ((__Internal*)__Instance)->VarIdx = value;
            }
        }

        public int[] BackupInt
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->BackupInt, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->BackupInt[i] = value[i];
                }
            }
        }

        public float[] BackupFloat
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->BackupFloat, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->BackupFloat[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiComboPreviewData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImRect.__Internal PreviewRect;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorPos;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorMaxPos;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorPosPrevLine;
            public float BackupPrevLineTextBaseOffset;
            public int BackupLayout;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiComboPreviewData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiComboPreviewData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiComboPreviewData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiComboPreviewData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiComboPreviewData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiComboPreviewData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiComboPreviewData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiComboPreviewData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiComboPreviewData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiComboPreviewData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiComboPreviewData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiComboPreviewData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiComboPreviewData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiComboPreviewData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiComboPreviewData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiComboPreviewData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiComboPreviewData(global::DearImguiSharp.ImGuiComboPreviewData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiComboPreviewData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiComboPreviewData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiComboPreviewData.__Internal*) _0.__Instance);
        }

        ~ImGuiComboPreviewData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImRect PreviewRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PreviewRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PreviewRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorMaxPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorMaxPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorPosPrevLine
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPosPrevLine));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPosPrevLine = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float BackupPrevLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->BackupPrevLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->BackupPrevLineTextBaseOffset = value;
            }
        }

        public int BackupLayout
        {
            get
            {
                return ((__Internal*)__Instance)->BackupLayout;
            }

            set
            {
                ((__Internal*)__Instance)->BackupLayout = value;
            }
        }
    }

    public unsafe partial class ImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public uint WindowID;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorPos;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorMaxPos;
            public global::DearImguiSharp.ImVec1.__Internal BackupIndent;
            public global::DearImguiSharp.ImVec1.__Internal BackupGroupOffset;
            public global::DearImguiSharp.ImVec2.__Internal BackupCurrLineSize;
            public float BackupCurrLineTextBaseOffset;
            public uint BackupActiveIdIsAlive;
            public byte BackupActiveIdPreviousFrameIsAlive;
            public byte BackupHoveredIdIsAlive;
            public byte EmitItem;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiGroupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiGroupData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiGroupData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiGroupData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiGroupData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiGroupData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiGroupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiGroupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiGroupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiGroupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiGroupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiGroupData(global::DearImguiSharp.ImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiGroupData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiGroupData.__Internal*) _0.__Instance);
        }

        ~ImGuiGroupData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint WindowID
        {
            get
            {
                return ((__Internal*)__Instance)->WindowID;
            }

            set
            {
                ((__Internal*)__Instance)->WindowID = value;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorMaxPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorMaxPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec1 BackupIndent
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupIndent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupIndent = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec1 BackupGroupOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupGroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupGroupOffset = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCurrLineSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCurrLineSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float BackupCurrLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->BackupCurrLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->BackupCurrLineTextBaseOffset = value;
            }
        }

        public uint BackupActiveIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupActiveIdIsAlive;
            }

            set
            {
                ((__Internal*)__Instance)->BackupActiveIdIsAlive = value;
            }
        }

        public bool BackupActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackupActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool BackupHoveredIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->BackupHoveredIdIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->BackupHoveredIdIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool EmitItem
        {
            get
            {
                return ((__Internal*)__Instance)->EmitItem != 0;
            }

            set
            {
                ((__Internal*)__Instance)->EmitItem = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiMenuColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public uint TotalWidth;
            public uint NextTotalWidth;
            public ushort Spacing;
            public ushort OffsetIcon;
            public ushort OffsetLabel;
            public ushort OffsetShortcut;
            public ushort OffsetMark;
            public fixed ushort Widths[4];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiMenuColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiMenuColumns>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiMenuColumns>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiMenuColumns managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiMenuColumns>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiMenuColumns managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiMenuColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiMenuColumns(native.ToPointer(), skipVTables);
        }

        internal static ImGuiMenuColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiMenuColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiMenuColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiMenuColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiMenuColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMenuColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiMenuColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMenuColumns(global::DearImguiSharp.ImGuiMenuColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiMenuColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiMenuColumns.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiMenuColumns.__Internal*) _0.__Instance);
        }

        ~ImGuiMenuColumns()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint TotalWidth
        {
            get
            {
                return ((__Internal*)__Instance)->TotalWidth;
            }

            set
            {
                ((__Internal*)__Instance)->TotalWidth = value;
            }
        }

        public uint NextTotalWidth
        {
            get
            {
                return ((__Internal*)__Instance)->NextTotalWidth;
            }

            set
            {
                ((__Internal*)__Instance)->NextTotalWidth = value;
            }
        }

        public ushort Spacing
        {
            get
            {
                return ((__Internal*)__Instance)->Spacing;
            }

            set
            {
                ((__Internal*)__Instance)->Spacing = value;
            }
        }

        public ushort OffsetIcon
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetIcon;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetIcon = value;
            }
        }

        public ushort OffsetLabel
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetLabel;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetLabel = value;
            }
        }

        public ushort OffsetShortcut
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetShortcut;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetShortcut = value;
            }
        }

        public ushort OffsetMark
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetMark;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetMark = value;
            }
        }

        public ushort[] Widths
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<ushort>(((__Internal*)__Instance)->Widths, 4);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 4; i++)
                        ((__Internal*)__Instance)->Widths[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiInputTextState : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 3720)]
        public partial struct __Internal
        {
            public uint ID;
            public int CurLenW;
            public int CurLenA;
            public global::DearImguiSharp.ImVectorImWchar.__Internal TextW;
            public global::DearImguiSharp.ImVector_char.__Internal TextA;
            public global::DearImguiSharp.ImVector_char.__Internal InitialTextA;
            public byte TextAIsValid;
            public int BufCapacityA;
            public float ScrollX;
            public global::DearImguiSharp.STB_TexteditState.__Internal Stb;
            public float CursorAnim;
            public byte CursorFollow;
            public byte SelectedAllMouseLock;
            public byte Edited;
            public int Flags;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputTextState@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextState>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextState>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputTextState managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputTextState>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputTextState managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputTextState __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputTextState(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputTextState __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputTextState)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputTextState __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputTextState(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputTextState(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextState(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputTextState()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputTextState(global::DearImguiSharp.ImGuiInputTextState _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputTextState.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputTextState.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputTextState.__Internal*) _0.__Instance);
        }

        ~ImGuiInputTextState()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int CurLenW
        {
            get
            {
                return ((__Internal*)__Instance)->CurLenW;
            }

            set
            {
                ((__Internal*)__Instance)->CurLenW = value;
            }
        }

        public int CurLenA
        {
            get
            {
                return ((__Internal*)__Instance)->CurLenA;
            }

            set
            {
                ((__Internal*)__Instance)->CurLenA = value;
            }
        }

        public global::DearImguiSharp.ImVectorImWchar TextW
        {
            get
            {
                return global::DearImguiSharp.ImVectorImWchar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextW));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextW = *(global::DearImguiSharp.ImVectorImWchar.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVector_char TextA
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextA = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVector_char InitialTextA
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InitialTextA));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InitialTextA = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public bool TextAIsValid
        {
            get
            {
                return ((__Internal*)__Instance)->TextAIsValid != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TextAIsValid = (byte) (value ? 1 : 0);
            }
        }

        public int BufCapacityA
        {
            get
            {
                return ((__Internal*)__Instance)->BufCapacityA;
            }

            set
            {
                ((__Internal*)__Instance)->BufCapacityA = value;
            }
        }

        public float ScrollX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollX = value;
            }
        }

        public global::DearImguiSharp.STB_TexteditState Stb
        {
            get
            {
                return global::DearImguiSharp.STB_TexteditState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Stb));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Stb = *(global::DearImguiSharp.STB_TexteditState.__Internal*) value.__Instance;
            }
        }

        public float CursorAnim
        {
            get
            {
                return ((__Internal*)__Instance)->CursorAnim;
            }

            set
            {
                ((__Internal*)__Instance)->CursorAnim = value;
            }
        }

        public bool CursorFollow
        {
            get
            {
                return ((__Internal*)__Instance)->CursorFollow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->CursorFollow = (byte) (value ? 1 : 0);
            }
        }

        public bool SelectedAllMouseLock
        {
            get
            {
                return ((__Internal*)__Instance)->SelectedAllMouseLock != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SelectedAllMouseLock = (byte) (value ? 1 : 0);
            }
        }

        public bool Edited
        {
            get
            {
                return ((__Internal*)__Instance)->Edited != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Edited = (byte) (value ? 1 : 0);
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }
    }

    public unsafe partial class ImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public uint PopupId;
            public __IntPtr Window;
            public __IntPtr SourceWindow;
            public int ParentNavLayer;
            public int OpenFrameCount;
            public uint OpenParentId;
            public global::DearImguiSharp.ImVec2.__Internal OpenPopupPos;
            public global::DearImguiSharp.ImVec2.__Internal OpenMousePos;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPopupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPopupData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPopupData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPopupData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPopupData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPopupData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPopupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPopupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPopupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPopupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPopupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPopupData(global::DearImguiSharp.ImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPopupData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPopupData.__Internal*) _0.__Instance);
        }

        ~ImGuiPopupData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint PopupId
        {
            get
            {
                return ((__Internal*)__Instance)->PopupId;
            }

            set
            {
                ((__Internal*)__Instance)->PopupId = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow SourceWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->SourceWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->SourceWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int ParentNavLayer
        {
            get
            {
                return ((__Internal*)__Instance)->ParentNavLayer;
            }

            set
            {
                ((__Internal*)__Instance)->ParentNavLayer = value;
            }
        }

        public int OpenFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->OpenFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->OpenFrameCount = value;
            }
        }

        public uint OpenParentId
        {
            get
            {
                return ((__Internal*)__Instance)->OpenParentId;
            }

            set
            {
                ((__Internal*)__Instance)->OpenParentId = value;
            }
        }

        public global::DearImguiSharp.ImVec2 OpenPopupPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenPopupPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenPopupPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 OpenMousePos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenMousePos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextWindowData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 144)]
        public partial struct __Internal
        {
            public int Flags;
            public int PosCond;
            public int SizeCond;
            public int CollapsedCond;
            public int DockCond;
            public global::DearImguiSharp.ImVec2.__Internal PosVal;
            public global::DearImguiSharp.ImVec2.__Internal PosPivotVal;
            public global::DearImguiSharp.ImVec2.__Internal SizeVal;
            public global::DearImguiSharp.ImVec2.__Internal ContentSizeVal;
            public global::DearImguiSharp.ImVec2.__Internal ScrollVal;
            public byte PosUndock;
            public byte CollapsedVal;
            public global::DearImguiSharp.ImRect.__Internal SizeConstraintRect;
            public __IntPtr SizeCallback;
            public __IntPtr SizeCallbackUserData;
            public float BgAlphaVal;
            public uint ViewportId;
            public uint DockId;
            public global::DearImguiSharp.ImGuiWindowClass.__Internal WindowClass;
            public global::DearImguiSharp.ImVec2.__Internal MenuBarOffsetMinVal;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNextWindowData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNextWindowData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNextWindowData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiNextWindowData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiNextWindowData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiNextWindowData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNextWindowData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNextWindowData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNextWindowData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNextWindowData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNextWindowData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNextWindowData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextWindowData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextWindowData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNextWindowData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextWindowData(global::DearImguiSharp.ImGuiNextWindowData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNextWindowData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiNextWindowData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiNextWindowData.__Internal*) _0.__Instance);
        }

        ~ImGuiNextWindowData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public int PosCond
        {
            get
            {
                return ((__Internal*)__Instance)->PosCond;
            }

            set
            {
                ((__Internal*)__Instance)->PosCond = value;
            }
        }

        public int SizeCond
        {
            get
            {
                return ((__Internal*)__Instance)->SizeCond;
            }

            set
            {
                ((__Internal*)__Instance)->SizeCond = value;
            }
        }

        public int CollapsedCond
        {
            get
            {
                return ((__Internal*)__Instance)->CollapsedCond;
            }

            set
            {
                ((__Internal*)__Instance)->CollapsedCond = value;
            }
        }

        public int DockCond
        {
            get
            {
                return ((__Internal*)__Instance)->DockCond;
            }

            set
            {
                ((__Internal*)__Instance)->DockCond = value;
            }
        }

        public global::DearImguiSharp.ImVec2 PosVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PosVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 PosPivotVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PosPivotVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PosPivotVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SizeVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ContentSizeVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool PosUndock
        {
            get
            {
                return ((__Internal*)__Instance)->PosUndock != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PosUndock = (byte) (value ? 1 : 0);
            }
        }

        public bool CollapsedVal
        {
            get
            {
                return ((__Internal*)__Instance)->CollapsedVal != 0;
            }

            set
            {
                ((__Internal*)__Instance)->CollapsedVal = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImRect SizeConstraintRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeConstraintRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeConstraintRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiSizeCallback SizeCallback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->SizeCallback;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.ImGuiSizeCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.ImGuiSizeCallback));
            }

            set
            {
                ((__Internal*)__Instance)->SizeCallback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr SizeCallbackUserData
        {
            get
            {
                return ((__Internal*)__Instance)->SizeCallbackUserData;
            }

            set
            {
                ((__Internal*)__Instance)->SizeCallbackUserData = (__IntPtr) value;
            }
        }

        public float BgAlphaVal
        {
            get
            {
                return ((__Internal*)__Instance)->BgAlphaVal;
            }

            set
            {
                ((__Internal*)__Instance)->BgAlphaVal = value;
            }
        }

        public uint ViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportId = value;
            }
        }

        public uint DockId
        {
            get
            {
                return ((__Internal*)__Instance)->DockId;
            }

            set
            {
                ((__Internal*)__Instance)->DockId = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindowClass WindowClass
        {
            get
            {
                return global::DearImguiSharp.ImGuiWindowClass.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowClass));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowClass = *(global::DearImguiSharp.ImGuiWindowClass.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 MenuBarOffsetMinVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuBarOffsetMinVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuBarOffsetMinVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNextItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public int Flags;
            public float Width;
            public uint FocusScopeId;
            public int OpenCond;
            public byte OpenVal;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNextItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNextItemData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNextItemData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiNextItemData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiNextItemData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiNextItemData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNextItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNextItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNextItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNextItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNextItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNextItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNextItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNextItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNextItemData(global::DearImguiSharp.ImGuiNextItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNextItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiNextItemData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiNextItemData.__Internal*) _0.__Instance);
        }

        ~ImGuiNextItemData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->FocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public int OpenCond
        {
            get
            {
                return ((__Internal*)__Instance)->OpenCond;
            }

            set
            {
                ((__Internal*)__Instance)->OpenCond = value;
            }
        }

        public bool OpenVal
        {
            get
            {
                return ((__Internal*)__Instance)->OpenVal != 0;
            }

            set
            {
                ((__Internal*)__Instance)->OpenVal = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiLastItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 60)]
        public partial struct __Internal
        {
            public uint ID;
            public int InFlags;
            public int StatusFlags;
            public global::DearImguiSharp.ImRect.__Internal Rect;
            public global::DearImguiSharp.ImRect.__Internal NavRect;
            public global::DearImguiSharp.ImRect.__Internal DisplayRect;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiLastItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiLastItemData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiLastItemData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiLastItemData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiLastItemData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiLastItemData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiLastItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiLastItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiLastItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiLastItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiLastItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiLastItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiLastItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiLastItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiLastItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiLastItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiLastItemData(global::DearImguiSharp.ImGuiLastItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiLastItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiLastItemData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiLastItemData.__Internal*) _0.__Instance);
        }

        ~ImGuiLastItemData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int InFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InFlags = value;
            }
        }

        public int StatusFlags
        {
            get
            {
                return ((__Internal*)__Instance)->StatusFlags;
            }

            set
            {
                ((__Internal*)__Instance)->StatusFlags = value;
            }
        }

        public global::DearImguiSharp.ImRect Rect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Rect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Rect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect NavRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect DisplayRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStackSizes : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 18)]
        public partial struct __Internal
        {
            public short SizeOfIDStack;
            public short SizeOfColorStack;
            public short SizeOfStyleVarStack;
            public short SizeOfFontStack;
            public short SizeOfFocusScopeStack;
            public short SizeOfGroupStack;
            public short SizeOfItemFlagsStack;
            public short SizeOfBeginPopupStack;
            public short SizeOfDisabledStack;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackSizes@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackSizes>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackSizes>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStackSizes managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStackSizes>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStackSizes managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackSizes __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackSizes(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackSizes __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackSizes)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackSizes __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackSizes(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackSizes(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackSizes(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackSizes()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackSizes.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackSizes(global::DearImguiSharp.ImGuiStackSizes _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackSizes.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStackSizes.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStackSizes.__Internal*) _0.__Instance);
        }

        ~ImGuiStackSizes()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public short SizeOfIDStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfIDStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfIDStack = value;
            }
        }

        public short SizeOfColorStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfColorStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfColorStack = value;
            }
        }

        public short SizeOfStyleVarStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfStyleVarStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfStyleVarStack = value;
            }
        }

        public short SizeOfFontStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfFontStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfFontStack = value;
            }
        }

        public short SizeOfFocusScopeStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfFocusScopeStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfFocusScopeStack = value;
            }
        }

        public short SizeOfGroupStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfGroupStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfGroupStack = value;
            }
        }

        public short SizeOfItemFlagsStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfItemFlagsStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfItemFlagsStack = value;
            }
        }

        public short SizeOfBeginPopupStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfBeginPopupStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfBeginPopupStack = value;
            }
        }

        public short SizeOfDisabledStack
        {
            get
            {
                return ((__Internal*)__Instance)->SizeOfDisabledStack;
            }

            set
            {
                ((__Internal*)__Instance)->SizeOfDisabledStack = value;
            }
        }
    }

    public unsafe partial class ImGuiWindowStackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            public __IntPtr Window;
            public global::DearImguiSharp.ImGuiLastItemData.__Internal ParentLastItemDataBackup;
            public global::DearImguiSharp.ImGuiStackSizes.__Internal StackSizesOnBegin;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowStackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowStackData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowStackData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindowStackData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindowStackData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindowStackData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowStackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowStackData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowStackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowStackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowStackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowStackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowStackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowStackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowStackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowStackData(global::DearImguiSharp.ImGuiWindowStackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindowStackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindowStackData.__Internal*) _0.__Instance);
        }

        ~ImGuiWindowStackData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiLastItemData ParentLastItemDataBackup
        {
            get
            {
                return global::DearImguiSharp.ImGuiLastItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ParentLastItemDataBackup));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ParentLastItemDataBackup = *(global::DearImguiSharp.ImGuiLastItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStackSizes StackSizesOnBegin
        {
            get
            {
                return global::DearImguiSharp.ImGuiStackSizes.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StackSizesOnBegin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StackSizesOnBegin = *(global::DearImguiSharp.ImGuiStackSizes.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public int Index;
            public float Width;
            public float InitialWidth;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiShrinkWidthItem>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiShrinkWidthItem>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiShrinkWidthItem managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiShrinkWidthItem>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiShrinkWidthItem managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiShrinkWidthItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static ImGuiShrinkWidthItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiShrinkWidthItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiShrinkWidthItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiShrinkWidthItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiShrinkWidthItem(global::DearImguiSharp.ImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        ~ImGuiShrinkWidthItem()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public float InitialWidth
        {
            get
            {
                return ((__Internal*)__Instance)->InitialWidth;
            }

            set
            {
                ((__Internal*)__Instance)->InitialWidth = value;
            }
        }
    }

    public unsafe partial class ImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Ptr;
            public int Index;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiPtrOrIndex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPtrOrIndex>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiPtrOrIndex>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiPtrOrIndex managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiPtrOrIndex>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiPtrOrIndex managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiPtrOrIndex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static ImGuiPtrOrIndex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiPtrOrIndex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiPtrOrIndex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiPtrOrIndex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiPtrOrIndex(global::DearImguiSharp.ImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiPtrOrIndex.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        ~ImGuiPtrOrIndex()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public __IntPtr Ptr
        {
            get
            {
                return ((__Internal*)__Instance)->Ptr;
            }

            set
            {
                ((__Internal*)__Instance)->Ptr = (__IntPtr) value;
            }
        }

        public int Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }
    }

    public unsafe partial class ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 20)]
        public partial struct __Internal
        {
            public fixed uint Storage[5];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(native.ToPointer(), skipVTables);
        }

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN(global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) __Instance) = *((global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) _0.__Instance);
        }

        ~ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] Storage
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->Storage, 5);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 5; i++)
                        ((__Internal*)__Instance)->Storage[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImGuiInputEventMousePos : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float PosX;
            public float PosY;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMousePos@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMousePos>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMousePos>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventMousePos managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMousePos>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventMousePos managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMousePos __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMousePos(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMousePos __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMousePos)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMousePos __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMousePos(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMousePos(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMousePos(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMousePos()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMousePos.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMousePos(global::DearImguiSharp.ImGuiInputEventMousePos _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMousePos.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventMousePos.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventMousePos.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventMousePos()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float PosX
        {
            get
            {
                return ((__Internal*)__Instance)->PosX;
            }

            set
            {
                ((__Internal*)__Instance)->PosX = value;
            }
        }

        public float PosY
        {
            get
            {
                return ((__Internal*)__Instance)->PosY;
            }

            set
            {
                ((__Internal*)__Instance)->PosY = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventMouseWheel : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float WheelX;
            public float WheelY;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMouseWheel@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseWheel>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseWheel>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventMouseWheel managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseWheel>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventMouseWheel managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMouseWheel __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseWheel(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMouseWheel __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMouseWheel)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMouseWheel __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseWheel(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMouseWheel(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseWheel(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMouseWheel()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseWheel(global::DearImguiSharp.ImGuiInputEventMouseWheel _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventMouseWheel()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float WheelX
        {
            get
            {
                return ((__Internal*)__Instance)->WheelX;
            }

            set
            {
                ((__Internal*)__Instance)->WheelX = value;
            }
        }

        public float WheelY
        {
            get
            {
                return ((__Internal*)__Instance)->WheelY;
            }

            set
            {
                ((__Internal*)__Instance)->WheelY = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventMouseButton : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public int Button;
            public byte Down;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMouseButton@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseButton>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseButton>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventMouseButton managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseButton>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventMouseButton managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMouseButton __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseButton(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMouseButton __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMouseButton)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMouseButton __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseButton(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMouseButton(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseButton(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMouseButton()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseButton(global::DearImguiSharp.ImGuiInputEventMouseButton _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventMouseButton()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Button
        {
            get
            {
                return ((__Internal*)__Instance)->Button;
            }

            set
            {
                ((__Internal*)__Instance)->Button = value;
            }
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiInputEventMouseViewport : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public uint HoveredViewportID;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventMouseViewport@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseViewport>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseViewport>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventMouseViewport managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventMouseViewport>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventMouseViewport managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventMouseViewport __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseViewport(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventMouseViewport __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventMouseViewport)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventMouseViewport __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventMouseViewport(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventMouseViewport(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseViewport(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventMouseViewport()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventMouseViewport(global::DearImguiSharp.ImGuiInputEventMouseViewport _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventMouseViewport()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint HoveredViewportID
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredViewportID;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredViewportID = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventKey : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public int Key;
            public byte Down;
            public float AnalogValue;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventKey@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventKey>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventKey>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventKey managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventKey>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventKey managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventKey __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventKey(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventKey __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventKey)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventKey __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventKey(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventKey(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventKey(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventKey()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventKey.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventKey(global::DearImguiSharp.ImGuiInputEventKey _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventKey.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventKey.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventKey.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventKey()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Key
        {
            get
            {
                return ((__Internal*)__Instance)->Key;
            }

            set
            {
                ((__Internal*)__Instance)->Key = value;
            }
        }

        public bool Down
        {
            get
            {
                return ((__Internal*)__Instance)->Down != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Down = (byte) (value ? 1 : 0);
            }
        }

        public float AnalogValue
        {
            get
            {
                return ((__Internal*)__Instance)->AnalogValue;
            }

            set
            {
                ((__Internal*)__Instance)->AnalogValue = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventText : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 4)]
        public partial struct __Internal
        {
            public uint Char;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventText@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventText>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventText>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventText managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventText>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventText managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventText __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventText(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventText __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventText)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventText __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventText(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventText(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventText(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventText()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventText.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventText(global::DearImguiSharp.ImGuiInputEventText _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventText.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventText.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventText.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventText()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint Char
        {
            get
            {
                return ((__Internal*)__Instance)->Char;
            }

            set
            {
                ((__Internal*)__Instance)->Char = value;
            }
        }
    }

    public unsafe partial class ImGuiInputEventAppFocused : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 1)]
        public partial struct __Internal
        {
            public byte Focused;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEventAppFocused@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventAppFocused>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventAppFocused>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEventAppFocused managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEventAppFocused>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEventAppFocused managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEventAppFocused __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEventAppFocused(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEventAppFocused __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEventAppFocused)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEventAppFocused __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEventAppFocused(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEventAppFocused(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventAppFocused(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEventAppFocused()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEventAppFocused(global::DearImguiSharp.ImGuiInputEventAppFocused _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEventAppFocused()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Focused
        {
            get
            {
                return ((__Internal*)__Instance)->Focused != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Focused = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 24)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public global::DearImguiSharp.ImGuiInputEventType Type;

            [FieldOffset(4)]
            public global::DearImguiSharp.ImGuiInputSource Source;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventMousePos.__Internal MousePos;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal MouseWheel;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal MouseButton;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal MouseViewport;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventKey.__Internal Key;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventText.__Internal Text;

            [FieldOffset(8)]
            public global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal AppFocused;

            [FieldOffset(20)]
            public byte AddedByTestEngine;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiInputEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEvent>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiInputEvent>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiInputEvent managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiInputEvent>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiInputEvent managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiInputEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiInputEvent(native.ToPointer(), skipVTables);
        }

        internal static ImGuiInputEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiInputEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiInputEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiInputEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiInputEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiInputEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiInputEvent(global::DearImguiSharp.ImGuiInputEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiInputEvent.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiInputEvent.__Internal*) _0.__Instance);
        }

        ~ImGuiInputEvent()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiInputEventType Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public global::DearImguiSharp.ImGuiInputSource Source
        {
            get
            {
                return ((__Internal*)__Instance)->Source;
            }

            set
            {
                ((__Internal*)__Instance)->Source = value;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventMousePos MousePos
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventMousePos.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MousePos = *(global::DearImguiSharp.ImGuiInputEventMousePos.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventMouseWheel MouseWheel
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventMouseWheel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseWheel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseWheel = *(global::DearImguiSharp.ImGuiInputEventMouseWheel.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventMouseButton MouseButton
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventMouseButton.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseButton));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseButton = *(global::DearImguiSharp.ImGuiInputEventMouseButton.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventMouseViewport MouseViewport
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventMouseViewport.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseViewport));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseViewport = *(global::DearImguiSharp.ImGuiInputEventMouseViewport.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventKey Key
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventKey.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Key));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Key = *(global::DearImguiSharp.ImGuiInputEventKey.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventText Text
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventText.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Text));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Text = *(global::DearImguiSharp.ImGuiInputEventText.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputEventAppFocused AppFocused
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputEventAppFocused.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->AppFocused));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->AppFocused = *(global::DearImguiSharp.ImGuiInputEventAppFocused.__Internal*) value.__Instance;
            }
        }

        public bool AddedByTestEngine
        {
            get
            {
                return ((__Internal*)__Instance)->AddedByTestEngine != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AddedByTestEngine = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiListClipperRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 12)]
        public partial struct __Internal
        {
            public int Min;
            public int Max;
            public byte PosToIndexConvert;
            public sbyte PosToIndexOffsetMin;
            public sbyte PosToIndexOffsetMax;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipperRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperRange>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperRange>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiListClipperRange managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperRange>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiListClipperRange managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipperRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipperRange(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipperRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipperRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipperRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipperRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipperRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipperRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperRange(global::DearImguiSharp.ImGuiListClipperRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiListClipperRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiListClipperRange.__Internal*) _0.__Instance);
        }

        ~ImGuiListClipperRange()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Min
        {
            get
            {
                return ((__Internal*)__Instance)->Min;
            }

            set
            {
                ((__Internal*)__Instance)->Min = value;
            }
        }

        public int Max
        {
            get
            {
                return ((__Internal*)__Instance)->Max;
            }

            set
            {
                ((__Internal*)__Instance)->Max = value;
            }
        }

        public bool PosToIndexConvert
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexConvert != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexConvert = (byte) (value ? 1 : 0);
            }
        }

        public sbyte PosToIndexOffsetMin
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexOffsetMin;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexOffsetMin = value;
            }
        }

        public sbyte PosToIndexOffsetMax
        {
            get
            {
                return ((__Internal*)__Instance)->PosToIndexOffsetMax;
            }

            set
            {
                ((__Internal*)__Instance)->PosToIndexOffsetMax = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiListClipperRange : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiListClipperRange@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperRange>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperRange>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiListClipperRange managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperRange>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiListClipperRange managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiListClipperRange __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperRange(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiListClipperRange __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiListClipperRange)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiListClipperRange __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperRange(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiListClipperRange(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperRange(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiListClipperRange()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperRange(global::DearImguiSharp.ImVectorImGuiListClipperRange _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiListClipperRange()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiListClipperRange Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiListClipperRange.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiListClipperData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public __IntPtr ListClipper;
            public float LossynessOffset;
            public int StepNo;
            public int ItemsFrozen;
            public global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal Ranges;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiListClipperData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiListClipperData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiListClipperData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiListClipperData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiListClipperData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiListClipperData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiListClipperData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiListClipperData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiListClipperData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiListClipperData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiListClipperData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiListClipperData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiListClipperData(global::DearImguiSharp.ImGuiListClipperData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiListClipperData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiListClipperData.__Internal*) _0.__Instance);
        }

        ~ImGuiListClipperData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiListClipper ListClipper
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiListClipper.__GetOrCreateInstance(((__Internal*)__Instance)->ListClipper, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ListClipper = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float LossynessOffset
        {
            get
            {
                return ((__Internal*)__Instance)->LossynessOffset;
            }

            set
            {
                ((__Internal*)__Instance)->LossynessOffset = value;
            }
        }

        public int StepNo
        {
            get
            {
                return ((__Internal*)__Instance)->StepNo;
            }

            set
            {
                ((__Internal*)__Instance)->StepNo = value;
            }
        }

        public int ItemsFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ItemsFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ItemsFrozen = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiListClipperRange Ranges
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiListClipperRange.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Ranges));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Ranges = *(global::DearImguiSharp.ImVectorImGuiListClipperRange.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiNavItemData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public __IntPtr Window;
            public uint ID;
            public uint FocusScopeId;
            public global::DearImguiSharp.ImRect.__Internal RectRel;
            public int InFlags;
            public float DistBox;
            public float DistCenter;
            public float DistAxial;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiNavItemData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNavItemData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiNavItemData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiNavItemData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiNavItemData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiNavItemData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiNavItemData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiNavItemData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiNavItemData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiNavItemData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiNavItemData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiNavItemData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiNavItemData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNavItemData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiNavItemData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNavItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiNavItemData(global::DearImguiSharp.ImGuiNavItemData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiNavItemData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiNavItemData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiNavItemData.__Internal*) _0.__Instance);
        }

        ~ImGuiNavItemData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public uint FocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->FocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->FocusScopeId = value;
            }
        }

        public global::DearImguiSharp.ImRect RectRel
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->RectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->RectRel = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public int InFlags
        {
            get
            {
                return ((__Internal*)__Instance)->InFlags;
            }

            set
            {
                ((__Internal*)__Instance)->InFlags = value;
            }
        }

        public float DistBox
        {
            get
            {
                return ((__Internal*)__Instance)->DistBox;
            }

            set
            {
                ((__Internal*)__Instance)->DistBox = value;
            }
        }

        public float DistCenter
        {
            get
            {
                return ((__Internal*)__Instance)->DistCenter;
            }

            set
            {
                ((__Internal*)__Instance)->DistCenter = value;
            }
        }

        public float DistAxial
        {
            get
            {
                return ((__Internal*)__Instance)->DistAxial;
            }

            set
            {
                ((__Internal*)__Instance)->DistAxial = value;
            }
        }
    }

    public unsafe partial class ImGuiOldColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 28)]
        public partial struct __Internal
        {
            public float OffsetNorm;
            public float OffsetNormBeforeResize;
            public int Flags;
            public global::DearImguiSharp.ImRect.__Internal ClipRect;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOldColumnData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumnData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumnData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiOldColumnData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumnData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiOldColumnData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOldColumnData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOldColumnData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOldColumnData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOldColumnData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOldColumnData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOldColumnData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOldColumnData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOldColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumnData(global::DearImguiSharp.ImGuiOldColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiOldColumnData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiOldColumnData.__Internal*) _0.__Instance);
        }

        ~ImGuiOldColumnData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float OffsetNorm
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetNorm;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetNorm = value;
            }
        }

        public float OffsetNormBeforeResize
        {
            get
            {
                return ((__Internal*)__Instance)->OffsetNormBeforeResize;
            }

            set
            {
                ((__Internal*)__Instance)->OffsetNormBeforeResize = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::DearImguiSharp.ImRect ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiOldColumnData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiOldColumnData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumnData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumnData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiOldColumnData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumnData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiOldColumnData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiOldColumnData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumnData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiOldColumnData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiOldColumnData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiOldColumnData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumnData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiOldColumnData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumnData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiOldColumnData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumnData(global::DearImguiSharp.ImVectorImGuiOldColumnData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiOldColumnData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiOldColumnData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiOldColumnData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiOldColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 136)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public byte IsFirstFrame;
            public byte IsBeingResized;
            public int Current;
            public int Count;
            public float OffMinX;
            public float OffMaxX;
            public float LineMinY;
            public float LineMaxY;
            public float HostCursorPosY;
            public float HostCursorMaxPosX;
            public global::DearImguiSharp.ImRect.__Internal HostInitialClipRect;
            public global::DearImguiSharp.ImRect.__Internal HostBackupClipRect;
            public global::DearImguiSharp.ImRect.__Internal HostBackupParentWorkRect;
            public global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal Columns;
            public global::DearImguiSharp.ImDrawListSplitter.__Internal Splitter;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiOldColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumns>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumns>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiOldColumns managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiOldColumns>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiOldColumns managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiOldColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiOldColumns(native.ToPointer(), skipVTables);
        }

        internal static ImGuiOldColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiOldColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiOldColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiOldColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiOldColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiOldColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiOldColumns(global::DearImguiSharp.ImGuiOldColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiOldColumns.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiOldColumns.__Internal*) _0.__Instance);
        }

        ~ImGuiOldColumns()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public bool IsFirstFrame
        {
            get
            {
                return ((__Internal*)__Instance)->IsFirstFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsFirstFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool IsBeingResized
        {
            get
            {
                return ((__Internal*)__Instance)->IsBeingResized != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsBeingResized = (byte) (value ? 1 : 0);
            }
        }

        public int Current
        {
            get
            {
                return ((__Internal*)__Instance)->Current;
            }

            set
            {
                ((__Internal*)__Instance)->Current = value;
            }
        }

        public int Count
        {
            get
            {
                return ((__Internal*)__Instance)->Count;
            }

            set
            {
                ((__Internal*)__Instance)->Count = value;
            }
        }

        public float OffMinX
        {
            get
            {
                return ((__Internal*)__Instance)->OffMinX;
            }

            set
            {
                ((__Internal*)__Instance)->OffMinX = value;
            }
        }

        public float OffMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->OffMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->OffMaxX = value;
            }
        }

        public float LineMinY
        {
            get
            {
                return ((__Internal*)__Instance)->LineMinY;
            }

            set
            {
                ((__Internal*)__Instance)->LineMinY = value;
            }
        }

        public float LineMaxY
        {
            get
            {
                return ((__Internal*)__Instance)->LineMaxY;
            }

            set
            {
                ((__Internal*)__Instance)->LineMaxY = value;
            }
        }

        public float HostCursorPosY
        {
            get
            {
                return ((__Internal*)__Instance)->HostCursorPosY;
            }

            set
            {
                ((__Internal*)__Instance)->HostCursorPosY = value;
            }
        }

        public float HostCursorMaxPosX
        {
            get
            {
                return ((__Internal*)__Instance)->HostCursorMaxPosX;
            }

            set
            {
                ((__Internal*)__Instance)->HostCursorMaxPosX = value;
            }
        }

        public global::DearImguiSharp.ImRect HostInitialClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostInitialClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostInitialClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostBackupClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostBackupParentWorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupParentWorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiOldColumnData Columns
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiOldColumnData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Columns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Columns = *(global::DearImguiSharp.ImVectorImGuiOldColumnData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawListSplitter Splitter
        {
            get
            {
                return global::DearImguiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Splitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Splitter = *(global::DearImguiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiWindowPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiWindowPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiWindowPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiWindowPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiWindowPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiWindowPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiWindowPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiWindowPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowPtr(global::DearImguiSharp.ImVectorImGuiWindowPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiWindowPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindow Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImGuiDockNode : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 208)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public uint ID;

            [FieldOffset(4)]
            public int SharedFlags;

            [FieldOffset(8)]
            public int LocalFlags;

            [FieldOffset(12)]
            public int LocalFlagsInWindows;

            [FieldOffset(16)]
            public int MergedFlags;

            [FieldOffset(20)]
            public global::DearImguiSharp.ImGuiDockNodeState State;

            [FieldOffset(24)]
            public __IntPtr ParentNode;

            [FieldOffset(32)]
            public fixed long ChildNodes[2];

            [FieldOffset(48)]
            public global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal Windows;

            [FieldOffset(64)]
            public __IntPtr TabBar;

            [FieldOffset(72)]
            public global::DearImguiSharp.ImVec2.__Internal Pos;

            [FieldOffset(80)]
            public global::DearImguiSharp.ImVec2.__Internal Size;

            [FieldOffset(88)]
            public global::DearImguiSharp.ImVec2.__Internal SizeRef;

            [FieldOffset(96)]
            public global::DearImguiSharp.ImGuiAxis SplitAxis;

            [FieldOffset(100)]
            public global::DearImguiSharp.ImGuiWindowClass.__Internal WindowClass;

            [FieldOffset(128)]
            public uint LastBgColor;

            [FieldOffset(136)]
            public __IntPtr HostWindow;

            [FieldOffset(144)]
            public __IntPtr VisibleWindow;

            [FieldOffset(152)]
            public __IntPtr CentralNode;

            [FieldOffset(160)]
            public __IntPtr OnlyNodeWithWindows;

            [FieldOffset(168)]
            public int CountNodeWithWindows;

            [FieldOffset(172)]
            public int LastFrameAlive;

            [FieldOffset(176)]
            public int LastFrameActive;

            [FieldOffset(180)]
            public int LastFrameFocused;

            [FieldOffset(184)]
            public uint LastFocusedNodeId;

            [FieldOffset(188)]
            public uint SelectedTabId;

            [FieldOffset(192)]
            public uint WantCloseTabId;

            [FieldOffset(196)]
            public int AuthorityForPos;

            [FieldOffset(196)]
            public int AuthorityForSize;

            [FieldOffset(196)]
            public int AuthorityForViewport;

            [FieldOffset(200)]
            public byte IsVisible;

            [FieldOffset(200)]
            public byte IsFocused;

            [FieldOffset(200)]
            public byte IsBgDrawnThisFrame;

            [FieldOffset(200)]
            public byte HasCloseButton;

            [FieldOffset(200)]
            public byte HasWindowMenuButton;

            [FieldOffset(200)]
            public byte HasCentralNodeChild;

            [FieldOffset(200)]
            public byte WantCloseAll;

            [FieldOffset(200)]
            public byte WantLockSizeOnce;

            [FieldOffset(201)]
            public byte WantMouseMove;

            [FieldOffset(201)]
            public byte WantHiddenTabBarUpdate;

            [FieldOffset(201)]
            public byte WantHiddenTabBarToggle;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDockNode@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockNode>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockNode>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDockNode managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDockNode>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDockNode managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDockNode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDockNode(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDockNode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDockNode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDockNode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDockNode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDockNode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockNode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDockNode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDockNode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockNode(global::DearImguiSharp.ImGuiDockNode _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDockNode.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiDockNode.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiDockNode.__Internal*) _0.__Instance);
        }

        ~ImGuiDockNode()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int SharedFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SharedFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SharedFlags = value;
            }
        }

        public int LocalFlags
        {
            get
            {
                return ((__Internal*)__Instance)->LocalFlags;
            }

            set
            {
                ((__Internal*)__Instance)->LocalFlags = value;
            }
        }

        public int LocalFlagsInWindows
        {
            get
            {
                return ((__Internal*)__Instance)->LocalFlagsInWindows;
            }

            set
            {
                ((__Internal*)__Instance)->LocalFlagsInWindows = value;
            }
        }

        public int MergedFlags
        {
            get
            {
                return ((__Internal*)__Instance)->MergedFlags;
            }

            set
            {
                ((__Internal*)__Instance)->MergedFlags = value;
            }
        }

        public global::DearImguiSharp.ImGuiDockNodeState State
        {
            get
            {
                return ((__Internal*)__Instance)->State;
            }

            set
            {
                ((__Internal*)__Instance)->State = value;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode ParentNode
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->ParentNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ParentNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode[] ChildNodes
        {
            get
            {
                global::DearImguiSharp.ImGuiDockNode[] __value = null;
                if (((__Internal*)__Instance)->ChildNodes != null)
                {
                    __value = new global::DearImguiSharp.ImGuiDockNode[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::DearImguiSharp.ImGuiDockNode.__CreateInstance((__IntPtr) ((__Internal*)__Instance)->ChildNodes[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->ChildNodes[i] = (long) value[i].__Instance;
                }
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowPtr Windows
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Windows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Windows = *(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTabBar TabBar
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTabBar.__GetOrCreateInstance(((__Internal*)__Instance)->TabBar, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->TabBar = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Size
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SizeRef
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeRef));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeRef = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiAxis SplitAxis
        {
            get
            {
                return ((__Internal*)__Instance)->SplitAxis;
            }

            set
            {
                ((__Internal*)__Instance)->SplitAxis = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindowClass WindowClass
        {
            get
            {
                return global::DearImguiSharp.ImGuiWindowClass.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowClass));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowClass = *(global::DearImguiSharp.ImGuiWindowClass.__Internal*) value.__Instance;
            }
        }

        public uint LastBgColor
        {
            get
            {
                return ((__Internal*)__Instance)->LastBgColor;
            }

            set
            {
                ((__Internal*)__Instance)->LastBgColor = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindow HostWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->HostWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HostWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow VisibleWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->VisibleWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode CentralNode
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->CentralNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CentralNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode OnlyNodeWithWindows
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->OnlyNodeWithWindows, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->OnlyNodeWithWindows = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int CountNodeWithWindows
        {
            get
            {
                return ((__Internal*)__Instance)->CountNodeWithWindows;
            }

            set
            {
                ((__Internal*)__Instance)->CountNodeWithWindows = value;
            }
        }

        public int LastFrameAlive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameAlive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameAlive = value;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public int LastFrameFocused
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameFocused;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameFocused = value;
            }
        }

        public uint LastFocusedNodeId
        {
            get
            {
                return ((__Internal*)__Instance)->LastFocusedNodeId;
            }

            set
            {
                ((__Internal*)__Instance)->LastFocusedNodeId = value;
            }
        }

        public uint SelectedTabId
        {
            get
            {
                return ((__Internal*)__Instance)->SelectedTabId;
            }

            set
            {
                ((__Internal*)__Instance)->SelectedTabId = value;
            }
        }

        public uint WantCloseTabId
        {
            get
            {
                return ((__Internal*)__Instance)->WantCloseTabId;
            }

            set
            {
                ((__Internal*)__Instance)->WantCloseTabId = value;
            }
        }

        public int AuthorityForPos
        {
            get
            {
                return ((__Internal*)__Instance)->AuthorityForPos;
            }

            set
            {
                ((__Internal*)__Instance)->AuthorityForPos = value;
            }
        }

        public int AuthorityForSize
        {
            get
            {
                return ((__Internal*)__Instance)->AuthorityForSize;
            }

            set
            {
                ((__Internal*)__Instance)->AuthorityForSize = value;
            }
        }

        public int AuthorityForViewport
        {
            get
            {
                return ((__Internal*)__Instance)->AuthorityForViewport;
            }

            set
            {
                ((__Internal*)__Instance)->AuthorityForViewport = value;
            }
        }

        public bool IsVisible
        {
            get
            {
                return ((__Internal*)__Instance)->IsVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsVisible = (byte) (value ? 1 : 0);
            }
        }

        public bool IsFocused
        {
            get
            {
                return ((__Internal*)__Instance)->IsFocused != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsFocused = (byte) (value ? 1 : 0);
            }
        }

        public bool IsBgDrawnThisFrame
        {
            get
            {
                return ((__Internal*)__Instance)->IsBgDrawnThisFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsBgDrawnThisFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool HasCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->HasCloseButton != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HasCloseButton = (byte) (value ? 1 : 0);
            }
        }

        public bool HasWindowMenuButton
        {
            get
            {
                return ((__Internal*)__Instance)->HasWindowMenuButton != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HasWindowMenuButton = (byte) (value ? 1 : 0);
            }
        }

        public bool HasCentralNodeChild
        {
            get
            {
                return ((__Internal*)__Instance)->HasCentralNodeChild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HasCentralNodeChild = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCloseAll
        {
            get
            {
                return ((__Internal*)__Instance)->WantCloseAll != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCloseAll = (byte) (value ? 1 : 0);
            }
        }

        public bool WantLockSizeOnce
        {
            get
            {
                return ((__Internal*)__Instance)->WantLockSizeOnce != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantLockSizeOnce = (byte) (value ? 1 : 0);
            }
        }

        public bool WantMouseMove
        {
            get
            {
                return ((__Internal*)__Instance)->WantMouseMove != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantMouseMove = (byte) (value ? 1 : 0);
            }
        }

        public bool WantHiddenTabBarUpdate
        {
            get
            {
                return ((__Internal*)__Instance)->WantHiddenTabBarUpdate != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantHiddenTabBarUpdate = (byte) (value ? 1 : 0);
            }
        }

        public bool WantHiddenTabBarToggle
        {
            get
            {
                return ((__Internal*)__Instance)->WantHiddenTabBarToggle != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantHiddenTabBarToggle = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiWindowDockStyle : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 24)]
        public partial struct __Internal
        {
            public fixed uint Colors[6];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowDockStyle@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowDockStyle>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowDockStyle>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindowDockStyle managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindowDockStyle>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindowDockStyle managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowDockStyle __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowDockStyle(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowDockStyle __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowDockStyle)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowDockStyle __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowDockStyle(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowDockStyle(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowDockStyle(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowDockStyle()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowDockStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowDockStyle(global::DearImguiSharp.ImGuiWindowDockStyle _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowDockStyle.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindowDockStyle.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindowDockStyle.__Internal*) _0.__Instance);
        }

        ~ImGuiWindowDockStyle()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint[] Colors
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->Colors, 6);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 6; i++)
                        ((__Internal*)__Instance)->Colors[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImVectorImGuiDockRequest : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiDockRequest@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockRequest>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockRequest>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiDockRequest managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockRequest>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiDockRequest managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiDockRequest __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiDockRequest(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiDockRequest __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiDockRequest)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiDockRequest __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiDockRequest(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiDockRequest(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiDockRequest(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiDockRequest()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiDockRequest(global::DearImguiSharp.ImVectorImGuiDockRequest _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiDockRequest()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiDockRequest Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockRequest.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiDockNodeSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiDockNodeSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockNodeSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockNodeSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiDockNodeSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiDockNodeSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiDockNodeSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiDockNodeSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiDockNodeSettings(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiDockNodeSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiDockNodeSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiDockNodeSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiDockNodeSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiDockNodeSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiDockNodeSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiDockNodeSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiDockNodeSettings(global::DearImguiSharp.ImVectorImGuiDockNodeSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiDockNodeSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiDockNodeSettings Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNodeSettings.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiDockContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImGuiStorage.__Internal Nodes;
            public global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal Requests;
            public global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal NodesSettings;
            public byte WantFullRebuild;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiDockContext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockContext>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiDockContext>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiDockContext managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiDockContext>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiDockContext managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiDockContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiDockContext(native.ToPointer(), skipVTables);
        }

        internal static ImGuiDockContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiDockContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiDockContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiDockContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiDockContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiDockContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDockContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiDockContext(global::DearImguiSharp.ImGuiDockContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiDockContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiDockContext.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiDockContext.__Internal*) _0.__Instance);
        }

        ~ImGuiDockContext()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiStorage Nodes
        {
            get
            {
                return global::DearImguiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Nodes));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Nodes = *(global::DearImguiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiDockRequest Requests
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiDockRequest.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Requests));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Requests = *(global::DearImguiSharp.ImVectorImGuiDockRequest.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiDockNodeSettings NodesSettings
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NodesSettings));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NodesSettings = *(global::DearImguiSharp.ImVectorImGuiDockNodeSettings.__Internal*) value.__Instance;
            }
        }

        public bool WantFullRebuild
        {
            get
            {
                return ((__Internal*)__Instance)->WantFullRebuild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantFullRebuild = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiViewportP : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 312)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImGuiViewport.__Internal _ImGuiViewport;
            public int Idx;
            public int LastFrameActive;
            public int LastFrontMostStampCount;
            public uint LastNameHash;
            public global::DearImguiSharp.ImVec2.__Internal LastPos;
            public float Alpha;
            public float LastAlpha;
            public short PlatformMonitor;
            public byte PlatformWindowCreated;
            public __IntPtr Window;
            public fixed int DrawListsLastFrame[2];
            public fixed long DrawLists[2];
            public global::DearImguiSharp.ImDrawData.__Internal DrawDataP;
            public global::DearImguiSharp.ImDrawDataBuilder.__Internal DrawDataBuilder;
            public global::DearImguiSharp.ImVec2.__Internal LastPlatformPos;
            public global::DearImguiSharp.ImVec2.__Internal LastPlatformSize;
            public global::DearImguiSharp.ImVec2.__Internal LastRendererSize;
            public global::DearImguiSharp.ImVec2.__Internal WorkOffsetMin;
            public global::DearImguiSharp.ImVec2.__Internal WorkOffsetMax;
            public global::DearImguiSharp.ImVec2.__Internal BuildWorkOffsetMin;
            public global::DearImguiSharp.ImVec2.__Internal BuildWorkOffsetMax;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiViewportP@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiViewportP>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiViewportP>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiViewportP managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiViewportP>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiViewportP managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiViewportP __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiViewportP(native.ToPointer(), skipVTables);
        }

        internal static ImGuiViewportP __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiViewportP)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiViewportP __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiViewportP(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiViewportP(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewportP(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiViewportP()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewportP.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiViewportP(global::DearImguiSharp.ImGuiViewportP _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiViewportP.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiViewportP.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiViewportP.__Internal*) _0.__Instance);
        }

        ~ImGuiViewportP()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiViewport ImGuiViewport
        {
            get
            {
                return global::DearImguiSharp.ImGuiViewport.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->_ImGuiViewport));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->_ImGuiViewport = *(global::DearImguiSharp.ImGuiViewport.__Internal*) value.__Instance;
            }
        }

        public int Idx
        {
            get
            {
                return ((__Internal*)__Instance)->Idx;
            }

            set
            {
                ((__Internal*)__Instance)->Idx = value;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public int LastFrontMostStampCount
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrontMostStampCount;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrontMostStampCount = value;
            }
        }

        public uint LastNameHash
        {
            get
            {
                return ((__Internal*)__Instance)->LastNameHash;
            }

            set
            {
                ((__Internal*)__Instance)->LastNameHash = value;
            }
        }

        public global::DearImguiSharp.ImVec2 LastPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float Alpha
        {
            get
            {
                return ((__Internal*)__Instance)->Alpha;
            }

            set
            {
                ((__Internal*)__Instance)->Alpha = value;
            }
        }

        public float LastAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->LastAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->LastAlpha = value;
            }
        }

        public short PlatformMonitor
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformMonitor;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformMonitor = value;
            }
        }

        public bool PlatformWindowCreated
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformWindowCreated != 0;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformWindowCreated = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int[] DrawListsLastFrame
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<int>(((__Internal*)__Instance)->DrawListsLastFrame, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->DrawListsLastFrame[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImDrawList[] DrawLists
        {
            get
            {
                global::DearImguiSharp.ImDrawList[] __value = null;
                if (((__Internal*)__Instance)->DrawLists != null)
                {
                    __value = new global::DearImguiSharp.ImDrawList[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::DearImguiSharp.ImDrawList.__CreateInstance((__IntPtr) ((__Internal*)__Instance)->DrawLists[i]);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->DrawLists[i] = (long) value[i].__Instance;
                }
            }
        }

        public global::DearImguiSharp.ImDrawData DrawDataP
        {
            get
            {
                return global::DearImguiSharp.ImDrawData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawDataP));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawDataP = *(global::DearImguiSharp.ImDrawData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawDataBuilder DrawDataBuilder
        {
            get
            {
                return global::DearImguiSharp.ImDrawDataBuilder.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawDataBuilder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawDataBuilder = *(global::DearImguiSharp.ImDrawDataBuilder.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 LastPlatformPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastPlatformPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastPlatformPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 LastPlatformSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastPlatformSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastPlatformSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 LastRendererSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastRendererSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastRendererSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkOffsetMin
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkOffsetMin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkOffsetMin = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WorkOffsetMax
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkOffsetMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkOffsetMax = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BuildWorkOffsetMin
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BuildWorkOffsetMin));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BuildWorkOffsetMin = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BuildWorkOffsetMax
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BuildWorkOffsetMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BuildWorkOffsetMax = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public uint ID;
            public global::DearImguiSharp.ImVec2ih.__Internal Pos;
            public global::DearImguiSharp.ImVec2ih.__Internal Size;
            public global::DearImguiSharp.ImVec2ih.__Internal ViewportPos;
            public uint ViewportId;
            public uint DockId;
            public uint ClassId;
            public short DockOrder;
            public byte Collapsed;
            public byte WantApply;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindowSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindowSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindowSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowSettings(global::DearImguiSharp.ImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindowSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        ~ImGuiWindowSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public global::DearImguiSharp.ImVec2ih Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2ih Size
        {
            get
            {
                return global::DearImguiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::DearImguiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2ih ViewportPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ViewportPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ViewportPos = *(global::DearImguiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public uint ViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportId = value;
            }
        }

        public uint DockId
        {
            get
            {
                return ((__Internal*)__Instance)->DockId;
            }

            set
            {
                ((__Internal*)__Instance)->DockId = value;
            }
        }

        public uint ClassId
        {
            get
            {
                return ((__Internal*)__Instance)->ClassId;
            }

            set
            {
                ((__Internal*)__Instance)->ClassId = value;
            }
        }

        public short DockOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DockOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DockOrder = value;
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((__Internal*)__Instance)->Collapsed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }

        public bool WantApply
        {
            get
            {
                return ((__Internal*)__Instance)->WantApply != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantApply = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            public __IntPtr TypeName;
            public uint TypeHash;
            public __IntPtr ClearAllFn;
            public __IntPtr ReadInitFn;
            public __IntPtr ReadOpenFn;
            public __IntPtr ReadLineFn;
            public __IntPtr ApplyAllFn;
            public __IntPtr WriteAllFn;
            public __IntPtr UserData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiSettingsHandler@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiSettingsHandler>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiSettingsHandler>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiSettingsHandler managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiSettingsHandler>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiSettingsHandler managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool __TypeName_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiSettingsHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static ImGuiSettingsHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiSettingsHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiSettingsHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiSettingsHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiSettingsHandler(global::DearImguiSharp.ImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiSettingsHandler.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiSettingsHandler.__Internal*) _0.__Instance);
            if (_0.__TypeName_OwnsNativeMemory)
                this.TypeName = _0.TypeName;
        }

        ~ImGuiSettingsHandler()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__TypeName_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->TypeName);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public string TypeName
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->TypeName);
            }

            set
            {
                if (__TypeName_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->TypeName);
                __TypeName_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->TypeName = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->TypeName = (__IntPtr) __bytePtr0;
            }
        }

        public uint TypeHash
        {
            get
            {
                return ((__Internal*)__Instance)->TypeHash;
            }

            set
            {
                ((__Internal*)__Instance)->TypeHash = value;
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr ClearAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ClearAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ClearAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr ReadInitFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadInitFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ReadInitFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8 ReadOpenFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadOpenFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func___IntPtr___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->ReadOpenFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8 ReadLineFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ReadLineFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr_string8));
            }

            set
            {
                ((__Internal*)__Instance)->ReadLineFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr ApplyAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->ApplyAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->ApplyAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr WriteAllFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->WriteAllFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action___IntPtr___IntPtr___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->WriteAllFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImGuiMetricsConfig : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public byte ShowDebugLog;
            public byte ShowStackTool;
            public byte ShowWindowsRects;
            public byte ShowWindowsBeginOrder;
            public byte ShowTablesRects;
            public byte ShowDrawCmdMesh;
            public byte ShowDrawCmdBoundingBoxes;
            public byte ShowDockingNodes;
            public int ShowWindowsRectsType;
            public int ShowTablesRectsType;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiMetricsConfig@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiMetricsConfig>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiMetricsConfig>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiMetricsConfig managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiMetricsConfig>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiMetricsConfig managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiMetricsConfig __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiMetricsConfig(native.ToPointer(), skipVTables);
        }

        internal static ImGuiMetricsConfig __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiMetricsConfig)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiMetricsConfig __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiMetricsConfig(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiMetricsConfig(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMetricsConfig(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiMetricsConfig()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiMetricsConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiMetricsConfig(global::DearImguiSharp.ImGuiMetricsConfig _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiMetricsConfig.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiMetricsConfig.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiMetricsConfig.__Internal*) _0.__Instance);
        }

        ~ImGuiMetricsConfig()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool ShowDebugLog
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDebugLog != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDebugLog = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowStackTool
        {
            get
            {
                return ((__Internal*)__Instance)->ShowStackTool != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowStackTool = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowWindowsRects
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsRects != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsRects = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowWindowsBeginOrder
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsBeginOrder != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsBeginOrder = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowTablesRects
        {
            get
            {
                return ((__Internal*)__Instance)->ShowTablesRects != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowTablesRects = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowDrawCmdMesh
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDrawCmdMesh != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDrawCmdMesh = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowDrawCmdBoundingBoxes
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDrawCmdBoundingBoxes != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDrawCmdBoundingBoxes = (byte) (value ? 1 : 0);
            }
        }

        public bool ShowDockingNodes
        {
            get
            {
                return ((__Internal*)__Instance)->ShowDockingNodes != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ShowDockingNodes = (byte) (value ? 1 : 0);
            }
        }

        public int ShowWindowsRectsType
        {
            get
            {
                return ((__Internal*)__Instance)->ShowWindowsRectsType;
            }

            set
            {
                ((__Internal*)__Instance)->ShowWindowsRectsType = value;
            }
        }

        public int ShowTablesRectsType
        {
            get
            {
                return ((__Internal*)__Instance)->ShowTablesRectsType;
            }

            set
            {
                ((__Internal*)__Instance)->ShowTablesRectsType = value;
            }
        }
    }

    public unsafe partial class ImGuiStackLevelInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 72)]
        public partial struct __Internal
        {
            public uint ID;
            public sbyte QueryFrameCount;
            public byte QuerySuccess;
            public int DataType;
            public fixed sbyte Desc[57];

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackLevelInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackLevelInfo>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackLevelInfo>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStackLevelInfo managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStackLevelInfo>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStackLevelInfo managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackLevelInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackLevelInfo(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackLevelInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackLevelInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackLevelInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackLevelInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackLevelInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackLevelInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackLevelInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackLevelInfo(global::DearImguiSharp.ImGuiStackLevelInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStackLevelInfo.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStackLevelInfo.__Internal*) _0.__Instance);
        }

        ~ImGuiStackLevelInfo()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public sbyte QueryFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->QueryFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->QueryFrameCount = value;
            }
        }

        public bool QuerySuccess
        {
            get
            {
                return ((__Internal*)__Instance)->QuerySuccess != 0;
            }

            set
            {
                ((__Internal*)__Instance)->QuerySuccess = (byte) (value ? 1 : 0);
            }
        }

        public int DataType
        {
            get
            {
                return ((__Internal*)__Instance)->DataType;
            }

            set
            {
                ((__Internal*)__Instance)->DataType = value;
            }
        }

        public sbyte[] Desc
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<sbyte>(((__Internal*)__Instance)->Desc, 57);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 57; i++)
                        ((__Internal*)__Instance)->Desc[i] = value[i];
                }
            }
        }
    }

    public unsafe partial class ImVectorImGuiStackLevelInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStackLevelInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStackLevelInfo>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStackLevelInfo>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiStackLevelInfo managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStackLevelInfo>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiStackLevelInfo managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStackLevelInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStackLevelInfo(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStackLevelInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStackLevelInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStackLevelInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStackLevelInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStackLevelInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStackLevelInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStackLevelInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStackLevelInfo(global::DearImguiSharp.ImVectorImGuiStackLevelInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiStackLevelInfo()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiStackLevelInfo Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiStackLevelInfo.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiStackTool : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public int LastActiveFrame;
            public int StackLevel;
            public uint QueryId;
            public global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal Results;
            public byte CopyToClipboardOnCtrlC;
            public float CopyToClipboardLastTime;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiStackTool@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackTool>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiStackTool>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiStackTool managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiStackTool>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiStackTool managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiStackTool __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiStackTool(native.ToPointer(), skipVTables);
        }

        internal static ImGuiStackTool __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiStackTool)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiStackTool __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiStackTool(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiStackTool(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackTool(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiStackTool()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackTool.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiStackTool(global::DearImguiSharp.ImGuiStackTool _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiStackTool.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiStackTool.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiStackTool.__Internal*) _0.__Instance);
        }

        ~ImGuiStackTool()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int LastActiveFrame
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveFrame;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveFrame = value;
            }
        }

        public int StackLevel
        {
            get
            {
                return ((__Internal*)__Instance)->StackLevel;
            }

            set
            {
                ((__Internal*)__Instance)->StackLevel = value;
            }
        }

        public uint QueryId
        {
            get
            {
                return ((__Internal*)__Instance)->QueryId;
            }

            set
            {
                ((__Internal*)__Instance)->QueryId = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiStackLevelInfo Results
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Results));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Results = *(global::DearImguiSharp.ImVectorImGuiStackLevelInfo.__Internal*) value.__Instance;
            }
        }

        public bool CopyToClipboardOnCtrlC
        {
            get
            {
                return ((__Internal*)__Instance)->CopyToClipboardOnCtrlC != 0;
            }

            set
            {
                ((__Internal*)__Instance)->CopyToClipboardOnCtrlC = (byte) (value ? 1 : 0);
            }
        }

        public float CopyToClipboardLastTime
        {
            get
            {
                return ((__Internal*)__Instance)->CopyToClipboardLastTime;
            }

            set
            {
                ((__Internal*)__Instance)->CopyToClipboardLastTime = value;
            }
        }
    }

    public unsafe partial class ImGuiContextHook : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 32)]
        public partial struct __Internal
        {
            public uint HookId;
            public global::DearImguiSharp.ImGuiContextHookType Type;
            public uint Owner;
            public __IntPtr Callback;
            public __IntPtr UserData;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiContextHook@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiContextHook>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiContextHook>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiContextHook managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiContextHook>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiContextHook managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiContextHook __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContextHook(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContextHook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiContextHook)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiContextHook __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContextHook(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContextHook(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContextHook(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiContextHook()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContextHook(global::DearImguiSharp.ImGuiContextHook _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiContextHook.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiContextHook.__Internal*) _0.__Instance);
        }

        ~ImGuiContextHook()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint HookId
        {
            get
            {
                return ((__Internal*)__Instance)->HookId;
            }

            set
            {
                ((__Internal*)__Instance)->HookId = value;
            }
        }

        public global::DearImguiSharp.ImGuiContextHookType Type
        {
            get
            {
                return ((__Internal*)__Instance)->Type;
            }

            set
            {
                ((__Internal*)__Instance)->Type = value;
            }
        }

        public uint Owner
        {
            get
            {
                return ((__Internal*)__Instance)->Owner;
            }

            set
            {
                ((__Internal*)__Instance)->Owner = value;
            }
        }

        public global::DearImguiSharp.ImGuiContextHookCallback Callback
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->Callback;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.ImGuiContextHookCallback) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.ImGuiContextHookCallback));
            }

            set
            {
                ((__Internal*)__Instance)->Callback = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }

        public __IntPtr UserData
        {
            get
            {
                return ((__Internal*)__Instance)->UserData;
            }

            set
            {
                ((__Internal*)__Instance)->UserData = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiInputEvent : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiInputEvent@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiInputEvent>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiInputEvent>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiInputEvent managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiInputEvent>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiInputEvent managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiInputEvent __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiInputEvent(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiInputEvent __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiInputEvent)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiInputEvent __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiInputEvent(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiInputEvent(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiInputEvent(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiInputEvent()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiInputEvent(global::DearImguiSharp.ImVectorImGuiInputEvent _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiInputEvent()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiInputEvent Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiInputEvent.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiWindowStackData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiWindowStackData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowStackData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowStackData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiWindowStackData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiWindowStackData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiWindowStackData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiWindowStackData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowStackData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiWindowStackData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiWindowStackData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiWindowStackData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiWindowStackData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiWindowStackData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowStackData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiWindowStackData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiWindowStackData(global::DearImguiSharp.ImVectorImGuiWindowStackData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiWindowStackData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindowStackData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindowStackData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiColorMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiColorMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiColorMod>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiColorMod>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiColorMod managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiColorMod>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiColorMod managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiColorMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiColorMod(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiColorMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiColorMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiColorMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiColorMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiColorMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiColorMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiColorMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiColorMod(global::DearImguiSharp.ImVectorImGuiColorMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiColorMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiColorMod.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiColorMod.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiColorMod()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiColorMod Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiColorMod.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiStyleMod : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiStyleMod@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStyleMod>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStyleMod>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiStyleMod managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiStyleMod>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiStyleMod managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiStyleMod __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiStyleMod(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiStyleMod __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiStyleMod)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiStyleMod __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiStyleMod(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiStyleMod(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStyleMod(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiStyleMod()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiStyleMod(global::DearImguiSharp.ImVectorImGuiStyleMod _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiStyleMod()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiStyleMod Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiStyleMod.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiID : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiID@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiID>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiID>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiID managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiID>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiID managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiID __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiID(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiID __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiID)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiID __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiID(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiID(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiID(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiID()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiID(global::DearImguiSharp.ImVectorImGuiID _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiID.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiID.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiID.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiID()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public uint* Data
        {
            get
            {
                return (uint*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiItemFlags : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiItemFlags@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiItemFlags>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiItemFlags>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiItemFlags managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiItemFlags>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiItemFlags managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiItemFlags __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiItemFlags(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiItemFlags __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiItemFlags)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiItemFlags __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiItemFlags(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiItemFlags(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiItemFlags(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiItemFlags()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiItemFlags(global::DearImguiSharp.ImVectorImGuiItemFlags _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiItemFlags()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public int* Data
        {
            get
            {
                return (int*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiGroupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiGroupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiGroupData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiGroupData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiGroupData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiGroupData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiGroupData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiGroupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiGroupData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiGroupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiGroupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiGroupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiGroupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiGroupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiGroupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiGroupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiGroupData(global::DearImguiSharp.ImVectorImGuiGroupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiGroupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiGroupData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiGroupData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiGroupData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiGroupData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiGroupData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPopupData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiPopupData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPopupData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPopupData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiPopupData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPopupData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiPopupData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiPopupData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiPopupData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiPopupData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiPopupData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiPopupData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiPopupData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPopupData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPopupData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiPopupData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPopupData(global::DearImguiSharp.ImVectorImGuiPopupData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPopupData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiPopupData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiPopupData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiPopupData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiPopupData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiPopupData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiViewportPPtr : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiViewportPPtr@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPPtr>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPPtr>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiViewportPPtr managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiViewportPPtr>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiViewportPPtr managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiViewportPPtr __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPPtr(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiViewportPPtr __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiViewportPPtr)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiViewportPPtr __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiViewportPPtr(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiViewportPPtr(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPPtr(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiViewportPPtr()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiViewportPPtr(global::DearImguiSharp.ImVectorImGuiViewportPPtr _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiViewportPPtr()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiViewportP Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                var __value = value is null ? __IntPtr.Zero : value.__Instance;
                ((__Internal*)__Instance)->Data = new __IntPtr(&__value);
            }
        }
    }

    public unsafe partial class ImVector_unsigned_char : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_unsigned_char@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_unsigned_char>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVector_unsigned_char>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVector_unsigned_char managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVector_unsigned_char>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVector_unsigned_char managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVector_unsigned_char __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVector_unsigned_char(native.ToPointer(), skipVTables);
        }

        internal static ImVector_unsigned_char __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVector_unsigned_char)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVector_unsigned_char __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVector_unsigned_char(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVector_unsigned_char(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_unsigned_char(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVector_unsigned_char()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVector_unsigned_char(global::DearImguiSharp.ImVector_unsigned_char _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVector_unsigned_char.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVector_unsigned_char.__Internal*) __Instance) = *((global::DearImguiSharp.ImVector_unsigned_char.__Internal*) _0.__Instance);
        }

        ~ImVector_unsigned_char()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiListClipperData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiListClipperData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiListClipperData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiListClipperData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiListClipperData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiListClipperData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiListClipperData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiListClipperData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiListClipperData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiListClipperData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiListClipperData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiListClipperData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiListClipperData(global::DearImguiSharp.ImVectorImGuiListClipperData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiListClipperData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiListClipperData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiListClipperData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTableTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTableTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableTempData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableTempData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTableTempData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableTempData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTableTempData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTableTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableTempData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTableTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTableTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTableTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTableTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTableTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableTempData(global::DearImguiSharp.ImVectorImGuiTableTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTableTempData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTableTempData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableTempData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTable>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTable>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTable managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTable>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTable managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTable(global::DearImguiSharp.ImVectorImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTable.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTable.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTable()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTable Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTable.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImPoolImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImGuiTable.__Internal Buf;
            public global::DearImguiSharp.ImGuiStorage.__Internal Map;
            public int FreeIdx;
            public int AliveCount;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImPool_ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTable>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTable>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImPoolImGuiTable managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTable>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImPoolImGuiTable managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImPoolImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImPoolImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImPoolImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPoolImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPoolImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPoolImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImPoolImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImPoolImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImPoolImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTable(global::DearImguiSharp.ImPoolImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImPoolImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImPoolImGuiTable.__Internal*) __Instance) = *((global::DearImguiSharp.ImPoolImGuiTable.__Internal*) _0.__Instance);
        }

        ~ImPoolImGuiTable()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImGuiTable Buf
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTable.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVectorImGuiTable.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStorage Map
        {
            get
            {
                return global::DearImguiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Map));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Map = *(global::DearImguiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int FreeIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FreeIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FreeIdx = value;
            }
        }

        public int AliveCount
        {
            get
            {
                return ((__Internal*)__Instance)->AliveCount;
            }

            set
            {
                ((__Internal*)__Instance)->AliveCount = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabBar>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabBar>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTabBar managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabBar>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTabBar managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabBar(global::DearImguiSharp.ImVectorImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTabBar.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTabBar.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTabBar()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTabBar Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTabBar.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImPoolImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 40)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImGuiTabBar.__Internal Buf;
            public global::DearImguiSharp.ImGuiStorage.__Internal Map;
            public int FreeIdx;
            public int AliveCount;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImPool_ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTabBar>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTabBar>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImPoolImGuiTabBar managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImPoolImGuiTabBar>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImPoolImGuiTabBar managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImPoolImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImPoolImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImPoolImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImPoolImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImPoolImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImPoolImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImPoolImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImPoolImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImPoolImGuiTabBar(global::DearImguiSharp.ImPoolImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImPoolImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImPoolImGuiTabBar.__Internal*) __Instance) = *((global::DearImguiSharp.ImPoolImGuiTabBar.__Internal*) _0.__Instance);
        }

        ~ImPoolImGuiTabBar()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImGuiTabBar Buf
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTabBar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVectorImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStorage Map
        {
            get
            {
                return global::DearImguiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Map));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Map = *(global::DearImguiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int FreeIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FreeIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FreeIdx = value;
            }
        }

        public int AliveCount
        {
            get
            {
                return ((__Internal*)__Instance)->AliveCount;
            }

            set
            {
                ((__Internal*)__Instance)->AliveCount = value;
            }
        }
    }

    public unsafe partial class ImVectorImGuiPtrOrIndex : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiPtrOrIndex@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPtrOrIndex>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPtrOrIndex>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiPtrOrIndex managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiPtrOrIndex>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiPtrOrIndex managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiPtrOrIndex __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiPtrOrIndex(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiPtrOrIndex __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiPtrOrIndex)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiPtrOrIndex __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiPtrOrIndex(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiPtrOrIndex(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPtrOrIndex(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiPtrOrIndex()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiPtrOrIndex(global::DearImguiSharp.ImVectorImGuiPtrOrIndex _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiPtrOrIndex()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiPtrOrIndex Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiShrinkWidthItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiShrinkWidthItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiShrinkWidthItem>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiShrinkWidthItem>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiShrinkWidthItem managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiShrinkWidthItem>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiShrinkWidthItem managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiShrinkWidthItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiShrinkWidthItem(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiShrinkWidthItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiShrinkWidthItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiShrinkWidthItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiShrinkWidthItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiShrinkWidthItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiShrinkWidthItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiShrinkWidthItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiShrinkWidthItem(global::DearImguiSharp.ImVectorImGuiShrinkWidthItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiShrinkWidthItem()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiShrinkWidthItem Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiShrinkWidthItem.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiSettingsHandler : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiSettingsHandler@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiSettingsHandler>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiSettingsHandler>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiSettingsHandler managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiSettingsHandler>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiSettingsHandler managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiSettingsHandler __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiSettingsHandler(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiSettingsHandler __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiSettingsHandler)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiSettingsHandler __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiSettingsHandler(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiSettingsHandler(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiSettingsHandler(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiSettingsHandler()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiSettingsHandler(global::DearImguiSharp.ImVectorImGuiSettingsHandler _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiSettingsHandler()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiSettingsHandler Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImChunkStreamImGuiWindowSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImChunkStream_ImGuiWindowSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiWindowSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiWindowSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImChunkStreamImGuiWindowSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiWindowSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImChunkStreamImGuiWindowSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImChunkStreamImGuiWindowSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiWindowSettings(native.ToPointer(), skipVTables);
        }

        internal static ImChunkStreamImGuiWindowSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImChunkStreamImGuiWindowSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImChunkStreamImGuiWindowSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiWindowSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImChunkStreamImGuiWindowSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiWindowSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImChunkStreamImGuiWindowSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiWindowSettings(global::DearImguiSharp.ImChunkStreamImGuiWindowSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) _0.__Instance);
        }

        ~ImChunkStreamImGuiWindowSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVector_char Buf
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImChunkStreamImGuiTableSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVector_char.__Internal Buf;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImChunkStream_ImGuiTableSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiTableSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiTableSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImChunkStreamImGuiTableSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImChunkStreamImGuiTableSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImChunkStreamImGuiTableSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImChunkStreamImGuiTableSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiTableSettings(native.ToPointer(), skipVTables);
        }

        internal static ImChunkStreamImGuiTableSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImChunkStreamImGuiTableSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImChunkStreamImGuiTableSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImChunkStreamImGuiTableSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImChunkStreamImGuiTableSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiTableSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImChunkStreamImGuiTableSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImChunkStreamImGuiTableSettings(global::DearImguiSharp.ImChunkStreamImGuiTableSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal*) _0.__Instance);
        }

        ~ImChunkStreamImGuiTableSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVector_char Buf
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Buf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Buf = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiContextHook : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiContextHook@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiContextHook>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiContextHook>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiContextHook managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiContextHook>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiContextHook managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiContextHook __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiContextHook(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiContextHook __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiContextHook)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiContextHook __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiContextHook(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiContextHook(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiContextHook(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiContextHook()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiContextHook(global::DearImguiSharp.ImVectorImGuiContextHook _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiContextHook.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiContextHook.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiContextHook.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiContextHook()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiContextHook Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiContextHook.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiContext : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 22632)]
        public partial struct __Internal
        {
            public byte Initialized;
            public byte FontAtlasOwnedByContext;
            public global::DearImguiSharp.ImGuiIO.__Internal IO;
            public global::DearImguiSharp.ImGuiPlatformIO.__Internal PlatformIO;
            public global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal InputEventsQueue;
            public global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal InputEventsTrail;
            public global::DearImguiSharp.ImGuiStyle.__Internal Style;
            public int ConfigFlagsCurrFrame;
            public int ConfigFlagsLastFrame;
            public __IntPtr Font;
            public float FontSize;
            public float FontBaseSize;
            public global::DearImguiSharp.ImDrawListSharedData.__Internal DrawListSharedData;
            public double Time;
            public int FrameCount;
            public int FrameCountEnded;
            public int FrameCountPlatformEnded;
            public int FrameCountRendered;
            public byte WithinFrameScope;
            public byte WithinFrameScopeWithImplicitWindow;
            public byte WithinEndChild;
            public byte GcCompactAll;
            public byte TestEngineHookItems;
            public __IntPtr TestEngine;
            public global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal Windows;
            public global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal WindowsFocusOrder;
            public global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal WindowsTempSortBuffer;
            public global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal CurrentWindowStack;
            public global::DearImguiSharp.ImGuiStorage.__Internal WindowsById;
            public int WindowsActiveCount;
            public global::DearImguiSharp.ImVec2.__Internal WindowsHoverPadding;
            public __IntPtr CurrentWindow;
            public __IntPtr HoveredWindow;
            public __IntPtr HoveredWindowUnderMovingWindow;
            public __IntPtr HoveredDockNode;
            public __IntPtr MovingWindow;
            public __IntPtr WheelingWindow;
            public global::DearImguiSharp.ImVec2.__Internal WheelingWindowRefMousePos;
            public float WheelingWindowTimer;
            public uint DebugHookIdInfo;
            public uint HoveredId;
            public uint HoveredIdPreviousFrame;
            public byte HoveredIdAllowOverlap;
            public byte HoveredIdUsingMouseWheel;
            public byte HoveredIdPreviousFrameUsingMouseWheel;
            public byte HoveredIdDisabled;
            public float HoveredIdTimer;
            public float HoveredIdNotActiveTimer;
            public uint ActiveId;
            public uint ActiveIdIsAlive;
            public float ActiveIdTimer;
            public byte ActiveIdIsJustActivated;
            public byte ActiveIdAllowOverlap;
            public byte ActiveIdNoClearOnFocusLoss;
            public byte ActiveIdHasBeenPressedBefore;
            public byte ActiveIdHasBeenEditedBefore;
            public byte ActiveIdHasBeenEditedThisFrame;
            public global::DearImguiSharp.ImVec2.__Internal ActiveIdClickOffset;
            public __IntPtr ActiveIdWindow;
            public global::DearImguiSharp.ImGuiInputSource ActiveIdSource;
            public int ActiveIdMouseButton;
            public uint ActiveIdPreviousFrame;
            public byte ActiveIdPreviousFrameIsAlive;
            public byte ActiveIdPreviousFrameHasBeenEditedBefore;
            public __IntPtr ActiveIdPreviousFrameWindow;
            public uint LastActiveId;
            public float LastActiveIdTimer;
            public byte ActiveIdUsingMouseWheel;
            public uint ActiveIdUsingNavDirMask;
            public uint ActiveIdUsingNavInputMask;
            public global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal ActiveIdUsingKeyInputMask;
            public int CurrentItemFlags;
            public global::DearImguiSharp.ImGuiNextItemData.__Internal NextItemData;
            public global::DearImguiSharp.ImGuiLastItemData.__Internal LastItemData;
            public global::DearImguiSharp.ImGuiNextWindowData.__Internal NextWindowData;
            public global::DearImguiSharp.ImVectorImGuiColorMod.__Internal ColorStack;
            public global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal StyleVarStack;
            public global::DearImguiSharp.ImVectorImFontPtr.__Internal FontStack;
            public global::DearImguiSharp.ImVectorImGuiID.__Internal FocusScopeStack;
            public global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal ItemFlagsStack;
            public global::DearImguiSharp.ImVectorImGuiGroupData.__Internal GroupStack;
            public global::DearImguiSharp.ImVectorImGuiPopupData.__Internal OpenPopupStack;
            public global::DearImguiSharp.ImVectorImGuiPopupData.__Internal BeginPopupStack;
            public int BeginMenuCount;
            public global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal Viewports;
            public float CurrentDpiScale;
            public __IntPtr CurrentViewport;
            public __IntPtr MouseViewport;
            public __IntPtr MouseLastHoveredViewport;
            public uint PlatformLastFocusedViewportId;
            public global::DearImguiSharp.ImGuiPlatformMonitor.__Internal FallbackMonitor;
            public int ViewportFrontMostStampCount;
            public __IntPtr NavWindow;
            public uint NavId;
            public uint NavFocusScopeId;
            public uint NavActivateId;
            public uint NavActivateDownId;
            public uint NavActivatePressedId;
            public uint NavActivateInputId;
            public int NavActivateFlags;
            public uint NavJustMovedToId;
            public uint NavJustMovedToFocusScopeId;
            public int NavJustMovedToKeyMods;
            public uint NavNextActivateId;
            public int NavNextActivateFlags;
            public global::DearImguiSharp.ImGuiInputSource NavInputSource;
            public global::DearImguiSharp.ImGuiNavLayer NavLayer;
            public byte NavIdIsAlive;
            public byte NavMousePosDirty;
            public byte NavDisableHighlight;
            public byte NavDisableMouseHover;
            public byte NavAnyRequest;
            public byte NavInitRequest;
            public byte NavInitRequestFromMove;
            public uint NavInitResultId;
            public global::DearImguiSharp.ImRect.__Internal NavInitResultRectRel;
            public byte NavMoveSubmitted;
            public byte NavMoveScoringItems;
            public byte NavMoveForwardToNextFrame;
            public int NavMoveFlags;
            public int NavMoveScrollFlags;
            public int NavMoveKeyMods;
            public int NavMoveDir;
            public int NavMoveDirForDebug;
            public int NavMoveClipDir;
            public global::DearImguiSharp.ImRect.__Internal NavScoringRect;
            public global::DearImguiSharp.ImRect.__Internal NavScoringNoClipRect;
            public int NavScoringDebugCount;
            public int NavTabbingDir;
            public int NavTabbingCounter;
            public global::DearImguiSharp.ImGuiNavItemData.__Internal NavMoveResultLocal;
            public global::DearImguiSharp.ImGuiNavItemData.__Internal NavMoveResultLocalVisible;
            public global::DearImguiSharp.ImGuiNavItemData.__Internal NavMoveResultOther;
            public global::DearImguiSharp.ImGuiNavItemData.__Internal NavTabbingResultFirst;
            public __IntPtr NavWindowingTarget;
            public __IntPtr NavWindowingTargetAnim;
            public __IntPtr NavWindowingListWindow;
            public float NavWindowingTimer;
            public float NavWindowingHighlightAlpha;
            public byte NavWindowingToggleLayer;
            public float DimBgRatio;
            public int MouseCursor;
            public byte DragDropActive;
            public byte DragDropWithinSource;
            public byte DragDropWithinTarget;
            public int DragDropSourceFlags;
            public int DragDropSourceFrameCount;
            public int DragDropMouseButton;
            public global::DearImguiSharp.ImGuiPayload.__Internal DragDropPayload;
            public global::DearImguiSharp.ImRect.__Internal DragDropTargetRect;
            public uint DragDropTargetId;
            public int DragDropAcceptFlags;
            public float DragDropAcceptIdCurrRectSurface;
            public uint DragDropAcceptIdCurr;
            public uint DragDropAcceptIdPrev;
            public int DragDropAcceptFrameCount;
            public uint DragDropHoldJustPressedId;
            public global::DearImguiSharp.ImVector_unsigned_char.__Internal DragDropPayloadBufHeap;
            public fixed byte DragDropPayloadBufLocal[16];
            public int ClipperTempDataStacked;
            public global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal ClipperTempData;
            public __IntPtr CurrentTable;
            public int TablesTempDataStacked;
            public global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal TablesTempData;
            public global::DearImguiSharp.ImPoolImGuiTable.__Internal Tables;
            public global::DearImguiSharp.ImVector_float.__Internal TablesLastTimeActive;
            public global::DearImguiSharp.ImVectorImDrawChannel.__Internal DrawChannelsTempMergeBuffer;
            public __IntPtr CurrentTabBar;
            public global::DearImguiSharp.ImPoolImGuiTabBar.__Internal TabBars;
            public global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal CurrentTabBarStack;
            public global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal ShrinkWidthBuffer;
            public global::DearImguiSharp.ImVec2.__Internal MouseLastValidPos;
            public global::DearImguiSharp.ImGuiInputTextState.__Internal InputTextState;
            public global::DearImguiSharp.ImFont.__Internal InputTextPasswordFont;
            public uint TempInputId;
            public int ColorEditOptions;
            public float ColorEditLastHue;
            public float ColorEditLastSat;
            public uint ColorEditLastColor;
            public global::DearImguiSharp.ImVec4.__Internal ColorPickerRef;
            public global::DearImguiSharp.ImGuiComboPreviewData.__Internal ComboPreviewData;
            public float SliderGrabClickOffset;
            public float SliderCurrentAccum;
            public byte SliderCurrentAccumDirty;
            public byte DragCurrentAccumDirty;
            public float DragCurrentAccum;
            public float DragSpeedDefaultRatio;
            public float ScrollbarClickDeltaToGrabCenter;
            public float DisabledAlphaBackup;
            public short DisabledStackSize;
            public short TooltipOverrideCount;
            public float TooltipSlowDelay;
            public global::DearImguiSharp.ImVector_char.__Internal ClipboardHandlerData;
            public global::DearImguiSharp.ImVectorImGuiID.__Internal MenusIdSubmittedThisFrame;
            public global::DearImguiSharp.ImGuiPlatformImeData.__Internal PlatformImeData;
            public global::DearImguiSharp.ImGuiPlatformImeData.__Internal PlatformImeDataPrev;
            public uint PlatformImeViewport;
            public sbyte PlatformLocaleDecimalPoint;
            public global::DearImguiSharp.ImGuiDockContext.__Internal DockContext;
            public byte SettingsLoaded;
            public float SettingsDirtyTimer;
            public global::DearImguiSharp.ImGuiTextBuffer.__Internal SettingsIniData;
            public global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal SettingsHandlers;
            public global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal SettingsWindows;
            public global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal SettingsTables;
            public global::DearImguiSharp.ImVectorImGuiContextHook.__Internal Hooks;
            public uint HookIdNext;
            public byte LogEnabled;
            public global::DearImguiSharp.ImGuiLogType LogType;
            public __IntPtr LogFile;
            public global::DearImguiSharp.ImGuiTextBuffer.__Internal LogBuffer;
            public __IntPtr LogNextPrefix;
            public __IntPtr LogNextSuffix;
            public float LogLinePosY;
            public byte LogLineFirstItem;
            public int LogDepthRef;
            public int LogDepthToExpand;
            public int LogDepthToExpandDefault;
            public int DebugLogFlags;
            public global::DearImguiSharp.ImGuiTextBuffer.__Internal DebugLogBuf;
            public byte DebugItemPickerActive;
            public uint DebugItemPickerBreakId;
            public global::DearImguiSharp.ImGuiMetricsConfig.__Internal DebugMetricsConfig;
            public global::DearImguiSharp.ImGuiStackTool.__Internal DebugStackTool;
            public fixed float FramerateSecPerFrame[120];
            public int FramerateSecPerFrameIdx;
            public int FramerateSecPerFrameCount;
            public float FramerateSecPerFrameAccum;
            public int WantCaptureMouseNextFrame;
            public int WantCaptureKeyboardNextFrame;
            public int WantTextInputNextFrame;
            public global::DearImguiSharp.ImVector_char.__Internal TempBuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiContext@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiContext>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiContext>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiContext managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiContext>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiContext managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        private bool __LogNextPrefix_OwnsNativeMemory = false;
        private bool __LogNextSuffix_OwnsNativeMemory = false;
        protected bool __ownsNativeInstance;

        internal static ImGuiContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiContext(native.ToPointer(), skipVTables);
        }

        internal static ImGuiContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiContext()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiContext(global::DearImguiSharp.ImGuiContext _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiContext.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiContext.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiContext.__Internal*) _0.__Instance);
            if (_0.__LogNextPrefix_OwnsNativeMemory)
                this.LogNextPrefix = _0.LogNextPrefix;
            if (_0.__LogNextSuffix_OwnsNativeMemory)
                this.LogNextSuffix = _0.LogNextSuffix;
        }

        ~ImGuiContext()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__LogNextPrefix_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextPrefix);
            if (__LogNextSuffix_OwnsNativeMemory)
                Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextSuffix);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public bool Initialized
        {
            get
            {
                return ((__Internal*)__Instance)->Initialized != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Initialized = (byte) (value ? 1 : 0);
            }
        }

        public bool FontAtlasOwnedByContext
        {
            get
            {
                return ((__Internal*)__Instance)->FontAtlasOwnedByContext != 0;
            }

            set
            {
                ((__Internal*)__Instance)->FontAtlasOwnedByContext = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImGuiIO IO
        {
            get
            {
                return global::DearImguiSharp.ImGuiIO.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IO));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IO = *(global::DearImguiSharp.ImGuiIO.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiPlatformIO PlatformIO
        {
            get
            {
                return global::DearImguiSharp.ImGuiPlatformIO.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PlatformIO));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PlatformIO = *(global::DearImguiSharp.ImGuiPlatformIO.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiInputEvent InputEventsQueue
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiInputEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputEventsQueue));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputEventsQueue = *(global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiInputEvent InputEventsTrail
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiInputEvent.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputEventsTrail));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputEventsTrail = *(global::DearImguiSharp.ImVectorImGuiInputEvent.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStyle Style
        {
            get
            {
                return global::DearImguiSharp.ImGuiStyle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Style));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Style = *(global::DearImguiSharp.ImGuiStyle.__Internal*) value.__Instance;
            }
        }

        public int ConfigFlagsCurrFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlagsCurrFrame;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlagsCurrFrame = value;
            }
        }

        public int ConfigFlagsLastFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ConfigFlagsLastFrame;
            }

            set
            {
                ((__Internal*)__Instance)->ConfigFlagsLastFrame = value;
            }
        }

        public global::DearImguiSharp.ImFont Font
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(((__Internal*)__Instance)->Font, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Font = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float FontSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontSize = value;
            }
        }

        public float FontBaseSize
        {
            get
            {
                return ((__Internal*)__Instance)->FontBaseSize;
            }

            set
            {
                ((__Internal*)__Instance)->FontBaseSize = value;
            }
        }

        public global::DearImguiSharp.ImDrawListSharedData DrawListSharedData
        {
            get
            {
                return global::DearImguiSharp.ImDrawListSharedData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawListSharedData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawListSharedData = *(global::DearImguiSharp.ImDrawListSharedData.__Internal*) value.__Instance;
            }
        }

        public double Time
        {
            get
            {
                return ((__Internal*)__Instance)->Time;
            }

            set
            {
                ((__Internal*)__Instance)->Time = value;
            }
        }

        public int FrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCount = value;
            }
        }

        public int FrameCountEnded
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCountEnded;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCountEnded = value;
            }
        }

        public int FrameCountPlatformEnded
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCountPlatformEnded;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCountPlatformEnded = value;
            }
        }

        public int FrameCountRendered
        {
            get
            {
                return ((__Internal*)__Instance)->FrameCountRendered;
            }

            set
            {
                ((__Internal*)__Instance)->FrameCountRendered = value;
            }
        }

        public bool WithinFrameScope
        {
            get
            {
                return ((__Internal*)__Instance)->WithinFrameScope != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinFrameScope = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinFrameScopeWithImplicitWindow
        {
            get
            {
                return ((__Internal*)__Instance)->WithinFrameScopeWithImplicitWindow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinFrameScopeWithImplicitWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool WithinEndChild
        {
            get
            {
                return ((__Internal*)__Instance)->WithinEndChild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WithinEndChild = (byte) (value ? 1 : 0);
            }
        }

        public bool GcCompactAll
        {
            get
            {
                return ((__Internal*)__Instance)->GcCompactAll != 0;
            }

            set
            {
                ((__Internal*)__Instance)->GcCompactAll = (byte) (value ? 1 : 0);
            }
        }

        public bool TestEngineHookItems
        {
            get
            {
                return ((__Internal*)__Instance)->TestEngineHookItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TestEngineHookItems = (byte) (value ? 1 : 0);
            }
        }

        public __IntPtr TestEngine
        {
            get
            {
                return ((__Internal*)__Instance)->TestEngine;
            }

            set
            {
                ((__Internal*)__Instance)->TestEngine = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowPtr Windows
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Windows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Windows = *(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowPtr WindowsFocusOrder
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsFocusOrder));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsFocusOrder = *(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowPtr WindowsTempSortBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsTempSortBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsTempSortBuffer = *(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowStackData CurrentWindowStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowStackData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentWindowStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentWindowStack = *(global::DearImguiSharp.ImVectorImGuiWindowStackData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStorage WindowsById
        {
            get
            {
                return global::DearImguiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsById));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsById = *(global::DearImguiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public int WindowsActiveCount
        {
            get
            {
                return ((__Internal*)__Instance)->WindowsActiveCount;
            }

            set
            {
                ((__Internal*)__Instance)->WindowsActiveCount = value;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowsHoverPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowsHoverPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowsHoverPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow CurrentWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow HoveredWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->HoveredWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow HoveredWindowUnderMovingWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->HoveredWindowUnderMovingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredWindowUnderMovingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode HoveredDockNode
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->HoveredDockNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredDockNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow MovingWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->MovingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->MovingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow WheelingWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->WheelingWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->WheelingWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WheelingWindowRefMousePos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WheelingWindowRefMousePos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WheelingWindowRefMousePos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WheelingWindowTimer
        {
            get
            {
                return ((__Internal*)__Instance)->WheelingWindowTimer;
            }

            set
            {
                ((__Internal*)__Instance)->WheelingWindowTimer = value;
            }
        }

        public uint DebugHookIdInfo
        {
            get
            {
                return ((__Internal*)__Instance)->DebugHookIdInfo;
            }

            set
            {
                ((__Internal*)__Instance)->DebugHookIdInfo = value;
            }
        }

        public uint HoveredId
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredId;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredId = value;
            }
        }

        public uint HoveredIdPreviousFrame
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdPreviousFrame;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdPreviousFrame = value;
            }
        }

        public bool HoveredIdAllowOverlap
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdAllowOverlap != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdPreviousFrameUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdPreviousFrameUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdPreviousFrameUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public bool HoveredIdDisabled
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdDisabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdDisabled = (byte) (value ? 1 : 0);
            }
        }

        public float HoveredIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdTimer = value;
            }
        }

        public float HoveredIdNotActiveTimer
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredIdNotActiveTimer;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredIdNotActiveTimer = value;
            }
        }

        public uint ActiveId
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveId;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveId = value;
            }
        }

        public uint ActiveIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdIsAlive;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdIsAlive = value;
            }
        }

        public float ActiveIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdTimer = value;
            }
        }

        public bool ActiveIdIsJustActivated
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdIsJustActivated != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdIsJustActivated = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdAllowOverlap
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdAllowOverlap != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdAllowOverlap = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdNoClearOnFocusLoss
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdNoClearOnFocusLoss != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdNoClearOnFocusLoss = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenPressedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenPressedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenPressedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenEditedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdHasBeenEditedThisFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdHasBeenEditedThisFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdHasBeenEditedThisFrame = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 ActiveIdClickOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ActiveIdClickOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ActiveIdClickOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow ActiveIdWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ActiveIdWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputSource ActiveIdSource
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdSource;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdSource = value;
            }
        }

        public int ActiveIdMouseButton
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdMouseButton;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdMouseButton = value;
            }
        }

        public uint ActiveIdPreviousFrame
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrame;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrame = value;
            }
        }

        public bool ActiveIdPreviousFrameIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrameIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool ActiveIdPreviousFrameHasBeenEditedBefore
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdPreviousFrameHasBeenEditedBefore != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameHasBeenEditedBefore = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImGuiWindow ActiveIdPreviousFrameWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ActiveIdPreviousFrameWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdPreviousFrameWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint LastActiveId
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveId;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveId = value;
            }
        }

        public float LastActiveIdTimer
        {
            get
            {
                return ((__Internal*)__Instance)->LastActiveIdTimer;
            }

            set
            {
                ((__Internal*)__Instance)->LastActiveIdTimer = value;
            }
        }

        public bool ActiveIdUsingMouseWheel
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingMouseWheel != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingMouseWheel = (byte) (value ? 1 : 0);
            }
        }

        public uint ActiveIdUsingNavDirMask
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingNavDirMask;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingNavDirMask = value;
            }
        }

        public uint ActiveIdUsingNavInputMask
        {
            get
            {
                return ((__Internal*)__Instance)->ActiveIdUsingNavInputMask;
            }

            set
            {
                ((__Internal*)__Instance)->ActiveIdUsingNavInputMask = value;
            }
        }

        public global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN ActiveIdUsingKeyInputMask
        {
            get
            {
                return global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ActiveIdUsingKeyInputMask));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ActiveIdUsingKeyInputMask = *(global::DearImguiSharp.ImBitArrayImGuiKeyNamedKeyCOUNT__lessImGuiKeyNamedKeyBEGIN.__Internal*) value.__Instance;
            }
        }

        public int CurrentItemFlags
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentItemFlags;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentItemFlags = value;
            }
        }

        public global::DearImguiSharp.ImGuiNextItemData NextItemData
        {
            get
            {
                return global::DearImguiSharp.ImGuiNextItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NextItemData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NextItemData = *(global::DearImguiSharp.ImGuiNextItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiLastItemData LastItemData
        {
            get
            {
                return global::DearImguiSharp.ImGuiLastItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LastItemData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LastItemData = *(global::DearImguiSharp.ImGuiLastItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiNextWindowData NextWindowData
        {
            get
            {
                return global::DearImguiSharp.ImGuiNextWindowData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NextWindowData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NextWindowData = *(global::DearImguiSharp.ImGuiNextWindowData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiColorMod ColorStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiColorMod.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColorStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColorStack = *(global::DearImguiSharp.ImVectorImGuiColorMod.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiStyleMod StyleVarStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiStyleMod.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StyleVarStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StyleVarStack = *(global::DearImguiSharp.ImVectorImGuiStyleMod.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImFontPtr FontStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImFontPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FontStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FontStack = *(global::DearImguiSharp.ImVectorImFontPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiID FocusScopeStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FocusScopeStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FocusScopeStack = *(global::DearImguiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiItemFlags ItemFlagsStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiItemFlags.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemFlagsStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemFlagsStack = *(global::DearImguiSharp.ImVectorImGuiItemFlags.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiGroupData GroupStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiGroupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GroupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GroupStack = *(global::DearImguiSharp.ImVectorImGuiGroupData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiPopupData OpenPopupStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiPopupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OpenPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OpenPopupStack = *(global::DearImguiSharp.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiPopupData BeginPopupStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiPopupData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BeginPopupStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BeginPopupStack = *(global::DearImguiSharp.ImVectorImGuiPopupData.__Internal*) value.__Instance;
            }
        }

        public int BeginMenuCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginMenuCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginMenuCount = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiViewportPPtr Viewports
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiViewportPPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Viewports));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Viewports = *(global::DearImguiSharp.ImVectorImGuiViewportPPtr.__Internal*) value.__Instance;
            }
        }

        public float CurrentDpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentDpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentDpiScale = value;
            }
        }

        public global::DearImguiSharp.ImGuiViewportP CurrentViewport
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentViewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentViewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiViewportP MouseViewport
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->MouseViewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseViewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiViewportP MouseLastHoveredViewport
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->MouseLastHoveredViewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->MouseLastHoveredViewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint PlatformLastFocusedViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformLastFocusedViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformLastFocusedViewportId = value;
            }
        }

        public global::DearImguiSharp.ImGuiPlatformMonitor FallbackMonitor
        {
            get
            {
                return global::DearImguiSharp.ImGuiPlatformMonitor.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FallbackMonitor));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FallbackMonitor = *(global::DearImguiSharp.ImGuiPlatformMonitor.__Internal*) value.__Instance;
            }
        }

        public int ViewportFrontMostStampCount
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportFrontMostStampCount;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportFrontMostStampCount = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindow NavWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint NavId
        {
            get
            {
                return ((__Internal*)__Instance)->NavId;
            }

            set
            {
                ((__Internal*)__Instance)->NavId = value;
            }
        }

        public uint NavFocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->NavFocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->NavFocusScopeId = value;
            }
        }

        public uint NavActivateId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateId = value;
            }
        }

        public uint NavActivateDownId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateDownId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateDownId = value;
            }
        }

        public uint NavActivatePressedId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivatePressedId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivatePressedId = value;
            }
        }

        public uint NavActivateInputId
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateInputId;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateInputId = value;
            }
        }

        public int NavActivateFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavActivateFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavActivateFlags = value;
            }
        }

        public uint NavJustMovedToId
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToId;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToId = value;
            }
        }

        public uint NavJustMovedToFocusScopeId
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToFocusScopeId;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToFocusScopeId = value;
            }
        }

        public int NavJustMovedToKeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->NavJustMovedToKeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->NavJustMovedToKeyMods = value;
            }
        }

        public uint NavNextActivateId
        {
            get
            {
                return ((__Internal*)__Instance)->NavNextActivateId;
            }

            set
            {
                ((__Internal*)__Instance)->NavNextActivateId = value;
            }
        }

        public int NavNextActivateFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavNextActivateFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavNextActivateFlags = value;
            }
        }

        public global::DearImguiSharp.ImGuiInputSource NavInputSource
        {
            get
            {
                return ((__Internal*)__Instance)->NavInputSource;
            }

            set
            {
                ((__Internal*)__Instance)->NavInputSource = value;
            }
        }

        public global::DearImguiSharp.ImGuiNavLayer NavLayer
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayer;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayer = value;
            }
        }

        public bool NavIdIsAlive
        {
            get
            {
                return ((__Internal*)__Instance)->NavIdIsAlive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavIdIsAlive = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMousePosDirty
        {
            get
            {
                return ((__Internal*)__Instance)->NavMousePosDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMousePosDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableHighlight
        {
            get
            {
                return ((__Internal*)__Instance)->NavDisableHighlight != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavDisableHighlight = (byte) (value ? 1 : 0);
            }
        }

        public bool NavDisableMouseHover
        {
            get
            {
                return ((__Internal*)__Instance)->NavDisableMouseHover != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavDisableMouseHover = (byte) (value ? 1 : 0);
            }
        }

        public bool NavAnyRequest
        {
            get
            {
                return ((__Internal*)__Instance)->NavAnyRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavAnyRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequest
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool NavInitRequestFromMove
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitRequestFromMove != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitRequestFromMove = (byte) (value ? 1 : 0);
            }
        }

        public uint NavInitResultId
        {
            get
            {
                return ((__Internal*)__Instance)->NavInitResultId;
            }

            set
            {
                ((__Internal*)__Instance)->NavInitResultId = value;
            }
        }

        public global::DearImguiSharp.ImRect NavInitResultRectRel
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavInitResultRectRel));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavInitResultRectRel = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public bool NavMoveSubmitted
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveSubmitted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveSubmitted = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMoveScoringItems
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveScoringItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveScoringItems = (byte) (value ? 1 : 0);
            }
        }

        public bool NavMoveForwardToNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveForwardToNextFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveForwardToNextFrame = (byte) (value ? 1 : 0);
            }
        }

        public int NavMoveFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveFlags = value;
            }
        }

        public int NavMoveScrollFlags
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveScrollFlags;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveScrollFlags = value;
            }
        }

        public int NavMoveKeyMods
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveKeyMods;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveKeyMods = value;
            }
        }

        public int NavMoveDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveDir = value;
            }
        }

        public int NavMoveDirForDebug
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveDirForDebug;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveDirForDebug = value;
            }
        }

        public int NavMoveClipDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavMoveClipDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavMoveClipDir = value;
            }
        }

        public global::DearImguiSharp.ImRect NavScoringRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavScoringRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavScoringRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect NavScoringNoClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavScoringNoClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavScoringNoClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public int NavScoringDebugCount
        {
            get
            {
                return ((__Internal*)__Instance)->NavScoringDebugCount;
            }

            set
            {
                ((__Internal*)__Instance)->NavScoringDebugCount = value;
            }
        }

        public int NavTabbingDir
        {
            get
            {
                return ((__Internal*)__Instance)->NavTabbingDir;
            }

            set
            {
                ((__Internal*)__Instance)->NavTabbingDir = value;
            }
        }

        public int NavTabbingCounter
        {
            get
            {
                return ((__Internal*)__Instance)->NavTabbingCounter;
            }

            set
            {
                ((__Internal*)__Instance)->NavTabbingCounter = value;
            }
        }

        public global::DearImguiSharp.ImGuiNavItemData NavMoveResultLocal
        {
            get
            {
                return global::DearImguiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultLocal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultLocal = *(global::DearImguiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiNavItemData NavMoveResultLocalVisible
        {
            get
            {
                return global::DearImguiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultLocalVisible));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultLocalVisible = *(global::DearImguiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiNavItemData NavMoveResultOther
        {
            get
            {
                return global::DearImguiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavMoveResultOther));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavMoveResultOther = *(global::DearImguiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiNavItemData NavTabbingResultFirst
        {
            get
            {
                return global::DearImguiSharp.ImGuiNavItemData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->NavTabbingResultFirst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->NavTabbingResultFirst = *(global::DearImguiSharp.ImGuiNavItemData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow NavWindowingTarget
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingTarget, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTarget = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow NavWindowingTargetAnim
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingTargetAnim, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTargetAnim = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow NavWindowingListWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavWindowingListWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingListWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public float NavWindowingTimer
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingTimer;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingTimer = value;
            }
        }

        public float NavWindowingHighlightAlpha
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingHighlightAlpha;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingHighlightAlpha = value;
            }
        }

        public bool NavWindowingToggleLayer
        {
            get
            {
                return ((__Internal*)__Instance)->NavWindowingToggleLayer != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavWindowingToggleLayer = (byte) (value ? 1 : 0);
            }
        }

        public float DimBgRatio
        {
            get
            {
                return ((__Internal*)__Instance)->DimBgRatio;
            }

            set
            {
                ((__Internal*)__Instance)->DimBgRatio = value;
            }
        }

        public int MouseCursor
        {
            get
            {
                return ((__Internal*)__Instance)->MouseCursor;
            }

            set
            {
                ((__Internal*)__Instance)->MouseCursor = value;
            }
        }

        public bool DragDropActive
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropActive = (byte) (value ? 1 : 0);
            }
        }

        public bool DragDropWithinSource
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropWithinSource != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropWithinSource = (byte) (value ? 1 : 0);
            }
        }

        public bool DragDropWithinTarget
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropWithinTarget != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropWithinTarget = (byte) (value ? 1 : 0);
            }
        }

        public int DragDropSourceFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropSourceFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropSourceFlags = value;
            }
        }

        public int DragDropSourceFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropSourceFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropSourceFrameCount = value;
            }
        }

        public int DragDropMouseButton
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropMouseButton;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropMouseButton = value;
            }
        }

        public global::DearImguiSharp.ImGuiPayload DragDropPayload
        {
            get
            {
                return global::DearImguiSharp.ImGuiPayload.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropPayload));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropPayload = *(global::DearImguiSharp.ImGuiPayload.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect DragDropTargetRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropTargetRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropTargetRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public uint DragDropTargetId
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropTargetId;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropTargetId = value;
            }
        }

        public int DragDropAcceptFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptFlags = value;
            }
        }

        public float DragDropAcceptIdCurrRectSurface
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdCurrRectSurface;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdCurrRectSurface = value;
            }
        }

        public uint DragDropAcceptIdCurr
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdCurr;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdCurr = value;
            }
        }

        public uint DragDropAcceptIdPrev
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptIdPrev;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptIdPrev = value;
            }
        }

        public int DragDropAcceptFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropAcceptFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropAcceptFrameCount = value;
            }
        }

        public uint DragDropHoldJustPressedId
        {
            get
            {
                return ((__Internal*)__Instance)->DragDropHoldJustPressedId;
            }

            set
            {
                ((__Internal*)__Instance)->DragDropHoldJustPressedId = value;
            }
        }

        public global::DearImguiSharp.ImVector_unsigned_char DragDropPayloadBufHeap
        {
            get
            {
                return global::DearImguiSharp.ImVector_unsigned_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DragDropPayloadBufHeap));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DragDropPayloadBufHeap = *(global::DearImguiSharp.ImVector_unsigned_char.__Internal*) value.__Instance;
            }
        }

        public byte[] DragDropPayloadBufLocal
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<byte>(((__Internal*)__Instance)->DragDropPayloadBufLocal, 16);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 16; i++)
                        ((__Internal*)__Instance)->DragDropPayloadBufLocal[i] = value[i];
                }
            }
        }

        public int ClipperTempDataStacked
        {
            get
            {
                return ((__Internal*)__Instance)->ClipperTempDataStacked;
            }

            set
            {
                ((__Internal*)__Instance)->ClipperTempDataStacked = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiListClipperData ClipperTempData
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiListClipperData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipperTempData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipperTempData = *(global::DearImguiSharp.ImVectorImGuiListClipperData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTable CurrentTable
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTable.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentTable, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTable = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int TablesTempDataStacked
        {
            get
            {
                return ((__Internal*)__Instance)->TablesTempDataStacked;
            }

            set
            {
                ((__Internal*)__Instance)->TablesTempDataStacked = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiTableTempData TablesTempData
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTableTempData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TablesTempData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TablesTempData = *(global::DearImguiSharp.ImVectorImGuiTableTempData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImPoolImGuiTable Tables
        {
            get
            {
                return global::DearImguiSharp.ImPoolImGuiTable.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Tables));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Tables = *(global::DearImguiSharp.ImPoolImGuiTable.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVector_float TablesLastTimeActive
        {
            get
            {
                return global::DearImguiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TablesLastTimeActive));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TablesLastTimeActive = *(global::DearImguiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImDrawChannel DrawChannelsTempMergeBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImDrawChannel.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawChannelsTempMergeBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawChannelsTempMergeBuffer = *(global::DearImguiSharp.ImVectorImDrawChannel.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTabBar CurrentTabBar
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTabBar.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentTabBar, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTabBar = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImPoolImGuiTabBar TabBars
        {
            get
            {
                return global::DearImguiSharp.ImPoolImGuiTabBar.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TabBars));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TabBars = *(global::DearImguiSharp.ImPoolImGuiTabBar.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiPtrOrIndex CurrentTabBarStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrentTabBarStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrentTabBarStack = *(global::DearImguiSharp.ImVectorImGuiPtrOrIndex.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiShrinkWidthItem ShrinkWidthBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ShrinkWidthBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ShrinkWidthBuffer = *(global::DearImguiSharp.ImVectorImGuiShrinkWidthItem.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 MouseLastValidPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MouseLastValidPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MouseLastValidPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiInputTextState InputTextState
        {
            get
            {
                return global::DearImguiSharp.ImGuiInputTextState.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputTextState));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputTextState = *(global::DearImguiSharp.ImGuiInputTextState.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImFont InputTextPasswordFont
        {
            get
            {
                return global::DearImguiSharp.ImFont.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InputTextPasswordFont));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InputTextPasswordFont = *(global::DearImguiSharp.ImFont.__Internal*) value.__Instance;
            }
        }

        public uint TempInputId
        {
            get
            {
                return ((__Internal*)__Instance)->TempInputId;
            }

            set
            {
                ((__Internal*)__Instance)->TempInputId = value;
            }
        }

        public int ColorEditOptions
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditOptions;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditOptions = value;
            }
        }

        public float ColorEditLastHue
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastHue;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastHue = value;
            }
        }

        public float ColorEditLastSat
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastSat;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastSat = value;
            }
        }

        public uint ColorEditLastColor
        {
            get
            {
                return ((__Internal*)__Instance)->ColorEditLastColor;
            }

            set
            {
                ((__Internal*)__Instance)->ColorEditLastColor = value;
            }
        }

        public global::DearImguiSharp.ImVec4 ColorPickerRef
        {
            get
            {
                return global::DearImguiSharp.ImVec4.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColorPickerRef));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColorPickerRef = *(global::DearImguiSharp.ImVec4.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiComboPreviewData ComboPreviewData
        {
            get
            {
                return global::DearImguiSharp.ImGuiComboPreviewData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ComboPreviewData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ComboPreviewData = *(global::DearImguiSharp.ImGuiComboPreviewData.__Internal*) value.__Instance;
            }
        }

        public float SliderGrabClickOffset
        {
            get
            {
                return ((__Internal*)__Instance)->SliderGrabClickOffset;
            }

            set
            {
                ((__Internal*)__Instance)->SliderGrabClickOffset = value;
            }
        }

        public float SliderCurrentAccum
        {
            get
            {
                return ((__Internal*)__Instance)->SliderCurrentAccum;
            }

            set
            {
                ((__Internal*)__Instance)->SliderCurrentAccum = value;
            }
        }

        public bool SliderCurrentAccumDirty
        {
            get
            {
                return ((__Internal*)__Instance)->SliderCurrentAccumDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SliderCurrentAccumDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool DragCurrentAccumDirty
        {
            get
            {
                return ((__Internal*)__Instance)->DragCurrentAccumDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DragCurrentAccumDirty = (byte) (value ? 1 : 0);
            }
        }

        public float DragCurrentAccum
        {
            get
            {
                return ((__Internal*)__Instance)->DragCurrentAccum;
            }

            set
            {
                ((__Internal*)__Instance)->DragCurrentAccum = value;
            }
        }

        public float DragSpeedDefaultRatio
        {
            get
            {
                return ((__Internal*)__Instance)->DragSpeedDefaultRatio;
            }

            set
            {
                ((__Internal*)__Instance)->DragSpeedDefaultRatio = value;
            }
        }

        public float ScrollbarClickDeltaToGrabCenter
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarClickDeltaToGrabCenter;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarClickDeltaToGrabCenter = value;
            }
        }

        public float DisabledAlphaBackup
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledAlphaBackup;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledAlphaBackup = value;
            }
        }

        public short DisabledStackSize
        {
            get
            {
                return ((__Internal*)__Instance)->DisabledStackSize;
            }

            set
            {
                ((__Internal*)__Instance)->DisabledStackSize = value;
            }
        }

        public short TooltipOverrideCount
        {
            get
            {
                return ((__Internal*)__Instance)->TooltipOverrideCount;
            }

            set
            {
                ((__Internal*)__Instance)->TooltipOverrideCount = value;
            }
        }

        public float TooltipSlowDelay
        {
            get
            {
                return ((__Internal*)__Instance)->TooltipSlowDelay;
            }

            set
            {
                ((__Internal*)__Instance)->TooltipSlowDelay = value;
            }
        }

        public global::DearImguiSharp.ImVector_char ClipboardHandlerData
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipboardHandlerData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipboardHandlerData = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiID MenusIdSubmittedThisFrame
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenusIdSubmittedThisFrame));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenusIdSubmittedThisFrame = *(global::DearImguiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiPlatformImeData PlatformImeData
        {
            get
            {
                return global::DearImguiSharp.ImGuiPlatformImeData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PlatformImeData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PlatformImeData = *(global::DearImguiSharp.ImGuiPlatformImeData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiPlatformImeData PlatformImeDataPrev
        {
            get
            {
                return global::DearImguiSharp.ImGuiPlatformImeData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PlatformImeDataPrev));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PlatformImeDataPrev = *(global::DearImguiSharp.ImGuiPlatformImeData.__Internal*) value.__Instance;
            }
        }

        public uint PlatformImeViewport
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformImeViewport;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformImeViewport = value;
            }
        }

        public sbyte PlatformLocaleDecimalPoint
        {
            get
            {
                return ((__Internal*)__Instance)->PlatformLocaleDecimalPoint;
            }

            set
            {
                ((__Internal*)__Instance)->PlatformLocaleDecimalPoint = value;
            }
        }

        public global::DearImguiSharp.ImGuiDockContext DockContext
        {
            get
            {
                return global::DearImguiSharp.ImGuiDockContext.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DockContext));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DockContext = *(global::DearImguiSharp.ImGuiDockContext.__Internal*) value.__Instance;
            }
        }

        public bool SettingsLoaded
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsLoaded != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsLoaded = (byte) (value ? 1 : 0);
            }
        }

        public float SettingsDirtyTimer
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsDirtyTimer;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsDirtyTimer = value;
            }
        }

        public global::DearImguiSharp.ImGuiTextBuffer SettingsIniData
        {
            get
            {
                return global::DearImguiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsIniData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsIniData = *(global::DearImguiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiSettingsHandler SettingsHandlers
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiSettingsHandler.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsHandlers));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsHandlers = *(global::DearImguiSharp.ImVectorImGuiSettingsHandler.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImChunkStreamImGuiWindowSettings SettingsWindows
        {
            get
            {
                return global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsWindows = *(global::DearImguiSharp.ImChunkStreamImGuiWindowSettings.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImChunkStreamImGuiTableSettings SettingsTables
        {
            get
            {
                return global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SettingsTables));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SettingsTables = *(global::DearImguiSharp.ImChunkStreamImGuiTableSettings.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiContextHook Hooks
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiContextHook.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Hooks));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Hooks = *(global::DearImguiSharp.ImVectorImGuiContextHook.__Internal*) value.__Instance;
            }
        }

        public uint HookIdNext
        {
            get
            {
                return ((__Internal*)__Instance)->HookIdNext;
            }

            set
            {
                ((__Internal*)__Instance)->HookIdNext = value;
            }
        }

        public bool LogEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->LogEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->LogEnabled = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImGuiLogType LogType
        {
            get
            {
                return ((__Internal*)__Instance)->LogType;
            }

            set
            {
                ((__Internal*)__Instance)->LogType = value;
            }
        }

        public global::System.IntPtr LogFile
        {
            get
            {
                return ((__Internal*)__Instance)->LogFile;
            }

            set
            {
                ((__Internal*)__Instance)->LogFile = value;
            }
        }

        public global::DearImguiSharp.ImGuiTextBuffer LogBuffer
        {
            get
            {
                return global::DearImguiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->LogBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->LogBuffer = *(global::DearImguiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public string LogNextPrefix
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogNextPrefix);
            }

            set
            {
                if (__LogNextPrefix_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextPrefix);
                __LogNextPrefix_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogNextPrefix = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogNextPrefix = (__IntPtr) __bytePtr0;
            }
        }

        public string LogNextSuffix
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, ((__Internal*)__Instance)->LogNextSuffix);
            }

            set
            {
                if (__LogNextSuffix_OwnsNativeMemory)
                    Marshal.FreeHGlobal(((__Internal*)__Instance)->LogNextSuffix);
                __LogNextSuffix_OwnsNativeMemory = true;
                if (value == null)
                {
                    ((__Internal*)__Instance)->LogNextSuffix = global::System.IntPtr.Zero;
                    return;
                }
                var __bytes0 = global::System.Text.Encoding.UTF8.GetBytes(value);
                var __bytePtr0 = Marshal.AllocHGlobal(__bytes0.Length + 1);
                Marshal.Copy(__bytes0, 0, __bytePtr0, __bytes0.Length);
                Marshal.WriteByte(__bytePtr0 + __bytes0.Length, 0);
                ((__Internal*)__Instance)->LogNextSuffix = (__IntPtr) __bytePtr0;
            }
        }

        public float LogLinePosY
        {
            get
            {
                return ((__Internal*)__Instance)->LogLinePosY;
            }

            set
            {
                ((__Internal*)__Instance)->LogLinePosY = value;
            }
        }

        public bool LogLineFirstItem
        {
            get
            {
                return ((__Internal*)__Instance)->LogLineFirstItem != 0;
            }

            set
            {
                ((__Internal*)__Instance)->LogLineFirstItem = (byte) (value ? 1 : 0);
            }
        }

        public int LogDepthRef
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthRef;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthRef = value;
            }
        }

        public int LogDepthToExpand
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthToExpand;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthToExpand = value;
            }
        }

        public int LogDepthToExpandDefault
        {
            get
            {
                return ((__Internal*)__Instance)->LogDepthToExpandDefault;
            }

            set
            {
                ((__Internal*)__Instance)->LogDepthToExpandDefault = value;
            }
        }

        public int DebugLogFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DebugLogFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DebugLogFlags = value;
            }
        }

        public global::DearImguiSharp.ImGuiTextBuffer DebugLogBuf
        {
            get
            {
                return global::DearImguiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DebugLogBuf));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DebugLogBuf = *(global::DearImguiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public bool DebugItemPickerActive
        {
            get
            {
                return ((__Internal*)__Instance)->DebugItemPickerActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DebugItemPickerActive = (byte) (value ? 1 : 0);
            }
        }

        public uint DebugItemPickerBreakId
        {
            get
            {
                return ((__Internal*)__Instance)->DebugItemPickerBreakId;
            }

            set
            {
                ((__Internal*)__Instance)->DebugItemPickerBreakId = value;
            }
        }

        public global::DearImguiSharp.ImGuiMetricsConfig DebugMetricsConfig
        {
            get
            {
                return global::DearImguiSharp.ImGuiMetricsConfig.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DebugMetricsConfig));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DebugMetricsConfig = *(global::DearImguiSharp.ImGuiMetricsConfig.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStackTool DebugStackTool
        {
            get
            {
                return global::DearImguiSharp.ImGuiStackTool.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DebugStackTool));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DebugStackTool = *(global::DearImguiSharp.ImGuiStackTool.__Internal*) value.__Instance;
            }
        }

        public float[] FramerateSecPerFrame
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<float>(((__Internal*)__Instance)->FramerateSecPerFrame, 120);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 120; i++)
                        ((__Internal*)__Instance)->FramerateSecPerFrame[i] = value[i];
                }
            }
        }

        public int FramerateSecPerFrameIdx
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameIdx;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameIdx = value;
            }
        }

        public int FramerateSecPerFrameCount
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameCount;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameCount = value;
            }
        }

        public float FramerateSecPerFrameAccum
        {
            get
            {
                return ((__Internal*)__Instance)->FramerateSecPerFrameAccum;
            }

            set
            {
                ((__Internal*)__Instance)->FramerateSecPerFrameAccum = value;
            }
        }

        public int WantCaptureMouseNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureMouseNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureMouseNextFrame = value;
            }
        }

        public int WantCaptureKeyboardNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantCaptureKeyboardNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantCaptureKeyboardNextFrame = value;
            }
        }

        public int WantTextInputNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->WantTextInputNextFrame;
            }

            set
            {
                ((__Internal*)__Instance)->WantTextInputNextFrame = value;
            }
        }

        public global::DearImguiSharp.ImVector_char TempBuffer
        {
            get
            {
                return global::DearImguiSharp.ImVector_char.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TempBuffer));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TempBuffer = *(global::DearImguiSharp.ImVector_char.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindowTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 240)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVec2.__Internal CursorPos;
            public global::DearImguiSharp.ImVec2.__Internal CursorPosPrevLine;
            public global::DearImguiSharp.ImVec2.__Internal CursorStartPos;
            public global::DearImguiSharp.ImVec2.__Internal CursorMaxPos;
            public global::DearImguiSharp.ImVec2.__Internal IdealMaxPos;
            public global::DearImguiSharp.ImVec2.__Internal CurrLineSize;
            public global::DearImguiSharp.ImVec2.__Internal PrevLineSize;
            public float CurrLineTextBaseOffset;
            public float PrevLineTextBaseOffset;
            public byte IsSameLine;
            public global::DearImguiSharp.ImVec1.__Internal Indent;
            public global::DearImguiSharp.ImVec1.__Internal ColumnsOffset;
            public global::DearImguiSharp.ImVec1.__Internal GroupOffset;
            public global::DearImguiSharp.ImVec2.__Internal CursorStartPosLossyness;
            public global::DearImguiSharp.ImGuiNavLayer NavLayerCurrent;
            public short NavLayersActiveMask;
            public short NavLayersActiveMaskNext;
            public uint NavFocusScopeIdCurrent;
            public byte NavHideHighlightOneFrame;
            public byte NavHasScroll;
            public byte MenuBarAppending;
            public global::DearImguiSharp.ImVec2.__Internal MenuBarOffset;
            public global::DearImguiSharp.ImGuiMenuColumns.__Internal MenuColumns;
            public int TreeDepth;
            public uint TreeJumpToParentOnPopMask;
            public global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal ChildWindows;
            public __IntPtr StateStorage;
            public __IntPtr CurrentColumns;
            public int CurrentTableIdx;
            public int LayoutType;
            public int ParentLayoutType;
            public float ItemWidth;
            public float TextWrapPos;
            public global::DearImguiSharp.ImVector_float.__Internal ItemWidthStack;
            public global::DearImguiSharp.ImVector_float.__Internal TextWrapPosStack;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindowTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowTempData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindowTempData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindowTempData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindowTempData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindowTempData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindowTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindowTempData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindowTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindowTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindowTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindowTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindowTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindowTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindowTempData(global::DearImguiSharp.ImGuiWindowTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindowTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindowTempData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindowTempData.__Internal*) _0.__Instance);
        }

        ~ImGuiWindowTempData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVec2 CursorPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CursorPosPrevLine
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorPosPrevLine));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorPosPrevLine = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CursorStartPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorStartPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorStartPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CursorMaxPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorMaxPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 IdealMaxPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IdealMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IdealMaxPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CurrLineSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CurrLineSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 PrevLineSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->PrevLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->PrevLineSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float CurrLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->CurrLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->CurrLineTextBaseOffset = value;
            }
        }

        public float PrevLineTextBaseOffset
        {
            get
            {
                return ((__Internal*)__Instance)->PrevLineTextBaseOffset;
            }

            set
            {
                ((__Internal*)__Instance)->PrevLineTextBaseOffset = value;
            }
        }

        public bool IsSameLine
        {
            get
            {
                return ((__Internal*)__Instance)->IsSameLine != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSameLine = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec1 Indent
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Indent));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Indent = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec1 ColumnsOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsOffset = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec1 GroupOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->GroupOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->GroupOffset = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 CursorStartPosLossyness
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->CursorStartPosLossyness));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->CursorStartPosLossyness = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiNavLayer NavLayerCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayerCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayerCurrent = value;
            }
        }

        public short NavLayersActiveMask
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayersActiveMask;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayersActiveMask = value;
            }
        }

        public short NavLayersActiveMaskNext
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayersActiveMaskNext;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayersActiveMaskNext = value;
            }
        }

        public uint NavFocusScopeIdCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavFocusScopeIdCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavFocusScopeIdCurrent = value;
            }
        }

        public bool NavHideHighlightOneFrame
        {
            get
            {
                return ((__Internal*)__Instance)->NavHideHighlightOneFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavHideHighlightOneFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool NavHasScroll
        {
            get
            {
                return ((__Internal*)__Instance)->NavHasScroll != 0;
            }

            set
            {
                ((__Internal*)__Instance)->NavHasScroll = (byte) (value ? 1 : 0);
            }
        }

        public bool MenuBarAppending
        {
            get
            {
                return ((__Internal*)__Instance)->MenuBarAppending != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MenuBarAppending = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.ImVec2 MenuBarOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuBarOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuBarOffset = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiMenuColumns MenuColumns
        {
            get
            {
                return global::DearImguiSharp.ImGuiMenuColumns.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->MenuColumns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->MenuColumns = *(global::DearImguiSharp.ImGuiMenuColumns.__Internal*) value.__Instance;
            }
        }

        public int TreeDepth
        {
            get
            {
                return ((__Internal*)__Instance)->TreeDepth;
            }

            set
            {
                ((__Internal*)__Instance)->TreeDepth = value;
            }
        }

        public uint TreeJumpToParentOnPopMask
        {
            get
            {
                return ((__Internal*)__Instance)->TreeJumpToParentOnPopMask;
            }

            set
            {
                ((__Internal*)__Instance)->TreeJumpToParentOnPopMask = value;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiWindowPtr ChildWindows
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiWindowPtr.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ChildWindows));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ChildWindows = *(global::DearImguiSharp.ImVectorImGuiWindowPtr.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiStorage StateStorage
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiStorage.__GetOrCreateInstance(((__Internal*)__Instance)->StateStorage, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->StateStorage = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiOldColumns CurrentColumns
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiOldColumns.__GetOrCreateInstance(((__Internal*)__Instance)->CurrentColumns, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentColumns = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int CurrentTableIdx
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentTableIdx;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentTableIdx = value;
            }
        }

        public int LayoutType
        {
            get
            {
                return ((__Internal*)__Instance)->LayoutType;
            }

            set
            {
                ((__Internal*)__Instance)->LayoutType = value;
            }
        }

        public int ParentLayoutType
        {
            get
            {
                return ((__Internal*)__Instance)->ParentLayoutType;
            }

            set
            {
                ((__Internal*)__Instance)->ParentLayoutType = value;
            }
        }

        public float ItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidth = value;
            }
        }

        public float TextWrapPos
        {
            get
            {
                return ((__Internal*)__Instance)->TextWrapPos;
            }

            set
            {
                ((__Internal*)__Instance)->TextWrapPos = value;
            }
        }

        public global::DearImguiSharp.ImVector_float ItemWidthStack
        {
            get
            {
                return global::DearImguiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ItemWidthStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ItemWidthStack = *(global::DearImguiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVector_float TextWrapPosStack
        {
            get
            {
                return global::DearImguiSharp.ImVector_float.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TextWrapPosStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TextWrapPosStack = *(global::DearImguiSharp.ImVector_float.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiOldColumns : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiOldColumns@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumns>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumns>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiOldColumns managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiOldColumns>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiOldColumns managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiOldColumns __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumns(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiOldColumns __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiOldColumns)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiOldColumns __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiOldColumns(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiOldColumns(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumns(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiOldColumns()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiOldColumns(global::DearImguiSharp.ImVectorImGuiOldColumns _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiOldColumns()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiOldColumns Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiOldColumns.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiWindow : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 1096)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public __IntPtr Name;

            [FieldOffset(8)]
            public uint ID;

            [FieldOffset(12)]
            public int Flags;

            [FieldOffset(16)]
            public int FlagsPreviousFrame;

            [FieldOffset(20)]
            public global::DearImguiSharp.ImGuiWindowClass.__Internal WindowClass;

            [FieldOffset(48)]
            public __IntPtr Viewport;

            [FieldOffset(56)]
            public uint ViewportId;

            [FieldOffset(60)]
            public global::DearImguiSharp.ImVec2.__Internal ViewportPos;

            [FieldOffset(68)]
            public int ViewportAllowPlatformMonitorExtend;

            [FieldOffset(72)]
            public global::DearImguiSharp.ImVec2.__Internal Pos;

            [FieldOffset(80)]
            public global::DearImguiSharp.ImVec2.__Internal Size;

            [FieldOffset(88)]
            public global::DearImguiSharp.ImVec2.__Internal SizeFull;

            [FieldOffset(96)]
            public global::DearImguiSharp.ImVec2.__Internal ContentSize;

            [FieldOffset(104)]
            public global::DearImguiSharp.ImVec2.__Internal ContentSizeIdeal;

            [FieldOffset(112)]
            public global::DearImguiSharp.ImVec2.__Internal ContentSizeExplicit;

            [FieldOffset(120)]
            public global::DearImguiSharp.ImVec2.__Internal WindowPadding;

            [FieldOffset(128)]
            public float WindowRounding;

            [FieldOffset(132)]
            public float WindowBorderSize;

            [FieldOffset(136)]
            public int NameBufLen;

            [FieldOffset(140)]
            public uint MoveId;

            [FieldOffset(144)]
            public uint TabId;

            [FieldOffset(148)]
            public uint ChildId;

            [FieldOffset(152)]
            public global::DearImguiSharp.ImVec2.__Internal Scroll;

            [FieldOffset(160)]
            public global::DearImguiSharp.ImVec2.__Internal ScrollMax;

            [FieldOffset(168)]
            public global::DearImguiSharp.ImVec2.__Internal ScrollTarget;

            [FieldOffset(176)]
            public global::DearImguiSharp.ImVec2.__Internal ScrollTargetCenterRatio;

            [FieldOffset(184)]
            public global::DearImguiSharp.ImVec2.__Internal ScrollTargetEdgeSnapDist;

            [FieldOffset(192)]
            public global::DearImguiSharp.ImVec2.__Internal ScrollbarSizes;

            [FieldOffset(200)]
            public byte ScrollbarX;

            [FieldOffset(201)]
            public byte ScrollbarY;

            [FieldOffset(202)]
            public byte ViewportOwned;

            [FieldOffset(203)]
            public byte Active;

            [FieldOffset(204)]
            public byte WasActive;

            [FieldOffset(205)]
            public byte WriteAccessed;

            [FieldOffset(206)]
            public byte Collapsed;

            [FieldOffset(207)]
            public byte WantCollapseToggle;

            [FieldOffset(208)]
            public byte SkipItems;

            [FieldOffset(209)]
            public byte Appearing;

            [FieldOffset(210)]
            public byte Hidden;

            [FieldOffset(211)]
            public byte IsFallbackWindow;

            [FieldOffset(212)]
            public byte IsExplicitChild;

            [FieldOffset(213)]
            public byte HasCloseButton;

            [FieldOffset(214)]
            public sbyte ResizeBorderHeld;

            [FieldOffset(216)]
            public short BeginCount;

            [FieldOffset(218)]
            public short BeginOrderWithinParent;

            [FieldOffset(220)]
            public short BeginOrderWithinContext;

            [FieldOffset(222)]
            public short FocusOrder;

            [FieldOffset(224)]
            public uint PopupId;

            [FieldOffset(228)]
            public sbyte AutoFitFramesX;

            [FieldOffset(229)]
            public sbyte AutoFitFramesY;

            [FieldOffset(230)]
            public sbyte AutoFitChildAxises;

            [FieldOffset(231)]
            public byte AutoFitOnlyGrows;

            [FieldOffset(232)]
            public int AutoPosLastDirection;

            [FieldOffset(236)]
            public sbyte HiddenFramesCanSkipItems;

            [FieldOffset(237)]
            public sbyte HiddenFramesCannotSkipItems;

            [FieldOffset(238)]
            public sbyte HiddenFramesForRenderOnly;

            [FieldOffset(239)]
            public sbyte DisableInputsFrames;

            [FieldOffset(240)]
            public int SetWindowPosAllowFlags;

            [FieldOffset(241)]
            public int SetWindowSizeAllowFlags;

            [FieldOffset(242)]
            public int SetWindowCollapsedAllowFlags;

            [FieldOffset(243)]
            public int SetWindowDockAllowFlags;

            [FieldOffset(244)]
            public global::DearImguiSharp.ImVec2.__Internal SetWindowPosVal;

            [FieldOffset(252)]
            public global::DearImguiSharp.ImVec2.__Internal SetWindowPosPivot;

            [FieldOffset(264)]
            public global::DearImguiSharp.ImVectorImGuiID.__Internal IDStack;

            [FieldOffset(280)]
            public global::DearImguiSharp.ImGuiWindowTempData.__Internal DC;

            [FieldOffset(520)]
            public global::DearImguiSharp.ImRect.__Internal OuterRectClipped;

            [FieldOffset(536)]
            public global::DearImguiSharp.ImRect.__Internal InnerRect;

            [FieldOffset(552)]
            public global::DearImguiSharp.ImRect.__Internal InnerClipRect;

            [FieldOffset(568)]
            public global::DearImguiSharp.ImRect.__Internal WorkRect;

            [FieldOffset(584)]
            public global::DearImguiSharp.ImRect.__Internal ParentWorkRect;

            [FieldOffset(600)]
            public global::DearImguiSharp.ImRect.__Internal ClipRect;

            [FieldOffset(616)]
            public global::DearImguiSharp.ImRect.__Internal ContentRegionRect;

            [FieldOffset(632)]
            public global::DearImguiSharp.ImVec2ih.__Internal HitTestHoleSize;

            [FieldOffset(636)]
            public global::DearImguiSharp.ImVec2ih.__Internal HitTestHoleOffset;

            [FieldOffset(640)]
            public int LastFrameActive;

            [FieldOffset(644)]
            public int LastFrameJustFocused;

            [FieldOffset(648)]
            public float LastTimeActive;

            [FieldOffset(652)]
            public float ItemWidthDefault;

            [FieldOffset(656)]
            public global::DearImguiSharp.ImGuiStorage.__Internal StateStorage;

            [FieldOffset(672)]
            public global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal ColumnsStorage;

            [FieldOffset(688)]
            public float FontWindowScale;

            [FieldOffset(692)]
            public float FontDpiScale;

            [FieldOffset(696)]
            public int SettingsOffset;

            [FieldOffset(704)]
            public __IntPtr DrawList;

            [FieldOffset(712)]
            public global::DearImguiSharp.ImDrawList.__Internal DrawListInst;

            [FieldOffset(912)]
            public __IntPtr ParentWindow;

            [FieldOffset(920)]
            public __IntPtr ParentWindowInBeginStack;

            [FieldOffset(928)]
            public __IntPtr RootWindow;

            [FieldOffset(936)]
            public __IntPtr RootWindowPopupTree;

            [FieldOffset(944)]
            public __IntPtr RootWindowDockTree;

            [FieldOffset(952)]
            public __IntPtr RootWindowForTitleBarHighlight;

            [FieldOffset(960)]
            public __IntPtr RootWindowForNav;

            [FieldOffset(968)]
            public __IntPtr NavLastChildNavWindow;

            [FieldOffset(976)]
            public fixed uint NavLastIds[2];

            [FieldOffset(984)]
            public fixed byte NavRectRel[32];

            [FieldOffset(1016)]
            public int MemoryDrawListIdxCapacity;

            [FieldOffset(1020)]
            public int MemoryDrawListVtxCapacity;

            [FieldOffset(1024)]
            public byte MemoryCompacted;

            [FieldOffset(1025)]
            public byte DockIsActive;

            [FieldOffset(1025)]
            public byte DockNodeIsVisible;

            [FieldOffset(1025)]
            public byte DockTabIsVisible;

            [FieldOffset(1025)]
            public byte DockTabWantClose;

            [FieldOffset(1026)]
            public short DockOrder;

            [FieldOffset(1028)]
            public global::DearImguiSharp.ImGuiWindowDockStyle.__Internal DockStyle;

            [FieldOffset(1056)]
            public __IntPtr DockNode;

            [FieldOffset(1064)]
            public __IntPtr DockNodeAsHost;

            [FieldOffset(1072)]
            public uint DockId;

            [FieldOffset(1076)]
            public int DockTabItemStatusFlags;

            [FieldOffset(1080)]
            public global::DearImguiSharp.ImRect.__Internal DockTabItemRect;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiWindow@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindow>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiWindow>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiWindow managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiWindow>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiWindow managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiWindow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiWindow(native.ToPointer(), skipVTables);
        }

        internal static ImGuiWindow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiWindow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiWindow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiWindow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiWindow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiWindow()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiWindow(global::DearImguiSharp.ImGuiWindow _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiWindow.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiWindow.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiWindow.__Internal*) _0.__Instance);
        }

        ~ImGuiWindow()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Name
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Name;
            }

            set
            {
                ((__Internal*)__Instance)->Name = (__IntPtr) value;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public int FlagsPreviousFrame
        {
            get
            {
                return ((__Internal*)__Instance)->FlagsPreviousFrame;
            }

            set
            {
                ((__Internal*)__Instance)->FlagsPreviousFrame = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindowClass WindowClass
        {
            get
            {
                return global::DearImguiSharp.ImGuiWindowClass.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowClass));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowClass = *(global::DearImguiSharp.ImGuiWindowClass.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiViewportP Viewport
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(((__Internal*)__Instance)->Viewport, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Viewport = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint ViewportId
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportId;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportId = value;
            }
        }

        public global::DearImguiSharp.ImVec2 ViewportPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ViewportPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ViewportPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public int ViewportAllowPlatformMonitorExtend
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportAllowPlatformMonitorExtend;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportAllowPlatformMonitorExtend = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Pos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Pos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Pos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 Size
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Size));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Size = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SizeFull
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SizeFull));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SizeFull = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ContentSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ContentSizeIdeal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeIdeal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeIdeal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ContentSizeExplicit
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentSizeExplicit));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentSizeExplicit = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 WindowPadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WindowPadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WindowPadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public float WindowRounding
        {
            get
            {
                return ((__Internal*)__Instance)->WindowRounding;
            }

            set
            {
                ((__Internal*)__Instance)->WindowRounding = value;
            }
        }

        public float WindowBorderSize
        {
            get
            {
                return ((__Internal*)__Instance)->WindowBorderSize;
            }

            set
            {
                ((__Internal*)__Instance)->WindowBorderSize = value;
            }
        }

        public int NameBufLen
        {
            get
            {
                return ((__Internal*)__Instance)->NameBufLen;
            }

            set
            {
                ((__Internal*)__Instance)->NameBufLen = value;
            }
        }

        public uint MoveId
        {
            get
            {
                return ((__Internal*)__Instance)->MoveId;
            }

            set
            {
                ((__Internal*)__Instance)->MoveId = value;
            }
        }

        public uint TabId
        {
            get
            {
                return ((__Internal*)__Instance)->TabId;
            }

            set
            {
                ((__Internal*)__Instance)->TabId = value;
            }
        }

        public uint ChildId
        {
            get
            {
                return ((__Internal*)__Instance)->ChildId;
            }

            set
            {
                ((__Internal*)__Instance)->ChildId = value;
            }
        }

        public global::DearImguiSharp.ImVec2 Scroll
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Scroll));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Scroll = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollMax
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollMax));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollMax = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollTarget
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTarget));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTarget = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollTargetCenterRatio
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTargetCenterRatio));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTargetCenterRatio = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollTargetEdgeSnapDist
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollTargetEdgeSnapDist));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollTargetEdgeSnapDist = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 ScrollbarSizes
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ScrollbarSizes));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ScrollbarSizes = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public bool ScrollbarX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarX != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarX = (byte) (value ? 1 : 0);
            }
        }

        public bool ScrollbarY
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollbarY != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollbarY = (byte) (value ? 1 : 0);
            }
        }

        public bool ViewportOwned
        {
            get
            {
                return ((__Internal*)__Instance)->ViewportOwned != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ViewportOwned = (byte) (value ? 1 : 0);
            }
        }

        public bool Active
        {
            get
            {
                return ((__Internal*)__Instance)->Active != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Active = (byte) (value ? 1 : 0);
            }
        }

        public bool WasActive
        {
            get
            {
                return ((__Internal*)__Instance)->WasActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WasActive = (byte) (value ? 1 : 0);
            }
        }

        public bool WriteAccessed
        {
            get
            {
                return ((__Internal*)__Instance)->WriteAccessed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WriteAccessed = (byte) (value ? 1 : 0);
            }
        }

        public bool Collapsed
        {
            get
            {
                return ((__Internal*)__Instance)->Collapsed != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Collapsed = (byte) (value ? 1 : 0);
            }
        }

        public bool WantCollapseToggle
        {
            get
            {
                return ((__Internal*)__Instance)->WantCollapseToggle != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantCollapseToggle = (byte) (value ? 1 : 0);
            }
        }

        public bool SkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->SkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->SkipItems = (byte) (value ? 1 : 0);
            }
        }

        public bool Appearing
        {
            get
            {
                return ((__Internal*)__Instance)->Appearing != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Appearing = (byte) (value ? 1 : 0);
            }
        }

        public bool Hidden
        {
            get
            {
                return ((__Internal*)__Instance)->Hidden != 0;
            }

            set
            {
                ((__Internal*)__Instance)->Hidden = (byte) (value ? 1 : 0);
            }
        }

        public bool IsFallbackWindow
        {
            get
            {
                return ((__Internal*)__Instance)->IsFallbackWindow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsFallbackWindow = (byte) (value ? 1 : 0);
            }
        }

        public bool IsExplicitChild
        {
            get
            {
                return ((__Internal*)__Instance)->IsExplicitChild != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsExplicitChild = (byte) (value ? 1 : 0);
            }
        }

        public bool HasCloseButton
        {
            get
            {
                return ((__Internal*)__Instance)->HasCloseButton != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HasCloseButton = (byte) (value ? 1 : 0);
            }
        }

        public sbyte ResizeBorderHeld
        {
            get
            {
                return ((__Internal*)__Instance)->ResizeBorderHeld;
            }

            set
            {
                ((__Internal*)__Instance)->ResizeBorderHeld = value;
            }
        }

        public short BeginCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginCount = value;
            }
        }

        public short BeginOrderWithinParent
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrderWithinParent;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrderWithinParent = value;
            }
        }

        public short BeginOrderWithinContext
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrderWithinContext;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrderWithinContext = value;
            }
        }

        public short FocusOrder
        {
            get
            {
                return ((__Internal*)__Instance)->FocusOrder;
            }

            set
            {
                ((__Internal*)__Instance)->FocusOrder = value;
            }
        }

        public uint PopupId
        {
            get
            {
                return ((__Internal*)__Instance)->PopupId;
            }

            set
            {
                ((__Internal*)__Instance)->PopupId = value;
            }
        }

        public sbyte AutoFitFramesX
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitFramesX;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitFramesX = value;
            }
        }

        public sbyte AutoFitFramesY
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitFramesY;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitFramesY = value;
            }
        }

        public sbyte AutoFitChildAxises
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitChildAxises;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitChildAxises = value;
            }
        }

        public bool AutoFitOnlyGrows
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitOnlyGrows != 0;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitOnlyGrows = (byte) (value ? 1 : 0);
            }
        }

        public int AutoPosLastDirection
        {
            get
            {
                return ((__Internal*)__Instance)->AutoPosLastDirection;
            }

            set
            {
                ((__Internal*)__Instance)->AutoPosLastDirection = value;
            }
        }

        public sbyte HiddenFramesCanSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesCanSkipItems;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesCanSkipItems = value;
            }
        }

        public sbyte HiddenFramesCannotSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesCannotSkipItems;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesCannotSkipItems = value;
            }
        }

        public sbyte HiddenFramesForRenderOnly
        {
            get
            {
                return ((__Internal*)__Instance)->HiddenFramesForRenderOnly;
            }

            set
            {
                ((__Internal*)__Instance)->HiddenFramesForRenderOnly = value;
            }
        }

        public sbyte DisableInputsFrames
        {
            get
            {
                return ((__Internal*)__Instance)->DisableInputsFrames;
            }

            set
            {
                ((__Internal*)__Instance)->DisableInputsFrames = value;
            }
        }

        public int SetWindowPosAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowPosAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowPosAllowFlags = value;
            }
        }

        public int SetWindowSizeAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowSizeAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowSizeAllowFlags = value;
            }
        }

        public int SetWindowCollapsedAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowCollapsedAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowCollapsedAllowFlags = value;
            }
        }

        public int SetWindowDockAllowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SetWindowDockAllowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SetWindowDockAllowFlags = value;
            }
        }

        public global::DearImguiSharp.ImVec2 SetWindowPosVal
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SetWindowPosVal));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SetWindowPosVal = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 SetWindowPosPivot
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SetWindowPosPivot));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SetWindowPosPivot = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiID IDStack
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiID.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->IDStack));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->IDStack = *(global::DearImguiSharp.ImVectorImGuiID.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindowTempData DC
        {
            get
            {
                return global::DearImguiSharp.ImGuiWindowTempData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DC));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DC = *(global::DearImguiSharp.ImGuiWindowTempData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect OuterRectClipped
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OuterRectClipped));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OuterRectClipped = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect InnerRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect InnerClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect WorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect ParentWorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ParentWorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect ContentRegionRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ContentRegionRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ContentRegionRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2ih HitTestHoleSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HitTestHoleSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HitTestHoleSize = *(global::DearImguiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2ih HitTestHoleOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec2ih.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HitTestHoleOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HitTestHoleOffset = *(global::DearImguiSharp.ImVec2ih.__Internal*) value.__Instance;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public int LastFrameJustFocused
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameJustFocused;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameJustFocused = value;
            }
        }

        public float LastTimeActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastTimeActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastTimeActive = value;
            }
        }

        public float ItemWidthDefault
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidthDefault;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidthDefault = value;
            }
        }

        public global::DearImguiSharp.ImGuiStorage StateStorage
        {
            get
            {
                return global::DearImguiSharp.ImGuiStorage.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->StateStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->StateStorage = *(global::DearImguiSharp.ImGuiStorage.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiOldColumns ColumnsStorage
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiOldColumns.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsStorage));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsStorage = *(global::DearImguiSharp.ImVectorImGuiOldColumns.__Internal*) value.__Instance;
            }
        }

        public float FontWindowScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontWindowScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontWindowScale = value;
            }
        }

        public float FontDpiScale
        {
            get
            {
                return ((__Internal*)__Instance)->FontDpiScale;
            }

            set
            {
                ((__Internal*)__Instance)->FontDpiScale = value;
            }
        }

        public int SettingsOffset
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsOffset;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsOffset = value;
            }
        }

        public global::DearImguiSharp.ImDrawList DrawList
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(((__Internal*)__Instance)->DrawList, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawList = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawList DrawListInst
        {
            get
            {
                return global::DearImguiSharp.ImDrawList.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawListInst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawListInst = *(global::DearImguiSharp.ImDrawList.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow ParentWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ParentWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ParentWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow ParentWindowInBeginStack
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->ParentWindowInBeginStack, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ParentWindowInBeginStack = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow RootWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow RootWindowPopupTree
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowPopupTree, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowPopupTree = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow RootWindowDockTree
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowDockTree, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowDockTree = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow RootWindowForTitleBarHighlight
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowForTitleBarHighlight, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowForTitleBarHighlight = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow RootWindowForNav
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->RootWindowForNav, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RootWindowForNav = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow NavLastChildNavWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->NavLastChildNavWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->NavLastChildNavWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint[] NavLastIds
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->NavLastIds, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->NavLastIds[i] = value[i];
                }
            }
        }

        public global::DearImguiSharp.ImRect[] NavRectRel
        {
            get
            {
                global::DearImguiSharp.ImRect[] __value = null;
                if (((__Internal*)__Instance)->NavRectRel != null)
                {
                    __value = new global::DearImguiSharp.ImRect[2];
                    for (int i = 0; i < 2; i++)
                        __value[i] = global::DearImguiSharp.ImRect.__GetOrCreateInstance((IntPtr)((global::DearImguiSharp.ImRect.__Internal*)&(((__Internal*)__Instance)->NavRectRel[i * sizeof(global::DearImguiSharp.ImRect.__Internal)])), true, true);
                }
                return __value;
            }

            set
            {
                if (value != null)
                {
                    if (value.Length != 2)
                        throw new ArgumentOutOfRangeException("value", "The dimensions of the provided array don't match the required size.");
                    for (int i = 0; i < 2; i++)
                        *(global::DearImguiSharp.ImRect.__Internal*) &((__Internal*)__Instance)->NavRectRel[i * sizeof(global::DearImguiSharp.ImRect.__Internal)] = *(global::DearImguiSharp.ImRect.__Internal*)value[i].__Instance;
                }
            }
        }

        public int MemoryDrawListIdxCapacity
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryDrawListIdxCapacity;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryDrawListIdxCapacity = value;
            }
        }

        public int MemoryDrawListVtxCapacity
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryDrawListVtxCapacity;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryDrawListVtxCapacity = value;
            }
        }

        public bool MemoryCompacted
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryCompacted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryCompacted = (byte) (value ? 1 : 0);
            }
        }

        public bool DockIsActive
        {
            get
            {
                return ((__Internal*)__Instance)->DockIsActive != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockIsActive = (byte) (value ? 1 : 0);
            }
        }

        public bool DockNodeIsVisible
        {
            get
            {
                return ((__Internal*)__Instance)->DockNodeIsVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockNodeIsVisible = (byte) (value ? 1 : 0);
            }
        }

        public bool DockTabIsVisible
        {
            get
            {
                return ((__Internal*)__Instance)->DockTabIsVisible != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockTabIsVisible = (byte) (value ? 1 : 0);
            }
        }

        public bool DockTabWantClose
        {
            get
            {
                return ((__Internal*)__Instance)->DockTabWantClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->DockTabWantClose = (byte) (value ? 1 : 0);
            }
        }

        public short DockOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DockOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DockOrder = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindowDockStyle DockStyle
        {
            get
            {
                return global::DearImguiSharp.ImGuiWindowDockStyle.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DockStyle));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DockStyle = *(global::DearImguiSharp.ImGuiWindowDockStyle.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode DockNode
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->DockNode, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DockNode = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiDockNode DockNodeAsHost
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(((__Internal*)__Instance)->DockNodeAsHost, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DockNodeAsHost = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint DockId
        {
            get
            {
                return ((__Internal*)__Instance)->DockId;
            }

            set
            {
                ((__Internal*)__Instance)->DockId = value;
            }
        }

        public int DockTabItemStatusFlags
        {
            get
            {
                return ((__Internal*)__Instance)->DockTabItemStatusFlags;
            }

            set
            {
                ((__Internal*)__Instance)->DockTabItemStatusFlags = value;
            }
        }

        public global::DearImguiSharp.ImRect DockTabItemRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DockTabItemRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DockTabItemRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 56)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public __IntPtr Window;
            public int LastFrameVisible;
            public int LastFrameSelected;
            public float Offset;
            public float Width;
            public float ContentWidth;
            public float RequestedWidth;
            public int NameOffset;
            public short BeginOrder;
            public short IndexDuringLayout;
            public byte WantClose;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTabItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTabItem>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTabItem>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTabItem managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTabItem>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTabItem managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTabItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTabItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTabItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTabItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabItem(global::DearImguiSharp.ImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTabItem.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTabItem.__Internal*) _0.__Instance);
        }

        ~ImGuiTabItem()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public global::DearImguiSharp.ImGuiWindow Window
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->Window, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Window = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public int LastFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameVisible = value;
            }
        }

        public int LastFrameSelected
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameSelected;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameSelected = value;
            }
        }

        public float Offset
        {
            get
            {
                return ((__Internal*)__Instance)->Offset;
            }

            set
            {
                ((__Internal*)__Instance)->Offset = value;
            }
        }

        public float Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public float ContentWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ContentWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ContentWidth = value;
            }
        }

        public float RequestedWidth
        {
            get
            {
                return ((__Internal*)__Instance)->RequestedWidth;
            }

            set
            {
                ((__Internal*)__Instance)->RequestedWidth = value;
            }
        }

        public int NameOffset
        {
            get
            {
                return ((__Internal*)__Instance)->NameOffset;
            }

            set
            {
                ((__Internal*)__Instance)->NameOffset = value;
            }
        }

        public short BeginOrder
        {
            get
            {
                return ((__Internal*)__Instance)->BeginOrder;
            }

            set
            {
                ((__Internal*)__Instance)->BeginOrder = value;
            }
        }

        public short IndexDuringLayout
        {
            get
            {
                return ((__Internal*)__Instance)->IndexDuringLayout;
            }

            set
            {
                ((__Internal*)__Instance)->IndexDuringLayout = value;
            }
        }

        public bool WantClose
        {
            get
            {
                return ((__Internal*)__Instance)->WantClose != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantClose = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImVectorImGuiTabItem : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTabItem@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabItem>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabItem>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTabItem managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTabItem>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTabItem managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTabItem __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabItem(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTabItem __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTabItem)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTabItem __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTabItem(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTabItem(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabItem(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTabItem()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTabItem(global::DearImguiSharp.ImVectorImGuiTabItem _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTabItem.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTabItem.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTabItem.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTabItem()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTabItem Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTabItem.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTabBar : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 152)]
        public partial struct __Internal
        {
            public global::DearImguiSharp.ImVectorImGuiTabItem.__Internal Tabs;
            public int Flags;
            public uint ID;
            public uint SelectedTabId;
            public uint NextSelectedTabId;
            public uint VisibleTabId;
            public int CurrFrameVisible;
            public int PrevFrameVisible;
            public global::DearImguiSharp.ImRect.__Internal BarRect;
            public float CurrTabsContentsHeight;
            public float PrevTabsContentsHeight;
            public float WidthAllTabs;
            public float WidthAllTabsIdeal;
            public float ScrollingAnim;
            public float ScrollingTarget;
            public float ScrollingTargetDistToVisibility;
            public float ScrollingSpeed;
            public float ScrollingRectMinX;
            public float ScrollingRectMaxX;
            public uint ReorderRequestTabId;
            public short ReorderRequestOffset;
            public sbyte BeginCount;
            public byte WantLayout;
            public byte VisibleTabWasSubmitted;
            public byte TabsAddedNew;
            public short TabsActiveCount;
            public short LastTabItemIdx;
            public float ItemSpacingY;
            public global::DearImguiSharp.ImVec2.__Internal FramePadding;
            public global::DearImguiSharp.ImVec2.__Internal BackupCursorPos;
            public global::DearImguiSharp.ImGuiTextBuffer.__Internal TabsNames;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTabBar@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTabBar>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTabBar>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTabBar managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTabBar>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTabBar managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTabBar __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTabBar(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTabBar __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTabBar)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTabBar __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTabBar(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTabBar(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabBar(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTabBar()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTabBar(global::DearImguiSharp.ImGuiTabBar _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTabBar.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTabBar.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTabBar.__Internal*) _0.__Instance);
        }

        ~ImGuiTabBar()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImVectorImGuiTabItem Tabs
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTabItem.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Tabs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Tabs = *(global::DearImguiSharp.ImVectorImGuiTabItem.__Internal*) value.__Instance;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public uint SelectedTabId
        {
            get
            {
                return ((__Internal*)__Instance)->SelectedTabId;
            }

            set
            {
                ((__Internal*)__Instance)->SelectedTabId = value;
            }
        }

        public uint NextSelectedTabId
        {
            get
            {
                return ((__Internal*)__Instance)->NextSelectedTabId;
            }

            set
            {
                ((__Internal*)__Instance)->NextSelectedTabId = value;
            }
        }

        public uint VisibleTabId
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleTabId;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleTabId = value;
            }
        }

        public int CurrFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->CurrFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->CurrFrameVisible = value;
            }
        }

        public int PrevFrameVisible
        {
            get
            {
                return ((__Internal*)__Instance)->PrevFrameVisible;
            }

            set
            {
                ((__Internal*)__Instance)->PrevFrameVisible = value;
            }
        }

        public global::DearImguiSharp.ImRect BarRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BarRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BarRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public float CurrTabsContentsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->CurrTabsContentsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->CurrTabsContentsHeight = value;
            }
        }

        public float PrevTabsContentsHeight
        {
            get
            {
                return ((__Internal*)__Instance)->PrevTabsContentsHeight;
            }

            set
            {
                ((__Internal*)__Instance)->PrevTabsContentsHeight = value;
            }
        }

        public float WidthAllTabs
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAllTabs;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAllTabs = value;
            }
        }

        public float WidthAllTabsIdeal
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAllTabsIdeal;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAllTabsIdeal = value;
            }
        }

        public float ScrollingAnim
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingAnim;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingAnim = value;
            }
        }

        public float ScrollingTarget
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingTarget;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingTarget = value;
            }
        }

        public float ScrollingTargetDistToVisibility
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingTargetDistToVisibility;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingTargetDistToVisibility = value;
            }
        }

        public float ScrollingSpeed
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingSpeed;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingSpeed = value;
            }
        }

        public float ScrollingRectMinX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingRectMinX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingRectMinX = value;
            }
        }

        public float ScrollingRectMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->ScrollingRectMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->ScrollingRectMaxX = value;
            }
        }

        public uint ReorderRequestTabId
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderRequestTabId;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderRequestTabId = value;
            }
        }

        public short ReorderRequestOffset
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderRequestOffset;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderRequestOffset = value;
            }
        }

        public sbyte BeginCount
        {
            get
            {
                return ((__Internal*)__Instance)->BeginCount;
            }

            set
            {
                ((__Internal*)__Instance)->BeginCount = value;
            }
        }

        public bool WantLayout
        {
            get
            {
                return ((__Internal*)__Instance)->WantLayout != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantLayout = (byte) (value ? 1 : 0);
            }
        }

        public bool VisibleTabWasSubmitted
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleTabWasSubmitted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleTabWasSubmitted = (byte) (value ? 1 : 0);
            }
        }

        public bool TabsAddedNew
        {
            get
            {
                return ((__Internal*)__Instance)->TabsAddedNew != 0;
            }

            set
            {
                ((__Internal*)__Instance)->TabsAddedNew = (byte) (value ? 1 : 0);
            }
        }

        public short TabsActiveCount
        {
            get
            {
                return ((__Internal*)__Instance)->TabsActiveCount;
            }

            set
            {
                ((__Internal*)__Instance)->TabsActiveCount = value;
            }
        }

        public short LastTabItemIdx
        {
            get
            {
                return ((__Internal*)__Instance)->LastTabItemIdx;
            }

            set
            {
                ((__Internal*)__Instance)->LastTabItemIdx = value;
            }
        }

        public float ItemSpacingY
        {
            get
            {
                return ((__Internal*)__Instance)->ItemSpacingY;
            }

            set
            {
                ((__Internal*)__Instance)->ItemSpacingY = value;
            }
        }

        public global::DearImguiSharp.ImVec2 FramePadding
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->FramePadding));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->FramePadding = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 BackupCursorPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BackupCursorPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BackupCursorPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTextBuffer TabsNames
        {
            get
            {
                return global::DearImguiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->TabsNames));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->TabsNames = *(global::DearImguiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTableColumn : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 104)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public int Flags;

            [FieldOffset(4)]
            public float WidthGiven;

            [FieldOffset(8)]
            public float MinX;

            [FieldOffset(12)]
            public float MaxX;

            [FieldOffset(16)]
            public float WidthRequest;

            [FieldOffset(20)]
            public float WidthAuto;

            [FieldOffset(24)]
            public float StretchWeight;

            [FieldOffset(28)]
            public float InitStretchWeightOrWidth;

            [FieldOffset(32)]
            public global::DearImguiSharp.ImRect.__Internal ClipRect;

            [FieldOffset(48)]
            public uint UserID;

            [FieldOffset(52)]
            public float WorkMinX;

            [FieldOffset(56)]
            public float WorkMaxX;

            [FieldOffset(60)]
            public float ItemWidth;

            [FieldOffset(64)]
            public float ContentMaxXFrozen;

            [FieldOffset(68)]
            public float ContentMaxXUnfrozen;

            [FieldOffset(72)]
            public float ContentMaxXHeadersUsed;

            [FieldOffset(76)]
            public float ContentMaxXHeadersIdeal;

            [FieldOffset(80)]
            public short NameOffset;

            [FieldOffset(82)]
            public sbyte DisplayOrder;

            [FieldOffset(83)]
            public sbyte IndexWithinEnabledSet;

            [FieldOffset(84)]
            public sbyte PrevEnabledColumn;

            [FieldOffset(85)]
            public sbyte NextEnabledColumn;

            [FieldOffset(86)]
            public sbyte SortOrder;

            [FieldOffset(87)]
            public byte DrawChannelCurrent;

            [FieldOffset(88)]
            public byte DrawChannelFrozen;

            [FieldOffset(89)]
            public byte DrawChannelUnfrozen;

            [FieldOffset(90)]
            public byte IsEnabled;

            [FieldOffset(91)]
            public byte IsUserEnabled;

            [FieldOffset(92)]
            public byte IsUserEnabledNextFrame;

            [FieldOffset(93)]
            public byte IsVisibleX;

            [FieldOffset(94)]
            public byte IsVisibleY;

            [FieldOffset(95)]
            public byte IsRequestOutput;

            [FieldOffset(96)]
            public byte IsSkipItems;

            [FieldOffset(97)]
            public byte IsPreserveWidthAuto;

            [FieldOffset(98)]
            public sbyte NavLayerCurrent;

            [FieldOffset(99)]
            public byte AutoFitQueue;

            [FieldOffset(100)]
            public byte CannotSkipItemsQueue;

            [FieldOffset(101)]
            public byte SortDirection;

            [FieldOffset(101)]
            public byte SortDirectionsAvailCount;

            [FieldOffset(101)]
            public byte SortDirectionsAvailMask;

            [FieldOffset(102)]
            public byte SortDirectionsAvailList;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumn@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumn>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumn>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableColumn managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumn>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableColumn managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumn(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumn)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumn __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumn(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumn(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumn(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumn()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumn(global::DearImguiSharp.ImGuiTableColumn _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableColumn.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableColumn.__Internal*) _0.__Instance);
        }

        ~ImGuiTableColumn()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public float WidthGiven
        {
            get
            {
                return ((__Internal*)__Instance)->WidthGiven;
            }

            set
            {
                ((__Internal*)__Instance)->WidthGiven = value;
            }
        }

        public float MinX
        {
            get
            {
                return ((__Internal*)__Instance)->MinX;
            }

            set
            {
                ((__Internal*)__Instance)->MinX = value;
            }
        }

        public float MaxX
        {
            get
            {
                return ((__Internal*)__Instance)->MaxX;
            }

            set
            {
                ((__Internal*)__Instance)->MaxX = value;
            }
        }

        public float WidthRequest
        {
            get
            {
                return ((__Internal*)__Instance)->WidthRequest;
            }

            set
            {
                ((__Internal*)__Instance)->WidthRequest = value;
            }
        }

        public float WidthAuto
        {
            get
            {
                return ((__Internal*)__Instance)->WidthAuto;
            }

            set
            {
                ((__Internal*)__Instance)->WidthAuto = value;
            }
        }

        public float StretchWeight
        {
            get
            {
                return ((__Internal*)__Instance)->StretchWeight;
            }

            set
            {
                ((__Internal*)__Instance)->StretchWeight = value;
            }
        }

        public float InitStretchWeightOrWidth
        {
            get
            {
                return ((__Internal*)__Instance)->InitStretchWeightOrWidth;
            }

            set
            {
                ((__Internal*)__Instance)->InitStretchWeightOrWidth = value;
            }
        }

        public global::DearImguiSharp.ImRect ClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public uint UserID
        {
            get
            {
                return ((__Internal*)__Instance)->UserID;
            }

            set
            {
                ((__Internal*)__Instance)->UserID = value;
            }
        }

        public float WorkMinX
        {
            get
            {
                return ((__Internal*)__Instance)->WorkMinX;
            }

            set
            {
                ((__Internal*)__Instance)->WorkMinX = value;
            }
        }

        public float WorkMaxX
        {
            get
            {
                return ((__Internal*)__Instance)->WorkMaxX;
            }

            set
            {
                ((__Internal*)__Instance)->WorkMaxX = value;
            }
        }

        public float ItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ItemWidth = value;
            }
        }

        public float ContentMaxXFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXFrozen = value;
            }
        }

        public float ContentMaxXUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXUnfrozen = value;
            }
        }

        public float ContentMaxXHeadersUsed
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXHeadersUsed;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXHeadersUsed = value;
            }
        }

        public float ContentMaxXHeadersIdeal
        {
            get
            {
                return ((__Internal*)__Instance)->ContentMaxXHeadersIdeal;
            }

            set
            {
                ((__Internal*)__Instance)->ContentMaxXHeadersIdeal = value;
            }
        }

        public short NameOffset
        {
            get
            {
                return ((__Internal*)__Instance)->NameOffset;
            }

            set
            {
                ((__Internal*)__Instance)->NameOffset = value;
            }
        }

        public sbyte DisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayOrder = value;
            }
        }

        public sbyte IndexWithinEnabledSet
        {
            get
            {
                return ((__Internal*)__Instance)->IndexWithinEnabledSet;
            }

            set
            {
                ((__Internal*)__Instance)->IndexWithinEnabledSet = value;
            }
        }

        public sbyte PrevEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->PrevEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->PrevEnabledColumn = value;
            }
        }

        public sbyte NextEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->NextEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->NextEnabledColumn = value;
            }
        }

        public sbyte SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public byte DrawChannelCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelCurrent = value;
            }
        }

        public byte DrawChannelFrozen
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelFrozen;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelFrozen = value;
            }
        }

        public byte DrawChannelUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->DrawChannelUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->DrawChannelUnfrozen = value;
            }
        }

        public bool IsEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsEnabled = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUserEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsUserEnabled != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUserEnabled = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUserEnabledNextFrame
        {
            get
            {
                return ((__Internal*)__Instance)->IsUserEnabledNextFrame != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUserEnabledNextFrame = (byte) (value ? 1 : 0);
            }
        }

        public bool IsVisibleX
        {
            get
            {
                return ((__Internal*)__Instance)->IsVisibleX != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsVisibleX = (byte) (value ? 1 : 0);
            }
        }

        public bool IsVisibleY
        {
            get
            {
                return ((__Internal*)__Instance)->IsVisibleY != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsVisibleY = (byte) (value ? 1 : 0);
            }
        }

        public bool IsRequestOutput
        {
            get
            {
                return ((__Internal*)__Instance)->IsRequestOutput != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsRequestOutput = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->IsSkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSkipItems = (byte) (value ? 1 : 0);
            }
        }

        public bool IsPreserveWidthAuto
        {
            get
            {
                return ((__Internal*)__Instance)->IsPreserveWidthAuto != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsPreserveWidthAuto = (byte) (value ? 1 : 0);
            }
        }

        public sbyte NavLayerCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->NavLayerCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->NavLayerCurrent = value;
            }
        }

        public byte AutoFitQueue
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitQueue;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitQueue = value;
            }
        }

        public byte CannotSkipItemsQueue
        {
            get
            {
                return ((__Internal*)__Instance)->CannotSkipItemsQueue;
            }

            set
            {
                ((__Internal*)__Instance)->CannotSkipItemsQueue = value;
            }
        }

        public byte SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }

        public byte SortDirectionsAvailCount
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailCount;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailCount = value;
            }
        }

        public byte SortDirectionsAvailMask
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailMask;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailMask = value;
            }
        }

        public byte SortDirectionsAvailList
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirectionsAvailList;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirectionsAvailList = value;
            }
        }
    }

    public unsafe partial class ImGuiTableCellData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public uint BgColor;
            public sbyte Column;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableCellData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableCellData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableCellData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableCellData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableCellData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableCellData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableCellData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableCellData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableCellData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableCellData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableCellData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableCellData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableCellData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableCellData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableCellData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableCellData(global::DearImguiSharp.ImGuiTableCellData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableCellData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableCellData.__Internal*) _0.__Instance);
        }

        ~ImGuiTableCellData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint BgColor
        {
            get
            {
                return ((__Internal*)__Instance)->BgColor;
            }

            set
            {
                ((__Internal*)__Instance)->BgColor = value;
            }
        }

        public sbyte Column
        {
            get
            {
                return ((__Internal*)__Instance)->Column;
            }

            set
            {
                ((__Internal*)__Instance)->Column = value;
            }
        }
    }

    public unsafe partial class ImGuiTableInstanceData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public float LastOuterHeight;
            public float LastFirstRowHeight;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableInstanceData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableInstanceData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableInstanceData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableInstanceData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableInstanceData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableInstanceData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableInstanceData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableInstanceData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableInstanceData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableInstanceData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableInstanceData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableInstanceData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableInstanceData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableInstanceData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableInstanceData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableInstanceData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableInstanceData(global::DearImguiSharp.ImGuiTableInstanceData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableInstanceData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableInstanceData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableInstanceData.__Internal*) _0.__Instance);
        }

        ~ImGuiTableInstanceData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float LastOuterHeight
        {
            get
            {
                return ((__Internal*)__Instance)->LastOuterHeight;
            }

            set
            {
                ((__Internal*)__Instance)->LastOuterHeight = value;
            }
        }

        public float LastFirstRowHeight
        {
            get
            {
                return ((__Internal*)__Instance)->LastFirstRowHeight;
            }

            set
            {
                ((__Internal*)__Instance)->LastFirstRowHeight = value;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableColumn : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableColumn@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumn>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumn>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImSpanImGuiTableColumn managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumn>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImSpanImGuiTableColumn managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableColumn __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumn(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableColumn __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableColumn)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableColumn __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumn(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableColumn(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumn(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableColumn()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumn(global::DearImguiSharp.ImSpanImGuiTableColumn _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal*) __Instance) = *((global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal*) _0.__Instance);
        }

        ~ImSpanImGuiTableColumn()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiTableColumn Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableColumn.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTableColumn DataEnd
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableColumn.__GetOrCreateInstance(((__Internal*)__Instance)->DataEnd, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableColumnIdx : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableColumnIdx@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumnIdx>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumnIdx>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImSpanImGuiTableColumnIdx managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableColumnIdx>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImSpanImGuiTableColumnIdx managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableColumnIdx __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumnIdx(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableColumnIdx __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableColumnIdx)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableColumnIdx __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableColumnIdx(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableColumnIdx(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumnIdx(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableColumnIdx()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableColumnIdx(global::DearImguiSharp.ImSpanImGuiTableColumnIdx _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal*) __Instance) = *((global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal*) _0.__Instance);
        }

        ~ImSpanImGuiTableColumnIdx()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public sbyte* Data
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->Data;
            }

            set
            {
                ((__Internal*)__Instance)->Data = (__IntPtr) value;
            }
        }

        public sbyte* DataEnd
        {
            get
            {
                return (sbyte*) ((__Internal*)__Instance)->DataEnd;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = (__IntPtr) value;
            }
        }
    }

    public unsafe partial class ImSpanImGuiTableCellData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr Data;
            public __IntPtr DataEnd;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImSpan_ImGuiTableCellData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableCellData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableCellData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImSpanImGuiTableCellData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImSpanImGuiTableCellData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImSpanImGuiTableCellData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImSpanImGuiTableCellData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableCellData(native.ToPointer(), skipVTables);
        }

        internal static ImSpanImGuiTableCellData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImSpanImGuiTableCellData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImSpanImGuiTableCellData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImSpanImGuiTableCellData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImSpanImGuiTableCellData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableCellData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImSpanImGuiTableCellData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImSpanImGuiTableCellData(global::DearImguiSharp.ImSpanImGuiTableCellData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal*) __Instance) = *((global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal*) _0.__Instance);
        }

        ~ImSpanImGuiTableCellData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.ImGuiTableCellData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableCellData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTableCellData DataEnd
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableCellData.__GetOrCreateInstance(((__Internal*)__Instance)->DataEnd, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DataEnd = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTableInstanceData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTableInstanceData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableInstanceData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableInstanceData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTableInstanceData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableInstanceData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTableInstanceData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTableInstanceData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableInstanceData(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTableInstanceData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTableInstanceData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTableInstanceData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableInstanceData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTableInstanceData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableInstanceData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTableInstanceData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableInstanceData(global::DearImguiSharp.ImVectorImGuiTableInstanceData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTableInstanceData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTableInstanceData Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableInstanceData.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImVectorImGuiTableColumnSortSpecs : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public int Size;
            public int Capacity;
            public __IntPtr Data;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImVector_ImGuiTableColumnSortSpecs@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImVectorImGuiTableColumnSortSpecs __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableColumnSortSpecs(native.ToPointer(), skipVTables);
        }

        internal static ImVectorImGuiTableColumnSortSpecs __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImVectorImGuiTableColumnSortSpecs)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImVectorImGuiTableColumnSortSpecs __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImVectorImGuiTableColumnSortSpecs(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImVectorImGuiTableColumnSortSpecs(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableColumnSortSpecs(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImVectorImGuiTableColumnSortSpecs()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImVectorImGuiTableColumnSortSpecs(global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) __Instance) = *((global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) _0.__Instance);
        }

        ~ImVectorImGuiTableColumnSortSpecs()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Size
        {
            get
            {
                return ((__Internal*)__Instance)->Size;
            }

            set
            {
                ((__Internal*)__Instance)->Size = value;
            }
        }

        public int Capacity
        {
            get
            {
                return ((__Internal*)__Instance)->Capacity;
            }

            set
            {
                ((__Internal*)__Instance)->Capacity = value;
            }
        }

        public global::DearImguiSharp.ImGuiTableColumnSortSpecs Data
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(((__Internal*)__Instance)->Data, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Data = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiTable : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 536)]
        public partial struct __Internal
        {
            public uint ID;
            public int Flags;
            public __IntPtr RawData;
            public __IntPtr TempData;
            public global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal Columns;
            public global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal DisplayOrderToIndex;
            public global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal RowCellData;
            public ulong EnabledMaskByDisplayOrder;
            public ulong EnabledMaskByIndex;
            public ulong VisibleMaskByIndex;
            public ulong RequestOutputMaskByIndex;
            public int SettingsLoadedFlags;
            public int SettingsOffset;
            public int LastFrameActive;
            public int ColumnsCount;
            public int CurrentRow;
            public int CurrentColumn;
            public short InstanceCurrent;
            public short InstanceInteracted;
            public float RowPosY1;
            public float RowPosY2;
            public float RowMinHeight;
            public float RowTextBaseline;
            public float RowIndentOffsetX;
            public int RowFlags;
            public int LastRowFlags;
            public int RowBgColorCounter;
            public fixed uint RowBgColor[2];
            public uint BorderColorStrong;
            public uint BorderColorLight;
            public float BorderX1;
            public float BorderX2;
            public float HostIndentX;
            public float MinColumnWidth;
            public float OuterPaddingX;
            public float CellPaddingX;
            public float CellPaddingY;
            public float CellSpacingX1;
            public float CellSpacingX2;
            public float InnerWidth;
            public float ColumnsGivenWidth;
            public float ColumnsAutoFitWidth;
            public float ColumnsStretchSumWeights;
            public float ResizedColumnNextWidth;
            public float ResizeLockMinContentsX2;
            public float RefScale;
            public global::DearImguiSharp.ImRect.__Internal OuterRect;
            public global::DearImguiSharp.ImRect.__Internal InnerRect;
            public global::DearImguiSharp.ImRect.__Internal WorkRect;
            public global::DearImguiSharp.ImRect.__Internal InnerClipRect;
            public global::DearImguiSharp.ImRect.__Internal BgClipRect;
            public global::DearImguiSharp.ImRect.__Internal Bg0ClipRectForDrawCmd;
            public global::DearImguiSharp.ImRect.__Internal Bg2ClipRectForDrawCmd;
            public global::DearImguiSharp.ImRect.__Internal HostClipRect;
            public global::DearImguiSharp.ImRect.__Internal HostBackupInnerClipRect;
            public __IntPtr OuterWindow;
            public __IntPtr InnerWindow;
            public global::DearImguiSharp.ImGuiTextBuffer.__Internal ColumnsNames;
            public __IntPtr DrawSplitter;
            public global::DearImguiSharp.ImGuiTableInstanceData.__Internal InstanceDataFirst;
            public global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal InstanceDataExtra;
            public global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal SortSpecsSingle;
            public global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal SortSpecsMulti;
            public global::DearImguiSharp.ImGuiTableSortSpecs.__Internal SortSpecs;
            public sbyte SortSpecsCount;
            public sbyte ColumnsEnabledCount;
            public sbyte ColumnsEnabledFixedCount;
            public sbyte DeclColumnsCount;
            public sbyte HoveredColumnBody;
            public sbyte HoveredColumnBorder;
            public sbyte AutoFitSingleColumn;
            public sbyte ResizedColumn;
            public sbyte LastResizedColumn;
            public sbyte HeldHeaderColumn;
            public sbyte ReorderColumn;
            public sbyte ReorderColumnDir;
            public sbyte LeftMostEnabledColumn;
            public sbyte RightMostEnabledColumn;
            public sbyte LeftMostStretchedColumn;
            public sbyte RightMostStretchedColumn;
            public sbyte ContextPopupColumn;
            public sbyte FreezeRowsRequest;
            public sbyte FreezeRowsCount;
            public sbyte FreezeColumnsRequest;
            public sbyte FreezeColumnsCount;
            public sbyte RowCellDataCurrent;
            public byte DummyDrawChannel;
            public byte Bg2DrawChannelCurrent;
            public byte Bg2DrawChannelUnfrozen;
            public byte IsLayoutLocked;
            public byte IsInsideRow;
            public byte IsInitializing;
            public byte IsSortSpecsDirty;
            public byte IsUsingHeaders;
            public byte IsContextPopupOpen;
            public byte IsSettingsRequestLoad;
            public byte IsSettingsDirty;
            public byte IsDefaultDisplayOrder;
            public byte IsResetAllRequest;
            public byte IsResetDisplayOrderRequest;
            public byte IsUnfrozenRows;
            public byte IsDefaultSizingPolicy;
            public byte MemoryCompacted;
            public byte HostSkipItems;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTable@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTable>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTable>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTable managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTable>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTable managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTable __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTable(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTable __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTable)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTable __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTable(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTable(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTable(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTable()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTable(global::DearImguiSharp.ImGuiTable _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTable.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTable.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTable.__Internal*) _0.__Instance);
        }

        ~ImGuiTable()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int Flags
        {
            get
            {
                return ((__Internal*)__Instance)->Flags;
            }

            set
            {
                ((__Internal*)__Instance)->Flags = value;
            }
        }

        public __IntPtr RawData
        {
            get
            {
                return ((__Internal*)__Instance)->RawData;
            }

            set
            {
                ((__Internal*)__Instance)->RawData = (__IntPtr) value;
            }
        }

        public global::DearImguiSharp.ImGuiTableTempData TempData
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiTableTempData.__GetOrCreateInstance(((__Internal*)__Instance)->TempData, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->TempData = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImSpanImGuiTableColumn Columns
        {
            get
            {
                return global::DearImguiSharp.ImSpanImGuiTableColumn.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Columns));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Columns = *(global::DearImguiSharp.ImSpanImGuiTableColumn.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImSpanImGuiTableColumnIdx DisplayOrderToIndex
        {
            get
            {
                return global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DisplayOrderToIndex));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DisplayOrderToIndex = *(global::DearImguiSharp.ImSpanImGuiTableColumnIdx.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImSpanImGuiTableCellData RowCellData
        {
            get
            {
                return global::DearImguiSharp.ImSpanImGuiTableCellData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->RowCellData));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->RowCellData = *(global::DearImguiSharp.ImSpanImGuiTableCellData.__Internal*) value.__Instance;
            }
        }

        public ulong EnabledMaskByDisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->EnabledMaskByDisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->EnabledMaskByDisplayOrder = value;
            }
        }

        public ulong EnabledMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->EnabledMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->EnabledMaskByIndex = value;
            }
        }

        public ulong VisibleMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->VisibleMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->VisibleMaskByIndex = value;
            }
        }

        public ulong RequestOutputMaskByIndex
        {
            get
            {
                return ((__Internal*)__Instance)->RequestOutputMaskByIndex;
            }

            set
            {
                ((__Internal*)__Instance)->RequestOutputMaskByIndex = value;
            }
        }

        public int SettingsLoadedFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsLoadedFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsLoadedFlags = value;
            }
        }

        public int SettingsOffset
        {
            get
            {
                return ((__Internal*)__Instance)->SettingsOffset;
            }

            set
            {
                ((__Internal*)__Instance)->SettingsOffset = value;
            }
        }

        public int LastFrameActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastFrameActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastFrameActive = value;
            }
        }

        public int ColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCount = value;
            }
        }

        public int CurrentRow
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentRow;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentRow = value;
            }
        }

        public int CurrentColumn
        {
            get
            {
                return ((__Internal*)__Instance)->CurrentColumn;
            }

            set
            {
                ((__Internal*)__Instance)->CurrentColumn = value;
            }
        }

        public short InstanceCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->InstanceCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->InstanceCurrent = value;
            }
        }

        public short InstanceInteracted
        {
            get
            {
                return ((__Internal*)__Instance)->InstanceInteracted;
            }

            set
            {
                ((__Internal*)__Instance)->InstanceInteracted = value;
            }
        }

        public float RowPosY1
        {
            get
            {
                return ((__Internal*)__Instance)->RowPosY1;
            }

            set
            {
                ((__Internal*)__Instance)->RowPosY1 = value;
            }
        }

        public float RowPosY2
        {
            get
            {
                return ((__Internal*)__Instance)->RowPosY2;
            }

            set
            {
                ((__Internal*)__Instance)->RowPosY2 = value;
            }
        }

        public float RowMinHeight
        {
            get
            {
                return ((__Internal*)__Instance)->RowMinHeight;
            }

            set
            {
                ((__Internal*)__Instance)->RowMinHeight = value;
            }
        }

        public float RowTextBaseline
        {
            get
            {
                return ((__Internal*)__Instance)->RowTextBaseline;
            }

            set
            {
                ((__Internal*)__Instance)->RowTextBaseline = value;
            }
        }

        public float RowIndentOffsetX
        {
            get
            {
                return ((__Internal*)__Instance)->RowIndentOffsetX;
            }

            set
            {
                ((__Internal*)__Instance)->RowIndentOffsetX = value;
            }
        }

        public int RowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->RowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->RowFlags = value;
            }
        }

        public int LastRowFlags
        {
            get
            {
                return ((__Internal*)__Instance)->LastRowFlags;
            }

            set
            {
                ((__Internal*)__Instance)->LastRowFlags = value;
            }
        }

        public int RowBgColorCounter
        {
            get
            {
                return ((__Internal*)__Instance)->RowBgColorCounter;
            }

            set
            {
                ((__Internal*)__Instance)->RowBgColorCounter = value;
            }
        }

        public uint[] RowBgColor
        {
            get
            {
                return CppSharp.Runtime.MarshalUtil.GetArray<uint>(((__Internal*)__Instance)->RowBgColor, 2);
            }

            set
            {
                if (value != null)
                {
                    for (int i = 0; i < 2; i++)
                        ((__Internal*)__Instance)->RowBgColor[i] = value[i];
                }
            }
        }

        public uint BorderColorStrong
        {
            get
            {
                return ((__Internal*)__Instance)->BorderColorStrong;
            }

            set
            {
                ((__Internal*)__Instance)->BorderColorStrong = value;
            }
        }

        public uint BorderColorLight
        {
            get
            {
                return ((__Internal*)__Instance)->BorderColorLight;
            }

            set
            {
                ((__Internal*)__Instance)->BorderColorLight = value;
            }
        }

        public float BorderX1
        {
            get
            {
                return ((__Internal*)__Instance)->BorderX1;
            }

            set
            {
                ((__Internal*)__Instance)->BorderX1 = value;
            }
        }

        public float BorderX2
        {
            get
            {
                return ((__Internal*)__Instance)->BorderX2;
            }

            set
            {
                ((__Internal*)__Instance)->BorderX2 = value;
            }
        }

        public float HostIndentX
        {
            get
            {
                return ((__Internal*)__Instance)->HostIndentX;
            }

            set
            {
                ((__Internal*)__Instance)->HostIndentX = value;
            }
        }

        public float MinColumnWidth
        {
            get
            {
                return ((__Internal*)__Instance)->MinColumnWidth;
            }

            set
            {
                ((__Internal*)__Instance)->MinColumnWidth = value;
            }
        }

        public float OuterPaddingX
        {
            get
            {
                return ((__Internal*)__Instance)->OuterPaddingX;
            }

            set
            {
                ((__Internal*)__Instance)->OuterPaddingX = value;
            }
        }

        public float CellPaddingX
        {
            get
            {
                return ((__Internal*)__Instance)->CellPaddingX;
            }

            set
            {
                ((__Internal*)__Instance)->CellPaddingX = value;
            }
        }

        public float CellPaddingY
        {
            get
            {
                return ((__Internal*)__Instance)->CellPaddingY;
            }

            set
            {
                ((__Internal*)__Instance)->CellPaddingY = value;
            }
        }

        public float CellSpacingX1
        {
            get
            {
                return ((__Internal*)__Instance)->CellSpacingX1;
            }

            set
            {
                ((__Internal*)__Instance)->CellSpacingX1 = value;
            }
        }

        public float CellSpacingX2
        {
            get
            {
                return ((__Internal*)__Instance)->CellSpacingX2;
            }

            set
            {
                ((__Internal*)__Instance)->CellSpacingX2 = value;
            }
        }

        public float InnerWidth
        {
            get
            {
                return ((__Internal*)__Instance)->InnerWidth;
            }

            set
            {
                ((__Internal*)__Instance)->InnerWidth = value;
            }
        }

        public float ColumnsGivenWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsGivenWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsGivenWidth = value;
            }
        }

        public float ColumnsAutoFitWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsAutoFitWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsAutoFitWidth = value;
            }
        }

        public float ColumnsStretchSumWeights
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsStretchSumWeights;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsStretchSumWeights = value;
            }
        }

        public float ResizedColumnNextWidth
        {
            get
            {
                return ((__Internal*)__Instance)->ResizedColumnNextWidth;
            }

            set
            {
                ((__Internal*)__Instance)->ResizedColumnNextWidth = value;
            }
        }

        public float ResizeLockMinContentsX2
        {
            get
            {
                return ((__Internal*)__Instance)->ResizeLockMinContentsX2;
            }

            set
            {
                ((__Internal*)__Instance)->ResizeLockMinContentsX2 = value;
            }
        }

        public float RefScale
        {
            get
            {
                return ((__Internal*)__Instance)->RefScale;
            }

            set
            {
                ((__Internal*)__Instance)->RefScale = value;
            }
        }

        public global::DearImguiSharp.ImRect OuterRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->OuterRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->OuterRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect InnerRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect WorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->WorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->WorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect InnerClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InnerClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect BgClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->BgClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->BgClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect Bg0ClipRectForDrawCmd
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Bg0ClipRectForDrawCmd));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Bg0ClipRectForDrawCmd = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect Bg2ClipRectForDrawCmd
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->Bg2ClipRectForDrawCmd));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->Bg2ClipRectForDrawCmd = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostBackupInnerClipRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupInnerClipRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupInnerClipRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow OuterWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->OuterWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->OuterWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiWindow InnerWindow
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(((__Internal*)__Instance)->InnerWindow, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->InnerWindow = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTextBuffer ColumnsNames
        {
            get
            {
                return global::DearImguiSharp.ImGuiTextBuffer.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->ColumnsNames));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->ColumnsNames = *(global::DearImguiSharp.ImGuiTextBuffer.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawListSplitter DrawSplitter
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImDrawListSplitter.__GetOrCreateInstance(((__Internal*)__Instance)->DrawSplitter, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DrawSplitter = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTableInstanceData InstanceDataFirst
        {
            get
            {
                return global::DearImguiSharp.ImGuiTableInstanceData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InstanceDataFirst));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InstanceDataFirst = *(global::DearImguiSharp.ImGuiTableInstanceData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiTableInstanceData InstanceDataExtra
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTableInstanceData.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->InstanceDataExtra));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->InstanceDataExtra = *(global::DearImguiSharp.ImVectorImGuiTableInstanceData.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTableColumnSortSpecs SortSpecsSingle
        {
            get
            {
                return global::DearImguiSharp.ImGuiTableColumnSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecsSingle));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecsSingle = *(global::DearImguiSharp.ImGuiTableColumnSortSpecs.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs SortSpecsMulti
        {
            get
            {
                return global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecsMulti));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecsMulti = *(global::DearImguiSharp.ImVectorImGuiTableColumnSortSpecs.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiTableSortSpecs SortSpecs
        {
            get
            {
                return global::DearImguiSharp.ImGuiTableSortSpecs.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SortSpecs));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SortSpecs = *(global::DearImguiSharp.ImGuiTableSortSpecs.__Internal*) value.__Instance;
            }
        }

        public sbyte SortSpecsCount
        {
            get
            {
                return ((__Internal*)__Instance)->SortSpecsCount;
            }

            set
            {
                ((__Internal*)__Instance)->SortSpecsCount = value;
            }
        }

        public sbyte ColumnsEnabledCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsEnabledCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsEnabledCount = value;
            }
        }

        public sbyte ColumnsEnabledFixedCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsEnabledFixedCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsEnabledFixedCount = value;
            }
        }

        public sbyte DeclColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->DeclColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->DeclColumnsCount = value;
            }
        }

        public sbyte HoveredColumnBody
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredColumnBody;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredColumnBody = value;
            }
        }

        public sbyte HoveredColumnBorder
        {
            get
            {
                return ((__Internal*)__Instance)->HoveredColumnBorder;
            }

            set
            {
                ((__Internal*)__Instance)->HoveredColumnBorder = value;
            }
        }

        public sbyte AutoFitSingleColumn
        {
            get
            {
                return ((__Internal*)__Instance)->AutoFitSingleColumn;
            }

            set
            {
                ((__Internal*)__Instance)->AutoFitSingleColumn = value;
            }
        }

        public sbyte ResizedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ResizedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ResizedColumn = value;
            }
        }

        public sbyte LastResizedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LastResizedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LastResizedColumn = value;
            }
        }

        public sbyte HeldHeaderColumn
        {
            get
            {
                return ((__Internal*)__Instance)->HeldHeaderColumn;
            }

            set
            {
                ((__Internal*)__Instance)->HeldHeaderColumn = value;
            }
        }

        public sbyte ReorderColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderColumn = value;
            }
        }

        public sbyte ReorderColumnDir
        {
            get
            {
                return ((__Internal*)__Instance)->ReorderColumnDir;
            }

            set
            {
                ((__Internal*)__Instance)->ReorderColumnDir = value;
            }
        }

        public sbyte LeftMostEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LeftMostEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LeftMostEnabledColumn = value;
            }
        }

        public sbyte RightMostEnabledColumn
        {
            get
            {
                return ((__Internal*)__Instance)->RightMostEnabledColumn;
            }

            set
            {
                ((__Internal*)__Instance)->RightMostEnabledColumn = value;
            }
        }

        public sbyte LeftMostStretchedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->LeftMostStretchedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->LeftMostStretchedColumn = value;
            }
        }

        public sbyte RightMostStretchedColumn
        {
            get
            {
                return ((__Internal*)__Instance)->RightMostStretchedColumn;
            }

            set
            {
                ((__Internal*)__Instance)->RightMostStretchedColumn = value;
            }
        }

        public sbyte ContextPopupColumn
        {
            get
            {
                return ((__Internal*)__Instance)->ContextPopupColumn;
            }

            set
            {
                ((__Internal*)__Instance)->ContextPopupColumn = value;
            }
        }

        public sbyte FreezeRowsRequest
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeRowsRequest;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeRowsRequest = value;
            }
        }

        public sbyte FreezeRowsCount
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeRowsCount;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeRowsCount = value;
            }
        }

        public sbyte FreezeColumnsRequest
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeColumnsRequest;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeColumnsRequest = value;
            }
        }

        public sbyte FreezeColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->FreezeColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->FreezeColumnsCount = value;
            }
        }

        public sbyte RowCellDataCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->RowCellDataCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->RowCellDataCurrent = value;
            }
        }

        public byte DummyDrawChannel
        {
            get
            {
                return ((__Internal*)__Instance)->DummyDrawChannel;
            }

            set
            {
                ((__Internal*)__Instance)->DummyDrawChannel = value;
            }
        }

        public byte Bg2DrawChannelCurrent
        {
            get
            {
                return ((__Internal*)__Instance)->Bg2DrawChannelCurrent;
            }

            set
            {
                ((__Internal*)__Instance)->Bg2DrawChannelCurrent = value;
            }
        }

        public byte Bg2DrawChannelUnfrozen
        {
            get
            {
                return ((__Internal*)__Instance)->Bg2DrawChannelUnfrozen;
            }

            set
            {
                ((__Internal*)__Instance)->Bg2DrawChannelUnfrozen = value;
            }
        }

        public bool IsLayoutLocked
        {
            get
            {
                return ((__Internal*)__Instance)->IsLayoutLocked != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsLayoutLocked = (byte) (value ? 1 : 0);
            }
        }

        public bool IsInsideRow
        {
            get
            {
                return ((__Internal*)__Instance)->IsInsideRow != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsInsideRow = (byte) (value ? 1 : 0);
            }
        }

        public bool IsInitializing
        {
            get
            {
                return ((__Internal*)__Instance)->IsInitializing != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsInitializing = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSortSpecsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->IsSortSpecsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSortSpecsDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUsingHeaders
        {
            get
            {
                return ((__Internal*)__Instance)->IsUsingHeaders != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUsingHeaders = (byte) (value ? 1 : 0);
            }
        }

        public bool IsContextPopupOpen
        {
            get
            {
                return ((__Internal*)__Instance)->IsContextPopupOpen != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsContextPopupOpen = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSettingsRequestLoad
        {
            get
            {
                return ((__Internal*)__Instance)->IsSettingsRequestLoad != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSettingsRequestLoad = (byte) (value ? 1 : 0);
            }
        }

        public bool IsSettingsDirty
        {
            get
            {
                return ((__Internal*)__Instance)->IsSettingsDirty != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsSettingsDirty = (byte) (value ? 1 : 0);
            }
        }

        public bool IsDefaultDisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->IsDefaultDisplayOrder != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsDefaultDisplayOrder = (byte) (value ? 1 : 0);
            }
        }

        public bool IsResetAllRequest
        {
            get
            {
                return ((__Internal*)__Instance)->IsResetAllRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsResetAllRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool IsResetDisplayOrderRequest
        {
            get
            {
                return ((__Internal*)__Instance)->IsResetDisplayOrderRequest != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsResetDisplayOrderRequest = (byte) (value ? 1 : 0);
            }
        }

        public bool IsUnfrozenRows
        {
            get
            {
                return ((__Internal*)__Instance)->IsUnfrozenRows != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsUnfrozenRows = (byte) (value ? 1 : 0);
            }
        }

        public bool IsDefaultSizingPolicy
        {
            get
            {
                return ((__Internal*)__Instance)->IsDefaultSizingPolicy != 0;
            }

            set
            {
                ((__Internal*)__Instance)->IsDefaultSizingPolicy = (byte) (value ? 1 : 0);
            }
        }

        public bool MemoryCompacted
        {
            get
            {
                return ((__Internal*)__Instance)->MemoryCompacted != 0;
            }

            set
            {
                ((__Internal*)__Instance)->MemoryCompacted = (byte) (value ? 1 : 0);
            }
        }

        public bool HostSkipItems
        {
            get
            {
                return ((__Internal*)__Instance)->HostSkipItems != 0;
            }

            set
            {
                ((__Internal*)__Instance)->HostSkipItems = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImGuiTableTempData : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 112)]
        public partial struct __Internal
        {
            public int TableIndex;
            public float LastTimeActive;
            public global::DearImguiSharp.ImVec2.__Internal UserOuterSize;
            public global::DearImguiSharp.ImDrawListSplitter.__Internal DrawSplitter;
            public global::DearImguiSharp.ImRect.__Internal HostBackupWorkRect;
            public global::DearImguiSharp.ImRect.__Internal HostBackupParentWorkRect;
            public global::DearImguiSharp.ImVec2.__Internal HostBackupPrevLineSize;
            public global::DearImguiSharp.ImVec2.__Internal HostBackupCurrLineSize;
            public global::DearImguiSharp.ImVec2.__Internal HostBackupCursorMaxPos;
            public global::DearImguiSharp.ImVec1.__Internal HostBackupColumnsOffset;
            public float HostBackupItemWidth;
            public int HostBackupItemWidthStackSize;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableTempData@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableTempData>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableTempData>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableTempData managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableTempData>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableTempData managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableTempData __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableTempData(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableTempData __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableTempData)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableTempData __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableTempData(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableTempData(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableTempData(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableTempData()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableTempData(global::DearImguiSharp.ImGuiTableTempData _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableTempData.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableTempData.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableTempData.__Internal*) _0.__Instance);
        }

        ~ImGuiTableTempData()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int TableIndex
        {
            get
            {
                return ((__Internal*)__Instance)->TableIndex;
            }

            set
            {
                ((__Internal*)__Instance)->TableIndex = value;
            }
        }

        public float LastTimeActive
        {
            get
            {
                return ((__Internal*)__Instance)->LastTimeActive;
            }

            set
            {
                ((__Internal*)__Instance)->LastTimeActive = value;
            }
        }

        public global::DearImguiSharp.ImVec2 UserOuterSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->UserOuterSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->UserOuterSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImDrawListSplitter DrawSplitter
        {
            get
            {
                return global::DearImguiSharp.ImDrawListSplitter.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->DrawSplitter));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->DrawSplitter = *(global::DearImguiSharp.ImDrawListSplitter.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostBackupWorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupWorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImRect HostBackupParentWorkRect
        {
            get
            {
                return global::DearImguiSharp.ImRect.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupParentWorkRect));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupParentWorkRect = *(global::DearImguiSharp.ImRect.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 HostBackupPrevLineSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupPrevLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupPrevLineSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 HostBackupCurrLineSize
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupCurrLineSize));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupCurrLineSize = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec2 HostBackupCursorMaxPos
        {
            get
            {
                return global::DearImguiSharp.ImVec2.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupCursorMaxPos));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupCursorMaxPos = *(global::DearImguiSharp.ImVec2.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.ImVec1 HostBackupColumnsOffset
        {
            get
            {
                return global::DearImguiSharp.ImVec1.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->HostBackupColumnsOffset));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->HostBackupColumnsOffset = *(global::DearImguiSharp.ImVec1.__Internal*) value.__Instance;
            }
        }

        public float HostBackupItemWidth
        {
            get
            {
                return ((__Internal*)__Instance)->HostBackupItemWidth;
            }

            set
            {
                ((__Internal*)__Instance)->HostBackupItemWidth = value;
            }
        }

        public int HostBackupItemWidthStackSize
        {
            get
            {
                return ((__Internal*)__Instance)->HostBackupItemWidthStackSize;
            }

            set
            {
                ((__Internal*)__Instance)->HostBackupItemWidthStackSize = value;
            }
        }
    }

    public unsafe partial class ImGuiTableColumnSettings : IDisposable
    {
        [StructLayout(LayoutKind.Explicit, Size = 12)]
        public partial struct __Internal
        {
            [FieldOffset(0)]
            public float WidthOrWeight;

            [FieldOffset(4)]
            public uint UserID;

            [FieldOffset(8)]
            public sbyte Index;

            [FieldOffset(9)]
            public sbyte DisplayOrder;

            [FieldOffset(10)]
            public sbyte SortOrder;

            [FieldOffset(11)]
            public byte SortDirection;

            [FieldOffset(11)]
            public byte IsEnabled;

            [FieldOffset(11)]
            public byte IsStretch;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableColumnSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableColumnSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableColumnSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableColumnSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableColumnSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableColumnSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableColumnSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableColumnSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableColumnSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableColumnSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableColumnSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableColumnSettings(global::DearImguiSharp.ImGuiTableColumnSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableColumnSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableColumnSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableColumnSettings.__Internal*) _0.__Instance);
        }

        ~ImGuiTableColumnSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public float WidthOrWeight
        {
            get
            {
                return ((__Internal*)__Instance)->WidthOrWeight;
            }

            set
            {
                ((__Internal*)__Instance)->WidthOrWeight = value;
            }
        }

        public uint UserID
        {
            get
            {
                return ((__Internal*)__Instance)->UserID;
            }

            set
            {
                ((__Internal*)__Instance)->UserID = value;
            }
        }

        public sbyte Index
        {
            get
            {
                return ((__Internal*)__Instance)->Index;
            }

            set
            {
                ((__Internal*)__Instance)->Index = value;
            }
        }

        public sbyte DisplayOrder
        {
            get
            {
                return ((__Internal*)__Instance)->DisplayOrder;
            }

            set
            {
                ((__Internal*)__Instance)->DisplayOrder = value;
            }
        }

        public sbyte SortOrder
        {
            get
            {
                return ((__Internal*)__Instance)->SortOrder;
            }

            set
            {
                ((__Internal*)__Instance)->SortOrder = value;
            }
        }

        public byte SortDirection
        {
            get
            {
                return ((__Internal*)__Instance)->SortDirection;
            }

            set
            {
                ((__Internal*)__Instance)->SortDirection = value;
            }
        }

        public byte IsEnabled
        {
            get
            {
                return ((__Internal*)__Instance)->IsEnabled;
            }

            set
            {
                ((__Internal*)__Instance)->IsEnabled = value;
            }
        }

        public byte IsStretch
        {
            get
            {
                return ((__Internal*)__Instance)->IsStretch;
            }

            set
            {
                ((__Internal*)__Instance)->IsStretch = value;
            }
        }
    }

    public unsafe partial class ImGuiTableSettings : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public uint ID;
            public int SaveFlags;
            public float RefScale;
            public sbyte ColumnsCount;
            public sbyte ColumnsCountMax;
            public byte WantApply;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGuiTableSettings@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableSettings>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiTableSettings>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiTableSettings managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiTableSettings>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiTableSettings managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiTableSettings __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiTableSettings(native.ToPointer(), skipVTables);
        }

        internal static ImGuiTableSettings __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiTableSettings)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiTableSettings __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiTableSettings(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiTableSettings(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSettings(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiTableSettings()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiTableSettings(global::DearImguiSharp.ImGuiTableSettings _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiTableSettings.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiTableSettings.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiTableSettings.__Internal*) _0.__Instance);
        }

        ~ImGuiTableSettings()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public uint ID
        {
            get
            {
                return ((__Internal*)__Instance)->ID;
            }

            set
            {
                ((__Internal*)__Instance)->ID = value;
            }
        }

        public int SaveFlags
        {
            get
            {
                return ((__Internal*)__Instance)->SaveFlags;
            }

            set
            {
                ((__Internal*)__Instance)->SaveFlags = value;
            }
        }

        public float RefScale
        {
            get
            {
                return ((__Internal*)__Instance)->RefScale;
            }

            set
            {
                ((__Internal*)__Instance)->RefScale = value;
            }
        }

        public sbyte ColumnsCount
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCount;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCount = value;
            }
        }

        public sbyte ColumnsCountMax
        {
            get
            {
                return ((__Internal*)__Instance)->ColumnsCountMax;
            }

            set
            {
                ((__Internal*)__Instance)->ColumnsCountMax = value;
            }
        }

        public bool WantApply
        {
            get
            {
                return ((__Internal*)__Instance)->WantApply != 0;
            }

            set
            {
                ((__Internal*)__Instance)->WantApply = (byte) (value ? 1 : 0);
            }
        }
    }

    public unsafe partial class ImFontBuilderIO : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 8)]
        public partial struct __Internal
        {
            public __IntPtr FontBuilder_Build;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImFontBuilderIO@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontBuilderIO>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImFontBuilderIO>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImFontBuilderIO managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImFontBuilderIO>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImFontBuilderIO managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImFontBuilderIO __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native.ToPointer(), skipVTables);
        }

        internal static ImFontBuilderIO __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImFontBuilderIO)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImFontBuilderIO __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImFontBuilderIO(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImFontBuilderIO(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontBuilderIO(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImFontBuilderIO()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontBuilderIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImFontBuilderIO(global::DearImguiSharp.ImFontBuilderIO _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImFontBuilderIO.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImFontBuilderIO.__Internal*) __Instance) = *((global::DearImguiSharp.ImFontBuilderIO.__Internal*) _0.__Instance);
        }

        ~ImFontBuilderIO()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.Delegates.Func_bool___IntPtr FontBuilderBuild
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->FontBuilder_Build;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Func_bool___IntPtr) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Func_bool___IntPtr));
            }

            set
            {
                ((__Internal*)__Instance)->FontBuilder_Build = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ImGui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_ImVec2_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec2_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2_ImVec2_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ImVec2Float(float _x, float _y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_ImVec4_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec4_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec4_ImVec4_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec4ImVec4Float(float _x, float _y, float _z, float _w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCreateContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr CreateContext(__IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDestroyContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DestroyContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentContext();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCurrentContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentContext(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRender", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Render();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowDemoWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowDemoWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowMetricsWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowMetricsWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowDebugLogWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowDebugLogWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStackToolWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowStackToolWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowAboutWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowAboutWindow(bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStyleEditor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowStyleEditor(__IntPtr @ref);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowStyleSelector", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ShowStyleSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowFontSelector", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowFontSelector([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowUserGuide", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowUserGuide();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetVersion", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetVersion();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsDark", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsDark(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsLight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsLight(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStyleColorsClassic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StyleColorsClassic(__IntPtr dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBegin", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Begin([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void End();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChild_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::DearImguiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChild_ID", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildID(uint id, global::DearImguiSharp.ImVec2.__Internal size, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndChild", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChild();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowAppearing", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowAppearing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowCollapsed();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowFocused(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetWindowDrawList();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowDpiScale", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowDpiScale();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetWindowHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetWindowViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowPos(global::DearImguiSharp.ImVec2.__Internal pos, int cond, global::DearImguiSharp.ImVec2.__Internal pivot);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSize(global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowSizeConstraints", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowSizeConstraints(global::DearImguiSharp.ImVec2.__Internal size_min, global::DearImguiSharp.ImVec2.__Internal size_max, __IntPtr custom_callback, __IntPtr custom_callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowContentSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowContentSize(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowCollapsed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowCollapsed(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowBgAlpha", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowBgAlpha(float alpha);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowViewport(uint viewport_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosVec2(global::DearImguiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeVec2(global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_Bool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedBool(bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFocus_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFontScale", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFontScale(float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::DearImguiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowFocus_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowFocusStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionAvail", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionAvail(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowContentRegionMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowContentRegionMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowContentRegionMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollX_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollX_Float(float scroll_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollY_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollY_Float(float scroll_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollMaxX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetScrollMaxY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetScrollMaxY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollHereX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereX(float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollHereY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollHereY(float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosX_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosX_Float(float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosY_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosY_Float(float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleColor_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorU32(int idx, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleColor_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleColorVec4(int idx, global::DearImguiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopStyleColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleColor(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleVar_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarFloat(int idx, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushStyleVar_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushStyleVarVec2(int idx, global::DearImguiSharp.ImVec2.__Internal val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopStyleVar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopStyleVar(int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushAllowKeyboardFocus(bool allow_keyboard_focus);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopAllowKeyboardFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopAllowKeyboardFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushButtonRepeat(bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopButtonRepeat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopButtonRepeat();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemWidth(float item_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcItemWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float CalcItemWidth();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushTextWrapPos(float wrap_local_pos_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopTextWrapPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopTextWrapPos();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFontSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFontSize();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFontTexUvWhitePixel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetFontTexUvWhitePixel(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_Col", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Col(int idx, float alpha_mul);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32Vec4(global::DearImguiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColorU32_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColorU32U32(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyleColorVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorVec4(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSeparator", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Separator();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSameLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SameLine(float offset_from_start_x, float spacing);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNewLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NewLine();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Spacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDummy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Dummy(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIndent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Indent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUnindent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Unindent(float indent_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndGroup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndGroup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetCursorPosY();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPos(global::DearImguiSharp.ImVec2.__Internal local_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPosX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosX(float local_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorPosY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorPosY(float local_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorStartPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorStartPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetCursorScreenPos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCursorScreenPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCursorScreenPos(global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAlignTextToFramePadding", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void AlignTextToFramePadding();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTextLineHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTextLineHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTextLineHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameHeightWithSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetFrameHeightWithSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Str([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_StrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Ptr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushID_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushID_Int(int int_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_Str([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_StrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetID_Ptr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextUnformatted", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextUnformatted([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Text([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextColored", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextColored(global::DearImguiSharp.ImVec4.__Internal col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextDisabled([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextWrapped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextWrapped([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLabelText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LabelText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBulletText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BulletText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Button([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSmallButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SmallButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInvisibleButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InvisibleButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, global::DearImguiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igArrowButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ArrowButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Image(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal size, global::DearImguiSharp.ImVec2.__Internal uv0, global::DearImguiSharp.ImVec2.__Internal uv1, global::DearImguiSharp.ImVec4.__Internal tint_col, global::DearImguiSharp.ImVec4.__Internal border_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImageButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImageButton(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal size, global::DearImguiSharp.ImVec2.__Internal uv0, global::DearImguiSharp.ImVec2.__Internal uv1, int frame_padding, global::DearImguiSharp.ImVec4.__Internal bg_col, global::DearImguiSharp.ImVec4.__Internal tint_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckbox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool Checkbox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_IntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* flags, int flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_UintPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsUintPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint* flags, uint flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRadioButton_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool active);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRadioButton_IntPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool RadioButtonIntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igProgressBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ProgressBar(float fraction, global::DearImguiSharp.ImVec2.__Internal size_arg, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBullet", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Bullet();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginCombo", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginCombo([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string preview_value, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndCombo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndCombo();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_Str_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string items_separated_by_zeros, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCombo_FnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ComboFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragFloatRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragFloatRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_current_min, float* v_current_max, float v_speed, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragIntRange2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragIntRange2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v_current_min, int* v_current_max, float v_speed, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format_max, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderAngle", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderAngle([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v_rad, float v_degrees_min, float v_degrees_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, float* v, float v_min, float v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, int* v, int v_min, int v_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igVSliderScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool VSliderScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextMultiline", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextMultiline([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, IntPtr buf_size, global::DearImguiSharp.ImVec2.__Internal size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextWithHint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextWithHint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, IntPtr buf_size, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* v, float step, float step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputFloat4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputFloat4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* v, int step, int step_fast, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt2([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputInt4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputInt4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int[] v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputDouble", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputDouble([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, double* v, double step, double step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputScalarN", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputScalarN([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEdit3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEdit4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorEdit4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPicker3", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker3([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPicker4", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorPicker4([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float[] col, int flags, float* ref_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ColorButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string desc_id, global::DearImguiSharp.ImVec4.__Internal col, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColorEditOptions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColorEditOptions(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNode_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodePtr(__IntPtr ptr_id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_StrStr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExStrStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeEx_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeExPtr(__IntPtr ptr_id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePush_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePush_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushPtr(__IntPtr ptr_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePop", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePop();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTreeNodeToLabelSpacing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetTreeNodeToLabelSpacing();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapsingHeader_TreeNodeFlags", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderTreeNodeFlags([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapsingHeader_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapsingHeaderBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_visible, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextItemOpen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextItemOpen(bool is_open, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSelectable_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool selected, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSelectable_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SelectableBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_selected, int flags, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginListBox", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginListBox([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndListBox", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndListBox();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igListBox_Str_arr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxStr_arr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, [MarshalAs(UnmanagedType.LPArray)] string[] items, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igListBox_FnBoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ListBoxFnBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int* current_item, __IntPtr items_getter, __IntPtr data, int items_count, int height_in_items);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotLines_FloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotLines_FnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotLinesFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotHistogram_FloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float* values, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotHistogram_FnFloatPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PlotHistogramFnFloatPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal graph_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Bool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, bool b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueInt([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Uint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueUint([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, uint v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igValue_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ValueFloat([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, float v, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string float_format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMainMenuBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMainMenuBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenu", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenu([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndMenu();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItem_Bool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBool([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItem_BoolPtr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemBoolPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool* p_selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTooltip();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopup", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupModal", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupModal([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopup_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopup_ID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupID(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopupOnItemClick", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupOnItemClick([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCloseCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CloseCurrentPopup();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextWindow", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupContextVoid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupContextVoid([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsPopupOpen_Str", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsPopupOpenStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTable([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int column, int flags, global::DearImguiSharp.ImVec2.__Internal outer_size, float inner_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableNextRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableNextRow(int row_flags, float min_row_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableNextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TableSetColumnIndex(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupColumn([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags, float init_width_or_weight, uint user_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupScrollFreeze", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupScrollFreeze(int cols, int rows);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableHeadersRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeadersRow();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableHeader", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableHeader([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetRowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetRowIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnName_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetColumnNameInt(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnFlags(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnEnabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnEnabled(int column_n, bool v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetBgColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetBgColor(int target, uint color, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Columns(int count, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string id, bool border);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNextColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NextColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnIndex();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnWidth(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnWidth(int column_index, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnOffset(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetColumnOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetColumnOffset(int column_index, float offset_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnsCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetColumnsCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabItem", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabItem([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndTabItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndTabItem();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabItemButton([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetTabItemClosed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetTabItemClosed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string tab_or_docked_window_label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockSpace", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockSpace(uint id, global::DearImguiSharp.ImVec2.__Internal size, int flags, __IntPtr window_class);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockSpaceOverViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockSpaceOverViewport(__IntPtr viewport, int flags, __IntPtr window_class);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowDockID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowDockID(uint dock_id, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowClass", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowClass(__IntPtr window_class);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowDockID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowDockID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowDocked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowDocked();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToTTY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToTTY(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToFile", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToFile(int auto_open_depth, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToClipboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToClipboard(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogFinish();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogButtons", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogButtons();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropSource(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SetDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, __IntPtr data, IntPtr sz, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropSource();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAcceptDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr AcceptDragDropPayload([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDragDropTarget();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDragDropPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDragDropPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginDisabled(bool disabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndDisabled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndDisabled();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushClipRect(global::DearImguiSharp.ImVec2.__Internal clip_rect_min, global::DearImguiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopClipRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemDefaultFocus", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemDefaultFocus();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetKeyboardFocusHere", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetKeyboardFocusHere(int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemHovered(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemClicked(int mouse_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemVisible", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemVisible();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemEdited", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemEdited();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemActivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemActivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemDeactivated", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivated();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemDeactivatedAfterEdit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemDeactivatedAfterEdit();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemToggledOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemToggledOpen();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemHovered", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemHovered();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyItemFocused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyItemFocused();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMin(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectMax(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemRectSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetItemRectSize(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemAllowOverlap", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemAllowOverlap();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMainViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetMainViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetBackgroundDrawList_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetBackgroundDrawListNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetBackgroundDrawList_ViewportPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetBackgroundDrawListViewportPtr(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_ViewportPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListViewportPtr(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsRectVisible_Nil", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleNil(global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsRectVisible_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsRectVisibleVec2(global::DearImguiSharp.ImVec2.__Internal rect_min, global::DearImguiSharp.ImVec2.__Internal rect_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTime", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double GetTime();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFrameCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetFrameCount();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDrawListSharedData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDrawListSharedData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStyleColorName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStyleColorName(int idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetStateStorage(__IntPtr storage);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetStateStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetStateStorage();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildFrame(uint id, global::DearImguiSharp.ImVec2.__Internal size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndChildFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndChildFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcTextSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcTextSize(__IntPtr pOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_double_hash, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertU32ToFloat4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertU32ToFloat4(__IntPtr pOut, uint @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertFloat4ToU32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ColorConvertFloat4ToU32(global::DearImguiSharp.ImVec4.__Internal @in);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertRGBtoHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertRGBtoHSV(float r, float g, float b, float* out_h, float* out_s, float* out_v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorConvertHSVtoRGB", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorConvertHSVtoRGB(float h, float s, float v, float* out_r, float* out_g, float* out_b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyDown(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyPressed", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyPressed(int key, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyReleased(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyPressedAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyPressedAmount(int key, float repeat_delay, float rate);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetKeyName(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextFrameWantCaptureKeyboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDown(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseClicked(int button, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseReleased", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseReleased(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDoubleClicked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDoubleClicked(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseClickedCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMouseClickedCount(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseHoveringRect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseHoveringRect(global::DearImguiSharp.ImVec2.__Internal r_min, global::DearImguiSharp.ImVec2.__Internal r_max, bool clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMousePosValid", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMousePosValid(__IntPtr mouse_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsAnyMouseDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsAnyMouseDown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMousePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePos(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMousePosOnOpeningCurrentPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMousePosOnOpeningCurrentPopup(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDragging", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDragging(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetMouseDragDelta(__IntPtr pOut, int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igResetMouseDragDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ResetMouseDragDelta(int button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMouseCursor();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetMouseCursor(int cursor_type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextFrameWantCaptureMouse", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextFrameWantCaptureMouse(bool want_capture_mouse);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetClipboardText();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetClipboardText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetClipboardText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLoadIniSettingsFromDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLoadIniSettingsFromMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LoadIniSettingsFromMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_data, IntPtr ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSaveIniSettingsToDisk", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SaveIniSettingsToDisk([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string ini_filename);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSaveIniSettingsToMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr SaveIniSettingsToMemory(IntPtr* out_ini_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugTextEncoding", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugTextEncoding([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugCheckVersionAndDataLayout", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DebugCheckVersionAndDataLayout([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetAllocatorFunctions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetAllocatorFunctions(__IntPtr alloc_func, __IntPtr free_func, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetAllocatorFunctions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetAllocatorFunctions(__IntPtr p_alloc_func, __IntPtr p_free_func, __IntPtr* p_user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMemAlloc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr MemAlloc(IntPtr size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMemFree", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MemFree(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetPlatformIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetPlatformIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdatePlatformWindows", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdatePlatformWindows();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderPlatformWindowsDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderPlatformWindowsDefault(__IntPtr platform_render_arg, __IntPtr renderer_render_arg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDestroyPlatformWindows", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DestroyPlatformWindows();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindViewportByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindViewportByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindViewportByPlatformHandle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindViewportByPlatformHandle(__IntPtr platform_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_ImGuiStyle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleImGuiStyle();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyle_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyle_ScaleAllSizes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyleScaleAllSizes(__IntPtr self, float scale_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddKeyEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddKeyEvent(__IntPtr self, int key, bool down);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddKeyAnalogEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddKeyAnalogEvent(__IntPtr self, int key, bool down, float v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMousePosEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMousePosEvent(__IntPtr self, float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMouseButtonEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMouseButtonEvent(__IntPtr self, int button, bool down);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMouseWheelEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMouseWheelEvent(__IntPtr self, float wh_x, float wh_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddMouseViewportEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddMouseViewportEvent(__IntPtr self, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddFocusEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddFocusEvent(__IntPtr self, bool focused);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharacter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacter(__IntPtr self, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharacterUTF16", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharacterUTF16(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_AddInputCharactersUTF8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_AddInputCharactersUTF8(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_SetKeyEventNativeData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_SetKeyEventNativeData(__IntPtr self, int key, int native_keycode, int native_scancode, int native_legacy_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_SetAppAcceptingEvents", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_SetAppAcceptingEvents(__IntPtr self, bool accepting_events);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ClearInputCharacters", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_ClearInputCharacters(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ClearInputKeys", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_ClearInputKeys(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_ImGuiIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiIO_ImGuiIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiIO_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiIO_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_ImGuiInputTextCallbackData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputTextCallbackDataImGuiInputTextCallbackData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_DeleteChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataDeleteChars(__IntPtr self, int pos, int bytes_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_InsertChars", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataInsertChars(__IntPtr self, int pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_SelectAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataSelectAll(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_ClearSelection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextCallbackDataClearSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextCallbackData_HasSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiInputTextCallbackDataHasSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowClass_ImGuiWindowClass", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiWindowClassImGuiWindowClass();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowClass_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowClass_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_ImGuiPayload", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPayloadImGuiPayload();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayload_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPayloadClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsDataType", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDataType(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsPreview", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsPreview(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPayload_IsDelivery", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiPayloadIsDelivery(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSortSpecs_ImGuiTableColumnSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumnSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSortSpecs_ImGuiTableSortSpecs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSortSpecsImGuiTableSortSpecs();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSortSpecs_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableSortSpecs_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOnceUponAFrame_ImGuiOnceUponAFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOnceUponAFrameImGuiOnceUponAFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOnceUponAFrame_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOnceUponAFrame_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_ImGuiTextFilter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextFilterImGuiTextFilter([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string default_filter);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Draw", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterDraw(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_PassFilter", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterPassFilter(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Build", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextFilterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextFilter_IsActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextFilterIsActive(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_ImGuiTextRange_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_ImGuiTextRange_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextRangeImGuiTextRangeStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _b, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string _e);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextRange_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextRange_split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextRange_split(__IntPtr self, sbyte separator, __IntPtr @out);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_ImGuiTextBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBufferImGuiTextBuffer();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_begin(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_end", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_end(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_size", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiTextBuffer_size(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_empty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiTextBuffer_empty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_clear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_reserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_reserve(__IntPtr self, int capacity);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_c_str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTextBuffer_c_str(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTextBuffer_append", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTextBuffer_append(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStoragePair_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStoragePair_ImGuiStoragePair_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiStorageGetInt(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetInt(__IntPtr self, uint key, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetBool", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiStorageGetBool(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetBool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetBool(__IntPtr self, uint key, bool val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiStorageGetFloat(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetFloat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetFloat(__IntPtr self, uint key, float val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStorageGetVoidPtr(__IntPtr self, uint key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetVoidPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetVoidPtr(__IntPtr self, uint key, __IntPtr val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetIntRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int* ImGuiStorageGetIntRef(__IntPtr self, uint key, int default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetBoolRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern bool* ImGuiStorageGetBoolRef(__IntPtr self, uint key, bool default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetFloatRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float* ImGuiStorageGetFloatRef(__IntPtr self, uint key, float default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_GetVoidPtrRef", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr* ImGuiStorageGetVoidPtrRef(__IntPtr self, uint key, __IntPtr default_val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_SetAllInt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageSetAllInt(__IntPtr self, int val);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStorage_BuildSortByKey", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStorageBuildSortByKey(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_ImGuiListClipper", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiListClipperImGuiListClipper();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipper_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_Begin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperBegin(__IntPtr self, int items_count, float items_height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_End", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperEnd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_Step", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiListClipperStep(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipper_ForceDisplayRangeByIndices", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperForceDisplayRangeByIndices(__IntPtr self, int item_min, int item_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColor_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorFloat(float r, float g, float b, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorVec4(global::DearImguiSharp.ImVec4.__Internal col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorInt(int r, int g, int b, int a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_ImColor_U32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImColorImColorU32(uint rgba);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_SetHSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorSetHSV(__IntPtr self, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImColor_HSV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImColorHSV(__IntPtr pOut, float h, float s, float v, float a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_ImDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawCmdImDrawCmd();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawCmd_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawCmd_GetTexID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawCmdGetTexID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_ImDrawListSplitter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListSplitterImDrawListSplitter();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitter_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Split", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSplit(__IntPtr self, __IntPtr draw_list, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_Merge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterMerge(__IntPtr self, __IntPtr draw_list);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSplitter_SetCurrentChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSplitterSetCurrentChannel(__IntPtr self, __IntPtr draw_list, int channel_idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ImDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListImDrawList(__IntPtr shared_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawList_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal clip_rect_min, global::DearImguiSharp.ImVec2.__Internal clip_rect_max, bool intersect_with_current_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushClipRectFullScreen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushClipRectFullScreen(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PopClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PushTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPushTextureID(__IntPtr self, __IntPtr texture_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PopTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_GetClipRectMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMin(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_GetClipRectMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListGetClipRectMax(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddLine", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddLine(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col, float rounding, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRectFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddRectFilledMultiColor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddRectFilledMultiColor(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuad(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddQuadFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddQuadFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddTriangle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangle(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddTriangleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTriangleFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCircle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircle(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCircleFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCircleFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddNgon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgon(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddNgonFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddNgonFilled(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, uint col, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddText_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextVec2(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddText_FontPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddTextFontPtr(__IntPtr self, __IntPtr font, float font_size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, __IntPtr cpu_fine_clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddPolyline", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddPolyline(__IntPtr self, __IntPtr points, int num_points, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddConvexPolyFilled", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddConvexPolyFilled(__IntPtr self, __IntPtr points, int num_points, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddBezierCubic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierCubic(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddBezierQuadratic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddBezierQuadratic(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, uint col, float thickness, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImage(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, global::DearImguiSharp.ImVec2.__Internal uv_min, global::DearImguiSharp.ImVec2.__Internal uv_max, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImageQuad", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageQuad(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, global::DearImguiSharp.ImVec2.__Internal uv1, global::DearImguiSharp.ImVec2.__Internal uv2, global::DearImguiSharp.ImVec2.__Internal uv3, global::DearImguiSharp.ImVec2.__Internal uv4, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddImageRounded", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddImageRounded(__IntPtr self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, global::DearImguiSharp.ImVec2.__Internal uv_min, global::DearImguiSharp.ImVec2.__Internal uv_max, uint col, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathClear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathLineTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathLineToMergeDuplicate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathLineToMergeDuplicate(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathFillConvex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathFillConvex(__IntPtr self, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathStroke", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathStroke(__IntPtr self, uint col, int flags, float thickness);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathArcTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathArcToFast", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToFast(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, int a_min_of_12, int a_max_of_12);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathBezierCubicCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierCubicCurveTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathBezierQuadraticCurveTo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathBezierQuadraticCurveTo(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PathRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal rect_min, global::DearImguiSharp.ImVec2.__Internal rect_max, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddCallback(__IntPtr self, __IntPtr callback, __IntPtr callback_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_AddDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListAddDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_CloneOutput", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListCloneOutput(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsSplit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSplit(__IntPtr self, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsMerge", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsMerge(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_ChannelsSetCurrent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListChannelsSetCurrent(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimReserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimReserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimUnreserve", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimUnreserve(__IntPtr self, int idx_count, int vtx_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRect(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimRectUV(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal uv_a, global::DearImguiSharp.ImVec2.__Internal uv_b, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimQuadUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimQuadUV(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c, global::DearImguiSharp.ImVec2.__Internal d, global::DearImguiSharp.ImVec2.__Internal uv_a, global::DearImguiSharp.ImVec2.__Internal uv_b, global::DearImguiSharp.ImVec2.__Internal uv_c, global::DearImguiSharp.ImVec2.__Internal uv_d, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimWriteVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteVtx(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimWriteIdx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimWriteIdx(__IntPtr self, ushort idx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList_PrimVtx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPrimVtx(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal uv, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__ResetForNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListResetForNewFrame(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PopUnusedDrawCmd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPopUnusedDrawCmd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__TryMergeDrawCmds", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListTryMergeDrawCmds(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedClipRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedTextureID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedTextureID(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__OnChangedVtxOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListOnChangedVtxOffset(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__CalcCircleAutoSegmentCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImDrawListCalcCircleAutoSegmentCount(__IntPtr self, float radius);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PathArcToFastEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToFastEx(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, int a_min_sample, int a_max_sample, int a_step);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawList__PathArcToN", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListPathArcToN(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal center, float radius, float a_min, float a_max, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_ImDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawDataImDrawData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_DeIndexAllBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataDeIndexAllBuffers(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawData_ScaleClipRects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataScaleClipRects(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal fb_scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontConfig_ImFontConfig", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontConfigImFontConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontConfig_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontConfig_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_ImFontGlyphRangesBuilder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilder_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_GetBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontGlyphRangesBuilderGetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_SetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderSetBit(__IntPtr self, IntPtr n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddChar(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddText(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_AddRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderAddRanges(__IntPtr self, ushort* ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontGlyphRangesBuilder_BuildRanges", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGlyphRangesBuilderBuildRanges(__IntPtr self, __IntPtr out_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_ImFontAtlasCustomRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasCustomRectImFontAtlasCustomRect();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCustomRect_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlasCustomRect_IsPacked", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasCustomRectIsPacked(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ImFontAtlas", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasImFontAtlas();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlas_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFont(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontDefault(__IntPtr self, __IntPtr font_cfg);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromFileTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromFileTTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryTTF(__IntPtr self, __IntPtr font_data, int font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedTTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedTTF(__IntPtr self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddFontFromMemoryCompressedBase85TTF", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string compressed_font_data_base85, float size_pixels, __IntPtr font_cfg, ushort* glyph_ranges);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearInputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearInputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearTexData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearTexData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_ClearFonts", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClearFonts(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_Build", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasBuild(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetTexDataAsAlpha8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsAlpha8(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetTexDataAsRGBA32", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasGetTexDataAsRGBA32(__IntPtr self, byte** out_pixels, int* out_width, int* out_height, int* out_bytes_per_pixel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_IsBuilt", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasIsBuilt(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_SetTexID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasSetTexID(__IntPtr self, __IntPtr id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesDefault", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesDefault(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesKorean", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesKorean(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesJapanese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesJapanese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseFull", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseFull(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesCyrillic", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesCyrillic(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesThai", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesThai(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetGlyphRangesVietnamese", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImFontAtlasGetGlyphRangesVietnamese(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddCustomRectRegular", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectRegular(__IntPtr self, int width, int height);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_AddCustomRectFontGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFontAtlasAddCustomRectFontGlyph(__IntPtr self, __IntPtr font, ushort id, int width, int height, float advance_x, global::DearImguiSharp.ImVec2.__Internal offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetCustomRectByIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasGetCustomRectByIndex(__IntPtr self, int index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_CalcCustomRectUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasCalcCustomRectUV(__IntPtr self, __IntPtr rect, __IntPtr out_uv_min, __IntPtr out_uv_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFontAtlas_GetMouseCursorTexData", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontAtlasGetMouseCursorTexData(__IntPtr self, int cursor, __IntPtr out_offset, __IntPtr out_size, global::DearImguiSharp.ImVec2.__Internal[] out_uv_border, global::DearImguiSharp.ImVec2.__Internal[] out_uv_fill);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_ImFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontImFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFont_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_FindGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyph(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_FindGlyphNoFallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontFindGlyphNoFallback(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GetCharAdvance", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFontGetCharAdvance(__IntPtr self, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_IsLoaded", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsLoaded(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GetDebugName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontGetDebugName(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_CalcTextSizeA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontCalcTextSizeA(__IntPtr pOut, __IntPtr self, float size, float max_width, float wrap_width, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, sbyte** remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_CalcWordWrapPositionA", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontCalcWordWrapPositionA(__IntPtr self, float scale, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_RenderChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderChar(__IntPtr self, __IntPtr draw_list, float size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, ushort c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_RenderText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontRenderText(__IntPtr self, __IntPtr draw_list, float size, global::DearImguiSharp.ImVec2.__Internal pos, uint col, global::DearImguiSharp.ImVec4.__Internal clip_rect, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width, bool cpu_fine_clip);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_BuildLookupTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontBuildLookupTable(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_ClearOutputData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontClearOutputData(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_GrowIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontGrowIndex(__IntPtr self, int new_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_AddGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddGlyph(__IntPtr self, __IntPtr src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_AddRemapChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAddRemapChar(__IntPtr self, ushort dst, ushort src, bool overwrite_dst);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_SetGlyphVisible", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontSetGlyphVisible(__IntPtr self, ushort c, bool visible);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImFont_IsGlyphRangeUnused", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFontIsGlyphRangeUnused(__IntPtr self, uint c_begin, uint c_last);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_ImGuiViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiViewportImGuiViewport();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewport_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_GetCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewport_GetWorkCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportGetWorkCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformIO_ImGuiPlatformIO", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPlatformIO_ImGuiPlatformIO();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformIO_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPlatformIO_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformMonitor_ImGuiPlatformMonitor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPlatformMonitorImGuiPlatformMonitor();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformMonitor_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPlatformMonitor_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformImeData_ImGuiPlatformImeData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPlatformImeDataImGuiPlatformImeData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPlatformImeData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPlatformImeData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetKeyIndex(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImHashData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImHashData(__IntPtr data, IntPtr data_size, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImHashStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImHashStr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string data, IntPtr data_size, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImQsort", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImQsort(__IntPtr @base, IntPtr count, IntPtr size_of_element, __IntPtr compare_func);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAlphaBlendColors", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImAlphaBlendColors(uint col_a, uint col_b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsPowerOfTwo_Int", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsPowerOfTwoInt(int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsPowerOfTwo_U64", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsPowerOfTwoU64(ulong v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImUpperPowerOfTwo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImUpperPowerOfTwo(int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStricmp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStricmp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrnicmp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStrnicmp([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str1, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str2, IntPtr count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrncpy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImStrncpy(sbyte* dst, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src, IntPtr count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrdup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImStrdup([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrdupcpy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImStrdupcpy(sbyte* dst, IntPtr* p_dst_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrchrRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStrchrRange([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end, sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrlenW", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImStrlenW(ushort* str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStreolRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStreolRange([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrbolW", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ushort* ImStrbolW(ushort* buf_mid_line, ushort* buf_begin);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStristr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStristr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string haystack, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string haystack_end, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string needle, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string needle_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrTrimBlanks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImStrTrimBlanks(sbyte* str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImStrSkipBlank", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImStrSkipBlank([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImCharIsBlankA", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImCharIsBlankA(sbyte c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImCharIsBlankW", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImCharIsBlankW(uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFormatString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImFormatString(sbyte* buf, IntPtr buf_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFormatStringToTempBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFormatStringToTempBuffer(sbyte** out_buf, sbyte** out_buf_end, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatFindStart", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatFindStart([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatFindEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatFindEnd([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatTrimDecorations", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatTrimDecorations([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, sbyte* buf, IntPtr buf_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatSanitizeForPrinting", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImParseFormatSanitizeForPrinting([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt_in, sbyte* fmt_out, IntPtr fmt_out_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatSanitizeForScanning", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImParseFormatSanitizeForScanning([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt_in, sbyte* fmt_out, IntPtr fmt_out_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImParseFormatPrecision", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImParseFormatPrecision([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int default_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCharToUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImTextCharToUtf8(sbyte[] out_buf, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextStrToUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextStrToUtf8(sbyte* out_buf, int out_buf_size, ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCharFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCharFromUtf8(uint* out_char, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextStrFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextStrFromUtf8(ushort* out_buf, int out_buf_size, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end, sbyte** in_remaining);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountCharsFromUtf8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountCharsFromUtf8([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountUtf8BytesFromChar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountUtf8BytesFromChar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTextCountUtf8BytesFromStr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImTextCountUtf8BytesFromStr(ushort* in_text, ushort* in_text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileOpen", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFileOpen([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileClose", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImFileClose(__IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileGetSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileGetSize(__IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileRead", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileRead(__IntPtr data, ulong size, ulong count, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileWrite", CallingConvention = __CallingConvention.Cdecl)]
            public static extern ulong ImFileWrite(__IntPtr data, ulong size, ulong count, __IntPtr file);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFileLoadToMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFileLoadToMemory([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string filename, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string mode, IntPtr* out_file_size, int padding_bytes);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImPow_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImPowFloat(float x, float y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImPow_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImPow_double(double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLog_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLogFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLog_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImLog_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImAbsInt(int x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImAbsFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImAbs_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImAbs_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSign_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImSignFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSign_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImSign_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRsqrt_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRsqrtFloat(float x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRsqrt_double", CallingConvention = __CallingConvention.Cdecl)]
            public static extern double ImRsqrt_double(double x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMin(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal lhs, global::DearImguiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMax", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMax(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal lhs, global::DearImguiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImClamp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImClamp(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal v, global::DearImguiSharp.ImVec2.__Internal mn, global::DearImguiSharp.ImVec2.__Internal mx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec2Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec2Float(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec2Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec2Vec2(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLerp_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLerpVec4(__IntPtr pOut, global::DearImguiSharp.ImVec4.__Internal a, global::DearImguiSharp.ImVec4.__Internal b, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImSaturate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImSaturate(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLengthSqr_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLengthSqrVec2(global::DearImguiSharp.ImVec2.__Internal lhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLengthSqr_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLengthSqrVec4(global::DearImguiSharp.ImVec4.__Internal lhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImInvLength", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImInvLength(global::DearImguiSharp.ImVec2.__Internal lhs, float fail_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloor_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFloorFloat(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloorSigned_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImFloorSignedFloat(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloor_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFloorVec2(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFloorSigned_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFloorSignedVec2(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImModPositive", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImModPositive(int a, int b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImDot", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImDot(global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImRotate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRotate(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal v, float cos_a, float sin_a);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLinearSweep", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImLinearSweep(float current, float target, float speed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImMul", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImMul(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal lhs, global::DearImguiSharp.ImVec2.__Internal rhs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImIsFloatAboveGuaranteedIntegerPrecision", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImIsFloatAboveGuaranteedIntegerPrecision(float f);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicCalc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicCalc(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicClosestPoint(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, global::DearImguiSharp.ImVec2.__Internal p, int num_segments);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierCubicClosestPointCasteljau", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierCubicClosestPointCasteljau(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, global::DearImguiSharp.ImVec2.__Internal p4, global::DearImguiSharp.ImVec2.__Internal p, float tess_tol);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBezierQuadraticCalc", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBezierQuadraticCalc(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal p1, global::DearImguiSharp.ImVec2.__Internal p2, global::DearImguiSharp.ImVec2.__Internal p3, float t);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImLineClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImLineClosestPoint(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleContainsPoint", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImTriangleContainsPoint(global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c, global::DearImguiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleClosestPoint", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImTriangleClosestPoint(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c, global::DearImguiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleBarycentricCoords", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImTriangleBarycentricCoords(global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c, global::DearImguiSharp.ImVec2.__Internal p, float* out_u, float* out_v, float* out_w);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImTriangleArea", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImTriangleArea(global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImGetDirQuadrantFromDelta", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGetDirQuadrantFromDelta(float dx, float dy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_ImVec1_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec1ImVec1Nil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec1_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec1_ImVec1_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec1ImVec1Float(float _x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ihImVec2ihNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVec2ih_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVec2ih_ImVec2ih_short", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVec2ihImVec2ih_short(short _x, short _y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRect_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectVec2(global::DearImguiSharp.ImVec2.__Internal min, global::DearImguiSharp.ImVec2.__Internal max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Vec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectVec4(global::DearImguiSharp.ImVec4.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ImRect_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImRectImRectFloat(float x1, float y1, float x2, float y2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetCenter", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetCenter(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetSize(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetWidth(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetArea", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImRectGetArea(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetTL", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetTL(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetTR", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetTR(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetBL", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetBL(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_GetBR", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectGetBR(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Contains_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectContainsVec2(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Contains_Rect", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectContainsRect(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Overlaps", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectOverlaps(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Add_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectAddVec2(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Add_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectAddRect(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Expand_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectExpandFloat(__IntPtr self, float amount);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Expand_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectExpandVec2(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal amount);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Translate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslate(__IntPtr self, global::DearImguiSharp.ImVec2.__Internal d);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_TranslateX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslateX(__IntPtr self, float dx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_TranslateY", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectTranslateY(__IntPtr self, float dy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ClipWith", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectClipWith(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ClipWithFull", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectClipWithFull(__IntPtr self, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_Floor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectFloor(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_IsInverted", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImRectIsInverted(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImRect_ToVec4", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImRectToVec4(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArrayTestBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImBitArrayTestBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArrayClearBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArrayClearBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArraySetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArraySetBit(uint* arr, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImBitArraySetBitRange", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitArraySetBitRange(uint* arr, int n, int n2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_Create", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorCreate(__IntPtr self, int sz);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_TestBit", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImBitVectorTestBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_SetBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorSetBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImBitVector_ClearBit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImBitVectorClearBit(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_ImDrawListSharedData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImDrawListSharedDataImDrawListSharedData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSharedData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawListSharedData_SetCircleTessellationMaxError", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawListSharedDataSetCircleTessellationMaxError(__IntPtr self, float max_error);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_GetDrawListCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImDrawDataBuilderGetDrawListCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImDrawDataBuilder_FlattenIntoSingleLayer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImDrawDataBuilderFlattenIntoSingleLayer(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModInt(int idx, int v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStyleMod_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Float", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModFloat(int idx, float v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStyleMod_ImGuiStyleMod_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStyleModImGuiStyleModVec2(int idx, global::DearImguiSharp.ImVec2.__Internal v);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiComboPreviewData_ImGuiComboPreviewData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiComboPreviewDataImGuiComboPreviewData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiComboPreviewData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiComboPreviewData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_ImGuiMenuColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiMenuColumnsImGuiMenuColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumns_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_Update", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumnsUpdate(__IntPtr self, float spacing, bool window_reappearing);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_DeclColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiMenuColumnsDeclColumns(__IntPtr self, float w_icon, float w_label, float w_shortcut, float w_mark);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMenuColumns_CalcNextTotalWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMenuColumnsCalcNextTotalWidth(__IntPtr self, bool update_offsets);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ImGuiInputTextState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputTextStateImGuiInputTextState();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextState_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearText(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearFreeMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearFreeMemory(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetUndoAvailCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetUndoAvailCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetRedoAvailCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetRedoAvailCount(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_OnKeyPressed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateOnKeyPressed(__IntPtr self, int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_CursorAnimReset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateCursorAnimReset(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_CursorClamp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateCursorClamp(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_HasSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiInputTextStateHasSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_ClearSelection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateClearSelection(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetCursorPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetCursorPos(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetSelectionStart", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetSelectionStart(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_GetSelectionEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiInputTextStateGetSelectionEnd(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputTextState_SelectAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputTextStateSelectAll(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPopupData_ImGuiPopupData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPopupDataImGuiPopupData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPopupData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPopupData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_ImGuiNextWindowData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNextWindowDataImGuiNextWindowData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextWindowData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextWindowData_ClearFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextWindowDataClearFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_ImGuiNextItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNextItemDataImGuiNextItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNextItemData_ClearFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNextItemDataClearFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiLastItemData_ImGuiLastItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiLastItemDataImGuiLastItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiLastItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiLastItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_ImGuiStackSizes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackSizesImGuiStackSizes();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizes_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_SetToCurrentState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizesSetToCurrentState(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackSizes_CompareWithCurrentState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackSizesCompareWithCurrentState(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexPtr(__IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiPtrOrIndex_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiPtrOrIndex_ImGuiPtrOrIndex_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputEvent_ImGuiInputEvent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiInputEventImGuiInputEvent();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiInputEvent_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiInputEvent_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperRange_FromIndices", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperRangeFromIndices(__IntPtr @return, int min, int max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperRange_FromPositions", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperRangeFromPositions(__IntPtr @return, float y1, float y2, int off_min, int off_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_ImGuiListClipperData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiListClipperDataImGuiListClipperData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiListClipperData_Reset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiListClipperDataReset(__IntPtr self, __IntPtr clipper);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_ImGuiNavItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiNavItemDataImGuiNavItemData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNavItemData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiNavItemData_Clear", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiNavItemDataClear(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumnData_ImGuiOldColumnData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOldColumnDataImGuiOldColumnData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumnData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOldColumnData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumns_ImGuiOldColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiOldColumnsImGuiOldColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiOldColumns_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiOldColumns_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_ImGuiDockNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiDockNodeImGuiDockNode(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiDockNode_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsRootNode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsRootNode(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsDockSpace", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsDockSpace(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsFloatingNode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsFloatingNode(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsCentralNode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsCentralNode(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsHiddenTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsHiddenTabBar(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsNoTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsNoTabBar(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsSplitNode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsSplitNode(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsLeafNode", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsLeafNode(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_IsEmpty", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiDockNodeIsEmpty(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiDockNodeRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_SetLocalFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiDockNodeSetLocalFlags(__IntPtr self, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockNode_UpdateMergedFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiDockNodeUpdateMergedFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockContext_ImGuiDockContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiDockContextImGuiDockContext();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiDockContext_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiDockContext_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_ImGuiViewportP", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiViewportP_ImGuiViewportP();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_ClearRequestFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_ClearRequestFlags(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_CalcWorkRectPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_CalcWorkRectPos(__IntPtr pOut, __IntPtr self, global::DearImguiSharp.ImVec2.__Internal off_min);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_CalcWorkRectSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_CalcWorkRectSize(__IntPtr pOut, __IntPtr self, global::DearImguiSharp.ImVec2.__Internal off_min, global::DearImguiSharp.ImVec2.__Internal off_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_UpdateWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_UpdateWorkRect(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetMainRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetMainRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetWorkRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiViewportP_GetBuildWorkRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiViewportP_GetBuildWorkRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_ImGuiWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiWindowSettingsImGuiWindowSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindowSettings_GetName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern sbyte* ImGuiWindowSettingsGetName(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiSettingsHandler_ImGuiSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiSettingsHandlerImGuiSettingsHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiSettingsHandler_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiSettingsHandler_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMetricsConfig_ImGuiMetricsConfig", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiMetricsConfigImGuiMetricsConfig();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiMetricsConfig_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiMetricsConfig_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackLevelInfo_ImGuiStackLevelInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackLevelInfoImGuiStackLevelInfo();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackLevelInfo_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackLevelInfo_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackTool_ImGuiStackTool", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiStackToolImGuiStackTool();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiStackTool_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiStackTool_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContextHook_ImGuiContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiContextHookImGuiContextHook();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContextHook_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiContextHook_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContext_ImGuiContext", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiContextImGuiContext(__IntPtr shared_font_atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiContext_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiContext_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_ImGuiWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiWindowImGuiWindow(__IntPtr context, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindow_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Str", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Str(__IntPtr self, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Ptr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Ptr(__IntPtr self, __IntPtr ptr);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetID_Int", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetID_Int(__IntPtr self, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_GetIDFromRectangle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint ImGuiWindowGetIDFromRectangle(__IntPtr self, __IntPtr r_abs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_CalcFontSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowCalcFontSize(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_TitleBarHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowTitleBarHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_TitleBarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowTitleBarRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_MenuBarHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiWindowMenuBarHeight(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiWindow_MenuBarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiWindowMenuBarRect(__IntPtr pOut, __IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabItem_ImGuiTabItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabItemImGuiTabItem();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabItem_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTabItem_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_ImGuiTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabBarImGuiTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTabBar_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_GetTabOrder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiTabBarGetTabOrder(__IntPtr self, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTabBar_GetTabName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTabBarGetTabName(__IntPtr self, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumn_ImGuiTableColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnImGuiTableColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumn_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumn_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableInstanceData_ImGuiTableInstanceData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableInstanceDataImGuiTableInstanceData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableInstanceData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableInstanceData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTable_ImGuiTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableImGuiTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTable_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTable_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableTempData_ImGuiTableTempData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableTempDataImGuiTableTempData();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableTempData_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableTempData_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSettings_ImGuiTableColumnSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableColumnSettingsImGuiTableColumnSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableColumnSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableColumnSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_ImGuiTableSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSettingsImGuiTableSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiTableSettings_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGuiTableSettings_GetColumnSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiTableSettingsGetColumnSettings(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentWindowRead", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentWindowRead();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentWindow();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowByName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowByName([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateWindowParentAndRootLinks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateWindowParentAndRootLinks(__IntPtr window, int flags, __IntPtr parent_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcWindowNextAutoFitSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcWindowNextAutoFitSize(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowChildOf", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowChildOf(__IntPtr window, __IntPtr potential_parent, bool popup_hierarchy, bool dock_hierarchy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowWithinBeginStackOf", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowWithinBeginStackOf(__IntPtr window, __IntPtr potential_parent);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowAbove", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowAbove(__IntPtr potential_above, __IntPtr potential_below);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsWindowNavFocusable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsWindowNavFocusable(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowPos_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowPosWindowPtr(__IntPtr window, global::DearImguiSharp.ImVec2.__Internal pos, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowSize_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowSizeWindowPtr(__IntPtr window, global::DearImguiSharp.ImVec2.__Internal size, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowCollapsed_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowCollapsedWindowPtr(__IntPtr window, bool collapsed, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowHitTestHole", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowHitTestHole(__IntPtr window, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igWindowRectAbsToRel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void WindowRectAbsToRel(__IntPtr pOut, __IntPtr window, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igWindowRectRelToAbs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void WindowRectRelToAbs(__IntPtr pOut, __IntPtr window, __IntPtr r);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFocusWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FocusWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFocusTopMostWindowUnderOne", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FocusTopMostWindowUnderOne(__IntPtr under_this_window, __IntPtr ignore_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToFocusFront", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToFocusFront(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayFront", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayFront(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayBack", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayBack(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBringWindowToDisplayBehind", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BringWindowToDisplayBehind(__IntPtr window, __IntPtr above_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowDisplayIndex", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int FindWindowDisplayIndex(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBottomMostVisibleWindowWithinBeginStack", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindBottomMostVisibleWindowWithinBeginStack(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCurrentFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetDefaultFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetDefaultFont();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetForegroundDrawList_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetForegroundDrawListWindowPtr(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInitialize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Initialize();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateInputEvents", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateInputEvents(bool trickle_fast_inputs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateHoveredWindowAndCaptureFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateHoveredWindowAndCaptureFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStartMouseMovingWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StartMouseMovingWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igStartMouseMovingWindowOrNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void StartMouseMovingWindowOrNode(__IntPtr window, __IntPtr node, bool undock_floating_node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateMouseMovingWindowNewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateMouseMovingWindowNewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igUpdateMouseMovingWindowEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void UpdateMouseMovingWindowEndFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAddContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint AddContextHook(__IntPtr context, __IntPtr hook);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRemoveContextHook", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RemoveContextHook(__IntPtr context, uint hook_to_remove);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCallContextHooks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CallContextHooks(__IntPtr context, global::DearImguiSharp.ImGuiContextHookType type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTranslateWindowsInViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TranslateWindowsInViewport(__IntPtr viewport, global::DearImguiSharp.ImVec2.__Internal old_pos, global::DearImguiSharp.ImVec2.__Internal new_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScaleWindowsInViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScaleWindowsInViewport(__IntPtr viewport, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDestroyPlatformWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DestroyPlatformWindow(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowViewport(__IntPtr window, __IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetCurrentViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetCurrentViewport(__IntPtr window, __IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetViewportPlatformMonitor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetViewportPlatformMonitor(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindHoveredViewportFromPlatformWindowStack", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindHoveredViewportFromPlatformWindowStack(global::DearImguiSharp.ImVec2.__Internal mouse_platform_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkIniSettingsDirty_Nil", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkIniSettingsDirtyNil();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkIniSettingsDirty_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkIniSettingsDirtyWindowPtr(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearIniSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearIniSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCreateNewWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr CreateNewWindowSettings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindWindowSettings(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindOrCreateWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindOrCreateWindowSettings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igAddSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void AddSettingsHandler(__IntPtr handler);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRemoveSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RemoveSettingsHandler([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type_name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindSettingsHandler([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string type_name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNextWindowScroll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNextWindowScroll(global::DearImguiSharp.ImVec2.__Internal scroll);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollX_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollX_WindowPtr(__IntPtr window, float scroll_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollY_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollY_WindowPtr(__IntPtr window, float scroll_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosX_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosX_WindowPtr(__IntPtr window, float local_x, float center_x_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetScrollFromPosY_WindowPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetScrollFromPosY_WindowPtr(__IntPtr window, float local_y, float center_y_ratio);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToItem(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToRect(__IntPtr window, __IntPtr rect, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToRectEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToRectEx(__IntPtr pOut, __IntPtr window, __IntPtr rect, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollToBringRectIntoView", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ScrollToBringRectIntoView(__IntPtr window, __IntPtr rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetItemID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemStatusFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetItemStatusFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetItemFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetItemFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetActiveID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveID(uint id, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetFocusID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetFocusID(uint id, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearActiveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearActiveID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetHoveredID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetHoveredID();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetHoveredID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetHoveredID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igKeepAliveID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void KeepAliveID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMarkItemEdited", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void MarkItemEdited(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushOverrideID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetIDWithSeed", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetIDWithSeed([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_begin, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id_end, uint seed);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemSize_Vec2", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ItemSizeVec2(global::DearImguiSharp.ImVec2.__Internal size, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemSize_Rect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ItemSizeRect(__IntPtr bb, float text_baseline_y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemAdd", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ItemAdd(__IntPtr bb, uint id, __IntPtr nav_bb, int extra_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igItemHoverable", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ItemHoverable(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsClippedEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsClippedEx(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetLastItemData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetLastItemData(uint item_id, int in_flags, int status_flags, __IntPtr item_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcItemSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void CalcItemSize(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal size, float default_w, float default_h);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcWrapWidthForPos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float CalcWrapWidthForPos(global::DearImguiSharp.ImVec2.__Internal pos, float wrap_pos_x);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushMultiItemsWidths", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushMultiItemsWidths(int components, float width_full);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsItemToggledSelection", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsItemToggledSelection();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetContentRegionMaxAbs", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetContentRegionMaxAbs(__IntPtr pOut);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShrinkWidths", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShrinkWidths(__IntPtr items, int count, float width_excess);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushItemFlag", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushItemFlag(int option, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopItemFlag", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopItemFlag();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogBegin", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogBegin(global::DearImguiSharp.ImGuiLogType type, int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogToBuffer", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogToBuffer(int auto_open_depth);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogRenderedText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogRenderedText(__IntPtr ref_pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogSetNextTextDecoration", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogSetNextTextDecoration([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string prefix, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string suffix);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginChildEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginChildEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint id, global::DearImguiSharp.ImVec2.__Internal size_arg, bool border, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igOpenPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void OpenPopupEx(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupToLevel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupsOverWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupsOverWindow(__IntPtr ref_window, bool restore_focus_to_window_under_popup);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClosePopupsExceptModals", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClosePopupsExceptModals();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsPopupOpen_ID", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsPopupOpenID(uint id, int popup_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginPopupEx(uint id, int extra_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTooltipEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginTooltipEx(int tooltip_flags, int extra_window_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetPopupAllowedExtentRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetPopupAllowedExtentRect(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTopMostPopupModal", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetTopMostPopupModal();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetTopMostAndVisiblePopupModal", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetTopMostAndVisiblePopupModal();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBestWindowPosForPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FindBestWindowPosForPopup(__IntPtr pOut, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindBestWindowPosForPopupEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void FindBestWindowPosForPopupEx(__IntPtr pOut, global::DearImguiSharp.ImVec2.__Internal ref_pos, global::DearImguiSharp.ImVec2.__Internal size, int* last_dir, __IntPtr r_outer, __IntPtr r_avoid, global::DearImguiSharp.ImGuiPopupPositionPolicy policy);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginViewportSideBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginViewportSideBar([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, __IntPtr viewport, int dir, float size, int window_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginMenuEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginMenuEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string icon, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igMenuItemEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool MenuItemEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string icon, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string shortcut, bool selected, bool enabled);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginComboPopup", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginComboPopup(uint popup_id, __IntPtr bb, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginComboPreview", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginComboPreview();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndComboPreview", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndComboPreview();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavInitWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavInitWindow(__IntPtr window, bool force_reinit);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavInitRequestApplyResult", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavInitRequestApplyResult();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestButNoResultYet", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool NavMoveRequestButNoResultYet();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestSubmit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestSubmit(int move_dir, int clip_dir, int move_flags, int scroll_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestForward", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestForward(int move_dir, int clip_dir, int move_flags, int scroll_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestResolveWithLastItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestResolveWithLastItem(__IntPtr result);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestCancel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestCancel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestApplyResult", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestApplyResult();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igNavMoveRequestTryWrapping", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void NavMoveRequestTryWrapping(__IntPtr window, int move_flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputName", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetNavInputName(int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetNavInputAmount(int n, global::DearImguiSharp.ImGuiNavReadMode mode);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetNavInputAmount2d", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetNavInputAmount2d(__IntPtr pOut, int dir_sources, global::DearImguiSharp.ImGuiNavReadMode mode, float slow_factor, float fast_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcTypematicRepeatAmount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igActivateItem", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ActivateItem(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNavWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNavWindow(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetNavID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetNavID(uint id, global::DearImguiSharp.ImGuiNavLayer nav_layer, uint focus_scope_id, __IntPtr rect_rel);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushFocusScope(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusedFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusedFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetFocusScope", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetFocusScope();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNamedKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNamedKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsLegacyKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsLegacyKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsGamepadKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsGamepadKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetKeyData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetKeyData(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetItemUsingMouseWheel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetItemUsingMouseWheel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveIdUsingNavAndKeys", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveIdUsingNavAndKeys();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingNavDir", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingNavDir(int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingNavInput", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingNavInput(int input);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsActiveIdUsingKey", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsActiveIdUsingKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetActiveIdUsingKey", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetActiveIdUsingKey(int key);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsMouseDragPastThreshold", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsMouseDragPastThreshold(int button, float lock_threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNavInputDown", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNavInputDown(int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsNavInputTest", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsNavInputTest(int n, global::DearImguiSharp.ImGuiNavReadMode rm);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetMergedModFlags", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int GetMergedModFlags();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsKeyPressedMap", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsKeyPressedMap(int key, bool repeat);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextInitialize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextInitialize(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextShutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextShutdown(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextClearNodes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextClearNodes(__IntPtr ctx, uint root_id, bool clear_settings_refs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextRebuildNodes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextRebuildNodes(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextNewFrameUpdateUndocking", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextNewFrameUpdateUndocking(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextNewFrameUpdateDocking", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextNewFrameUpdateDocking(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextEndFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextEndFrame(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextGenNodeID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockContextGenNodeID(__IntPtr ctx);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextQueueDock", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextQueueDock(__IntPtr ctx, __IntPtr target, __IntPtr target_node, __IntPtr payload, int split_dir, float split_ratio, bool split_outer);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextQueueUndockWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextQueueUndockWindow(__IntPtr ctx, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextQueueUndockNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockContextQueueUndockNode(__IntPtr ctx, __IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockContextCalcDropPosForDocking", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DockContextCalcDropPosForDocking(__IntPtr target, __IntPtr target_node, __IntPtr payload, int split_dir, bool split_outer, __IntPtr out_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeBeginAmendTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DockNodeBeginAmendTabBar(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeEndAmendTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockNodeEndAmendTabBar();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeGetRootNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr DockNodeGetRootNode(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeIsInHierarchyOf", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DockNodeIsInHierarchyOf(__IntPtr node, __IntPtr parent);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeGetDepth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int DockNodeGetDepth(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockNodeGetWindowMenuButtonId", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockNodeGetWindowMenuButtonId(__IntPtr node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowDockNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetWindowDockNode();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowAlwaysWantOwnTabBar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool GetWindowAlwaysWantOwnTabBar(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDocked", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginDocked(__IntPtr window, bool* p_open);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDockableDragDropSource", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginDockableDragDropSource(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDockableDragDropTarget", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginDockableDragDropTarget(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowDock", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowDock(__IntPtr window, uint dock_id, int cond);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderDockWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderDockWindow([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string window_name, uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderGetNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr DockBuilderGetNode(uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderGetCentralNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr DockBuilderGetCentralNode(uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderAddNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockBuilderAddNode(uint node_id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderRemoveNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderRemoveNode(uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderRemoveNodeDockedWindows", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderRemoveNodeDockedWindows(uint node_id, bool clear_settings_refs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderRemoveNodeChildNodes", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderRemoveNodeChildNodes(uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderSetNodePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderSetNodePos(uint node_id, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderSetNodeSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderSetNodeSize(uint node_id, global::DearImguiSharp.ImVec2.__Internal size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderSplitNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint DockBuilderSplitNode(uint node_id, int split_dir, float size_ratio_for_node_at_dir, uint* out_id_at_dir, uint* out_id_at_opposite_dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderCopyDockSpace", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderCopyDockSpace(uint src_dockspace_id, uint dst_dockspace_id, __IntPtr in_window_remap_pairs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderCopyNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderCopyNode(uint src_node_id, uint dst_node_id, __IntPtr out_node_remap_pairs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderCopyWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderCopyWindowSettings([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string src_name, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string dst_name);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDockBuilderFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DockBuilderFinish(uint node_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsDragDropActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsDragDropActive();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginDragDropTargetCustom", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginDragDropTargetCustom(__IntPtr bb, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igClearDragDrop", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ClearDragDrop();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igIsDragDropPayloadBeingAccepted", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool IsDragDropPayloadBeingAccepted();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSetWindowClipRectBeforeSetChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SetWindowClipRectBeforeSetChannel(__IntPtr window, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void BeginColumns([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int count, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igEndColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void EndColumns();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushColumnClipRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushColumnClipRect(int column_index);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPushColumnsBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PushColumnsBackground();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPopColumnsBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void PopColumnsBackground();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnsID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetColumnsID([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindOrCreateColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindOrCreateColumns(__IntPtr window, uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnOffsetFromNorm", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnOffsetFromNorm(__IntPtr columns, float offset_norm);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetColumnNormFromOffset", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GetColumnNormFromOffset(__IntPtr columns, float offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableOpenContextMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableOpenContextMenu(int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidth(int column_n, float width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnSortDirection(int column_n, int sort_direction, bool append_to_sort_specs);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetHoveredColumn", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetHoveredColumn();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetHeaderRowHeight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetHeaderRowHeight();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTablePushBackgroundChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TablePushBackgroundChannel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTablePopBackgroundChannel", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TablePopBackgroundChannel();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetCurrentTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetCurrentTable();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableFindByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableFindByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTableEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTableEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name, uint id, int columns_count, int flags, global::DearImguiSharp.ImVec2.__Internal outer_size, float inner_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginInitMemory", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginInitMemory(__IntPtr table, int columns_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginApplyRequests", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginApplyRequests(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetupDrawChannels", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetupDrawChannels(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateLayout", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateLayout(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateBorders", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateBorders(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableUpdateColumnsWeightFromWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableUpdateColumnsWeightFromWidth(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableDrawBorders", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableDrawBorders(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableDrawContextMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableDrawContextMenu(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableMergeDrawChannels", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableMergeDrawChannels(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetInstanceData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetInstanceData(__IntPtr table, int instance_no);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSortSpecsSanitize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSortSpecsSanitize(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSortSpecsBuild", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSortSpecsBuild(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnNextSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int TableGetColumnNextSortDirection(__IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableFixColumnSortDirection", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableFixColumnSortDirection(__IntPtr table, __IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnWidthAuto", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetColumnWidthAuto(__IntPtr table, __IntPtr column);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginRow(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableEndRow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableEndRow(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableBeginCell", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableBeginCell(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableEndCell", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableEndCell(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetCellBgRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGetCellBgRect(__IntPtr pOut, __IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnName_TablePtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetColumnNameTablePtr(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetColumnResizeID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint TableGetColumnResizeID(__IntPtr table, int column_n, int instance_no);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetMaxColumnWidth", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float TableGetMaxColumnWidth(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidthAutoSingle", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidthAutoSingle(__IntPtr table, int column_n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSetColumnWidthAutoAll", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSetColumnWidthAutoAll(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableRemove", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableRemove(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactTransientBuffers_TablePtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactTransientBuffersTablePtr(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactTransientBuffers_TableTempDataPtr", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactTransientBuffersTableTempDataPtr(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGcCompactSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableGcCompactSettings();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableLoadSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableLoadSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSaveSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSaveSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableResetSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableResetSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableGetBoundSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableGetBoundSettings(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsAddSettingsHandler", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TableSettingsAddSettingsHandler();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsCreate", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableSettingsCreate(uint id, int columns_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTableSettingsFindByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TableSettingsFindByID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igBeginTabBarEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool BeginTabBarEx(__IntPtr tab_bar, __IntPtr bb, int flags, __IntPtr dock_node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarFindTabByID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TabBarFindTabByID(__IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarFindMostRecentlySelectedTabForActiveWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr TabBarFindMostRecentlySelectedTabForActiveWindow(__IntPtr tab_bar);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarAddTab", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarAddTab(__IntPtr tab_bar, int tab_flags, __IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarRemoveTab", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarRemoveTab(__IntPtr tab_bar, uint tab_id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarCloseTab", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarCloseTab(__IntPtr tab_bar, __IntPtr tab);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarQueueReorder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarQueueReorder(__IntPtr tab_bar, __IntPtr tab, int offset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarQueueReorderFromMousePos", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabBarQueueReorderFromMousePos(__IntPtr tab_bar, __IntPtr tab, global::DearImguiSharp.ImVec2.__Internal mouse_pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabBarProcessReorder", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabBarProcessReorder(__IntPtr tab_bar);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TabItemEx(__IntPtr tab_bar, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool* p_open, int flags, __IntPtr docked_window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemCalcSize", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemCalcSize(__IntPtr pOut, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, bool has_close_button);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemBackground", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemBackground(__IntPtr draw_list, __IntPtr bb, int flags, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTabItemLabelAndCloseButton", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TabItemLabelAndCloseButton(__IntPtr draw_list, __IntPtr bb, int flags, global::DearImguiSharp.ImVec2.__Internal frame_padding, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, uint tab_id, uint close_button_id, bool is_contents_visible, bool* out_just_closed, bool* out_text_clipped);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderText(global::DearImguiSharp.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, bool hide_text_after_hash);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextWrapped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextWrapped(global::DearImguiSharp.ImVec2.__Internal pos, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, float wrap_width);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextClipped", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextClipped(global::DearImguiSharp.ImVec2.__Internal pos_min, global::DearImguiSharp.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known, global::DearImguiSharp.ImVec2.__Internal align, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextClippedEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextClippedEx(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos_min, global::DearImguiSharp.ImVec2.__Internal pos_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known, global::DearImguiSharp.ImVec2.__Internal align, __IntPtr clip_rect);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderTextEllipsis", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderTextEllipsis(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos_min, global::DearImguiSharp.ImVec2.__Internal pos_max, float clip_max_x, float ellipsis_max_x, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, __IntPtr text_size_if_known);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderFrame(global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint fill_col, bool border, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderFrameBorder", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderFrameBorder(global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderColorRectWithAlphaCheckerboard", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderColorRectWithAlphaCheckerboard(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal p_min, global::DearImguiSharp.ImVec2.__Internal p_max, uint fill_col, float grid_step, global::DearImguiSharp.ImVec2.__Internal grid_off, float rounding, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderNavHighlight", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderNavHighlight(__IntPtr bb, uint id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igFindRenderedTextEnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr FindRenderedTextEnd([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderMouseCursor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderMouseCursor(global::DearImguiSharp.ImVec2.__Internal pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderArrow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderArrow(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos, uint col, int dir, float scale);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderBullet", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderBullet(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderCheckMark", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderCheckMark(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos, uint col, float sz);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderArrowPointingAt", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderArrowPointingAt(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal pos, global::DearImguiSharp.ImVec2.__Internal half_sz, int direction, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderArrowDockMenu", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderArrowDockMenu(__IntPtr draw_list, global::DearImguiSharp.ImVec2.__Internal p_min, float sz, uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderRectFilledRangeH", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderRectFilledRangeH(__IntPtr draw_list, __IntPtr rect, uint col, float x_start_norm, float x_end_norm, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igRenderRectFilledWithHole", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void RenderRectFilledWithHole(__IntPtr draw_list, __IntPtr outer, __IntPtr inner, uint col, float rounding);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCalcRoundingFlagsForRectInRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int CalcRoundingFlagsForRectInRect(__IntPtr r_in, __IntPtr r_outer, float threshold);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTextEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TextEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text_end, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ButtonEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, global::DearImguiSharp.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCloseButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CloseButton(uint id, global::DearImguiSharp.ImVec2.__Internal pos);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCollapseButton", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CollapseButton(uint id, global::DearImguiSharp.ImVec2.__Internal pos, __IntPtr dock_node);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igArrowButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ArrowButtonEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string str_id, int dir, global::DearImguiSharp.ImVec2.__Internal size_arg, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollbar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void Scrollbar(global::DearImguiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igScrollbarEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ScrollbarEx(__IntPtr bb, uint id, global::DearImguiSharp.ImGuiAxis axis, long* p_scroll_v, long avail_v, long contents_v, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImageButtonEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImageButtonEx(uint id, __IntPtr texture_id, global::DearImguiSharp.ImVec2.__Internal size, global::DearImguiSharp.ImVec2.__Internal uv0, global::DearImguiSharp.ImVec2.__Internal uv1, global::DearImguiSharp.ImVec2.__Internal padding, global::DearImguiSharp.ImVec4.__Internal bg_col, global::DearImguiSharp.ImVec4.__Internal tint_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowScrollbarRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GetWindowScrollbarRect(__IntPtr pOut, __IntPtr window, global::DearImguiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowScrollbarID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowScrollbarID(__IntPtr window, global::DearImguiSharp.ImGuiAxis axis);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowResizeCornerID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowResizeCornerID(__IntPtr window, int n);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetWindowResizeBorderID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern uint GetWindowResizeBorderID(__IntPtr window, int dir);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSeparatorEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void SeparatorEx(int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_S64Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsS64Ptr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, long* flags, long flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igCheckboxFlags_U64Ptr", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool CheckboxFlagsU64Ptr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, ulong* flags, ulong flags_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igButtonBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ButtonBehavior(__IntPtr bb, uint id, bool* out_hovered, bool* out_held, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDragBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DragBehavior(uint id, int data_type, __IntPtr p_v, float v_speed, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSliderBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SliderBehavior(__IntPtr bb, uint id, int data_type, __IntPtr p_v, __IntPtr p_min, __IntPtr p_max, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, int flags, __IntPtr out_grab_bb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igSplitterBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool SplitterBehavior(__IntPtr bb, uint id, global::DearImguiSharp.ImGuiAxis axis, float* size1, float* size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, uint bg_col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeBehavior", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeBehavior(uint id, int flags, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreeNodeBehaviorIsOpen", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TreeNodeBehaviorIsOpen(uint id, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTreePushOverrideID", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void TreePushOverrideID(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeGetInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr DataTypeGetInfo(int data_type);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeFormatString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeApplyOp", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DataTypeApplyOp(int data_type, int op, __IntPtr output, __IntPtr arg_1, __IntPtr arg_2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeApplyFromText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DataTypeApplyFromText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string buf, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeCompare", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int DataTypeCompare(int data_type, __IntPtr arg_1, __IntPtr arg_2);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDataTypeClamp", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool DataTypeClamp(int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igInputTextEx", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool InputTextEx([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string hint, sbyte* buf, int buf_size, global::DearImguiSharp.ImVec2.__Internal size_arg, int flags, __IntPtr callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputText", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputText(__IntPtr bb, uint id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, sbyte* buf, int buf_size, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputScalar", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputScalar(__IntPtr bb, uint id, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, int data_type, __IntPtr p_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string format, __IntPtr p_clamp_min, __IntPtr p_clamp_max);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igTempInputIsActive", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool TempInputIsActive(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGetInputTextState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr GetInputTextState(uint id);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorTooltip", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorTooltip([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text, float* col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorEditOptionsPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorEditOptionsPopup(float* col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igColorPickerOptionsPopup", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ColorPickerOptionsPopup(float* ref_col, int flags);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igPlotEx", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int PlotEx(global::DearImguiSharp.ImGuiPlotType plot_type, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label, __IntPtr values_getter, __IntPtr data, int values_count, int values_offset, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2.__Internal frame_size);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShadeVertsLinearColorGradientKeepAlpha", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShadeVertsLinearColorGradientKeepAlpha(__IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::DearImguiSharp.ImVec2.__Internal gradient_p0, global::DearImguiSharp.ImVec2.__Internal gradient_p1, uint col0, uint col1);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShadeVertsLinearUV", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShadeVertsLinearUV(__IntPtr draw_list, int vert_start_idx, int vert_end_idx, global::DearImguiSharp.ImVec2.__Internal a, global::DearImguiSharp.ImVec2.__Internal b, global::DearImguiSharp.ImVec2.__Internal uv_a, global::DearImguiSharp.ImVec2.__Internal uv_b, bool clamp);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcCompactTransientMiscBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcCompactTransientMiscBuffers();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcCompactTransientWindowBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcCompactTransientWindowBuffers(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGcAwakeTransientWindowBuffers", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void GcAwakeTransientWindowBuffers(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugLog", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugLog([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igErrorCheckEndFrameRecover", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ErrorCheckEndFrameRecover(__IntPtr log_callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igErrorCheckEndWindowRecover", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ErrorCheckEndWindowRecover(__IntPtr log_callback, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugDrawItemRect", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugDrawItemRect(uint col);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugStartItemPicker", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugStartItemPicker();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igShowFontAtlas", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ShowFontAtlas(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugHookIdInfo", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugHookIdInfo(uint id, int data_type, __IntPtr data_id, __IntPtr data_id_end);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeColumns", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeColumns(__IntPtr columns);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeDockNode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeDockNode(__IntPtr node, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeDrawList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeDrawList(__IntPtr window, __IntPtr viewport, __IntPtr draw_list, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeDrawCmdShowMeshAndBoundingBox", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeDrawCmdShowMeshAndBoundingBox(__IntPtr out_draw_list, __IntPtr draw_list, __IntPtr draw_cmd, bool show_mesh, bool show_aabb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeFont(__IntPtr font);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeFontGlyph", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeFontGlyph(__IntPtr font, __IntPtr glyph);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeStorage", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeStorage(__IntPtr storage, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTabBar", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTabBar(__IntPtr tab_bar, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTable(__IntPtr table);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeTableSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeTableSettings(__IntPtr settings);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeInputTextState", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeInputTextState(__IntPtr state);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindow(__IntPtr window, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowSettings", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowSettings(__IntPtr settings);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowsList", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowsList(__IntPtr windows, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string label);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeWindowsListByBeginStackParent", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeWindowsListByBeginStackParent(__IntPtr windows, int windows_size, __IntPtr parent_in_begin_stack);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugNodeViewport", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugNodeViewport(__IntPtr viewport);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igDebugRenderViewportThumbnail", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void DebugRenderViewportThumbnail(__IntPtr draw_list, __IntPtr viewport, __IntPtr bb);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasGetBuilderForStbTruetype", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImFontAtlasGetBuilderForStbTruetype();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildInit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildInit(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildSetupFont", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildSetupFont(__IntPtr atlas, __IntPtr font, __IntPtr font_config, float ascent, float descent);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildPackCustomRects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildPackCustomRects(__IntPtr atlas, __IntPtr stbrp_context_opaque);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildFinish", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildFinish(__IntPtr atlas);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildRender8bppRectFromString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildRender8bppRectFromString(__IntPtr atlas, int x, int y, int w, int h, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_str, sbyte in_marker_char, byte in_marker_pixel_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildRender32bppRectFromString", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildRender32bppRectFromString(__IntPtr atlas, int x, int y, int w, int h, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string in_str, sbyte in_marker_char, uint in_marker_pixel_value);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildMultiplyCalcLookupTable", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igImFontAtlasBuildMultiplyRectAlpha8", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igLogText", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void LogText([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string fmt);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGET_FLT_MAX", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MAX();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "igGET_FLT_MIN", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float GET_FLT_MIN();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_create", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImVectorImWchar_create();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_destroy", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWchar_destroy(__IntPtr self);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_Init", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharInit(__IntPtr p);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImVector_ImWchar_UnInit", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImVectorImWcharUnInit(__IntPtr p);
        }

        public static global::DearImguiSharp.ImVec2 ImVec2ImVec2Nil()
        {
            var __ret = __Internal.ImVec2ImVec2Nil();
            var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec2_destroy(global::DearImguiSharp.ImVec2 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec2_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec2 ImVec2ImVec2Float(float _x, float _y)
        {
            var __ret = __Internal.ImVec2ImVec2Float(_x, _y);
            var __result0 = global::DearImguiSharp.ImVec2.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImVec4 ImVec4ImVec4Nil()
        {
            var __ret = __Internal.ImVec4ImVec4Nil();
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec4_destroy(global::DearImguiSharp.ImVec4 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec4_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec4 ImVec4ImVec4Float(float _x, float _y, float _z, float _w)
        {
            var __ret = __Internal.ImVec4ImVec4Float(_x, _y, _z, _w);
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiContext CreateContext(global::DearImguiSharp.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.CreateContext(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void DestroyContext(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DestroyContext(__arg0);
        }

        public static global::DearImguiSharp.ImGuiContext GetCurrentContext()
        {
            var __ret = __Internal.GetCurrentContext();
            var __result0 = global::DearImguiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetCurrentContext(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.SetCurrentContext(__arg0);
        }

        public static global::DearImguiSharp.ImGuiIO GetIO()
        {
            var __ret = __Internal.GetIO();
            var __result0 = global::DearImguiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStyle GetStyle()
        {
            var __ret = __Internal.GetStyle();
            var __result0 = global::DearImguiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void NewFrame()
        {
            __Internal.NewFrame();
        }

        public static void EndFrame()
        {
            __Internal.EndFrame();
        }

        public static void Render()
        {
            __Internal.Render();
        }

        public static global::DearImguiSharp.ImDrawData GetDrawData()
        {
            var __ret = __Internal.GetDrawData();
            var __result0 = global::DearImguiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ShowDemoWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowDemoWindow(__arg0);
            }
        }

        public static void ShowMetricsWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowMetricsWindow(__arg0);
            }
        }

        public static void ShowDebugLogWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowDebugLogWindow(__arg0);
            }
        }

        public static void ShowStackToolWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowStackToolWindow(__arg0);
            }
        }

        public static void ShowAboutWindow(ref bool p_open)
        {
            fixed (bool* __p_open0 = &p_open)
            {
                var __arg0 = __p_open0;
                __Internal.ShowAboutWindow(__arg0);
            }
        }

        public static void ShowStyleEditor(global::DearImguiSharp.ImGuiStyle @ref)
        {
            var __arg0 = @ref is null ? __IntPtr.Zero : @ref.__Instance;
            __Internal.ShowStyleEditor(__arg0);
        }

        public static bool ShowStyleSelector(string label)
        {
            var __ret = __Internal.ShowStyleSelector(label);
            return __ret;
        }

        public static void ShowFontSelector(string label)
        {
            __Internal.ShowFontSelector(label);
        }

        public static void ShowUserGuide()
        {
            __Internal.ShowUserGuide();
        }

        public static string GetVersion()
        {
            var __ret = __Internal.GetVersion();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void StyleColorsDark(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsDark(__arg0);
        }

        public static void StyleColorsLight(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsLight(__arg0);
        }

        public static void StyleColorsClassic(global::DearImguiSharp.ImGuiStyle dst)
        {
            var __arg0 = dst is null ? __IntPtr.Zero : dst.__Instance;
            __Internal.StyleColorsClassic(__arg0);
        }

        public static bool Begin(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.Begin(name, __arg1, flags);
                return __ret;
            }
        }

        public static void End()
        {
            __Internal.End();
        }

        public static bool BeginChildStr(string str_id, global::DearImguiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildStr(str_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static bool BeginChildID(uint id, global::DearImguiSharp.ImVec2 size, bool border, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildID(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, border, flags);
            return __ret;
        }

        public static void EndChild()
        {
            __Internal.EndChild();
        }

        public static bool IsWindowAppearing()
        {
            var __ret = __Internal.IsWindowAppearing();
            return __ret;
        }

        public static bool IsWindowCollapsed()
        {
            var __ret = __Internal.IsWindowCollapsed();
            return __ret;
        }

        public static bool IsWindowFocused(int flags)
        {
            var __ret = __Internal.IsWindowFocused(flags);
            return __ret;
        }

        public static bool IsWindowHovered(int flags)
        {
            var __ret = __Internal.IsWindowHovered(flags);
            return __ret;
        }

        public static global::DearImguiSharp.ImDrawList GetWindowDrawList()
        {
            var __ret = __Internal.GetWindowDrawList();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetWindowDpiScale()
        {
            var __ret = __Internal.GetWindowDpiScale();
            return __ret;
        }

        public static void GetWindowPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowPos(__arg0);
        }

        public static void GetWindowSize(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowSize(__arg0);
        }

        public static float GetWindowWidth()
        {
            var __ret = __Internal.GetWindowWidth();
            return __ret;
        }

        public static float GetWindowHeight()
        {
            var __ret = __Internal.GetWindowHeight();
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiViewport GetWindowViewport()
        {
            var __ret = __Internal.GetWindowViewport();
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetNextWindowPos(global::DearImguiSharp.ImVec2 pos, int cond, global::DearImguiSharp.ImVec2 pivot)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            if (ReferenceEquals(pivot, null))
                throw new global::System.ArgumentNullException("pivot", "Cannot be null because it is passed by value.");
            var __arg2 = pivot.__Instance;
            __Internal.SetNextWindowPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void SetNextWindowSize(global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowSize(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetNextWindowSizeConstraints(global::DearImguiSharp.ImVec2 size_min, global::DearImguiSharp.ImVec2 size_max, global::DearImguiSharp.ImGuiSizeCallback custom_callback, __IntPtr custom_callback_data)
        {
            if (ReferenceEquals(size_min, null))
                throw new global::System.ArgumentNullException("size_min", "Cannot be null because it is passed by value.");
            var __arg0 = size_min.__Instance;
            if (ReferenceEquals(size_max, null))
                throw new global::System.ArgumentNullException("size_max", "Cannot be null because it is passed by value.");
            var __arg1 = size_max.__Instance;
            var __arg2 = custom_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(custom_callback);
            __Internal.SetNextWindowSizeConstraints(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, custom_callback_data);
        }

        public static void SetNextWindowContentSize(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetNextWindowContentSize(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetNextWindowCollapsed(bool collapsed, int cond)
        {
            __Internal.SetNextWindowCollapsed(collapsed, cond);
        }

        public static void SetNextWindowFocus()
        {
            __Internal.SetNextWindowFocus();
        }

        public static void SetNextWindowBgAlpha(float alpha)
        {
            __Internal.SetNextWindowBgAlpha(alpha);
        }

        public static void SetNextWindowViewport(uint viewport_id)
        {
            __Internal.SetNextWindowViewport(viewport_id);
        }

        public static void SetWindowPosVec2(global::DearImguiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetWindowPosVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowSizeVec2(global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.SetWindowSizeVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, cond);
        }

        public static void SetWindowCollapsedBool(bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedBool(collapsed, cond);
        }

        public static void SetWindowFocusNil()
        {
            __Internal.SetWindowFocusNil();
        }

        public static void SetWindowFontScale(float scale)
        {
            __Internal.SetWindowFontScale(scale);
        }

        public static void SetWindowPosStr(string name, global::DearImguiSharp.ImVec2 pos, int cond)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosStr(name, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeStr(string name, global::DearImguiSharp.ImVec2 size, int cond)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeStr(name, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedStr(string name, bool collapsed, int cond)
        {
            __Internal.SetWindowCollapsedStr(name, collapsed, cond);
        }

        public static void SetWindowFocusStr(string name)
        {
            __Internal.SetWindowFocusStr(name);
        }

        public static void GetContentRegionAvail(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionAvail(__arg0);
        }

        public static void GetContentRegionMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMax(__arg0);
        }

        public static void GetWindowContentRegionMin(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMin(__arg0);
        }

        public static void GetWindowContentRegionMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetWindowContentRegionMax(__arg0);
        }

        public static float GetScrollX()
        {
            var __ret = __Internal.GetScrollX();
            return __ret;
        }

        public static float GetScrollY()
        {
            var __ret = __Internal.GetScrollY();
            return __ret;
        }

        public static void SetScrollX_Float(float scroll_x)
        {
            __Internal.SetScrollX_Float(scroll_x);
        }

        public static void SetScrollY_Float(float scroll_y)
        {
            __Internal.SetScrollY_Float(scroll_y);
        }

        public static float GetScrollMaxX()
        {
            var __ret = __Internal.GetScrollMaxX();
            return __ret;
        }

        public static float GetScrollMaxY()
        {
            var __ret = __Internal.GetScrollMaxY();
            return __ret;
        }

        public static void SetScrollHereX(float center_x_ratio)
        {
            __Internal.SetScrollHereX(center_x_ratio);
        }

        public static void SetScrollHereY(float center_y_ratio)
        {
            __Internal.SetScrollHereY(center_y_ratio);
        }

        public static void SetScrollFromPosX_Float(float local_x, float center_x_ratio)
        {
            __Internal.SetScrollFromPosX_Float(local_x, center_x_ratio);
        }

        public static void SetScrollFromPosY_Float(float local_y, float center_y_ratio)
        {
            __Internal.SetScrollFromPosY_Float(local_y, center_y_ratio);
        }

        public static void PushFont(global::DearImguiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.PushFont(__arg0);
        }

        public static void PopFont()
        {
            __Internal.PopFont();
        }

        public static void PushStyleColorU32(int idx, uint col)
        {
            __Internal.PushStyleColorU32(idx, col);
        }

        public static void PushStyleColorVec4(int idx, global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            __Internal.PushStyleColorVec4(idx, *(global::DearImguiSharp.ImVec4.__Internal*) __arg1);
        }

        public static void PopStyleColor(int count)
        {
            __Internal.PopStyleColor(count);
        }

        public static void PushStyleVarFloat(int idx, float val)
        {
            __Internal.PushStyleVarFloat(idx, val);
        }

        public static void PushStyleVarVec2(int idx, global::DearImguiSharp.ImVec2 val)
        {
            if (ReferenceEquals(val, null))
                throw new global::System.ArgumentNullException("val", "Cannot be null because it is passed by value.");
            var __arg1 = val.__Instance;
            __Internal.PushStyleVarVec2(idx, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void PopStyleVar(int count)
        {
            __Internal.PopStyleVar(count);
        }

        public static void PushAllowKeyboardFocus(bool allow_keyboard_focus)
        {
            __Internal.PushAllowKeyboardFocus(allow_keyboard_focus);
        }

        public static void PopAllowKeyboardFocus()
        {
            __Internal.PopAllowKeyboardFocus();
        }

        public static void PushButtonRepeat(bool repeat)
        {
            __Internal.PushButtonRepeat(repeat);
        }

        public static void PopButtonRepeat()
        {
            __Internal.PopButtonRepeat();
        }

        public static void PushItemWidth(float item_width)
        {
            __Internal.PushItemWidth(item_width);
        }

        public static void PopItemWidth()
        {
            __Internal.PopItemWidth();
        }

        public static void SetNextItemWidth(float item_width)
        {
            __Internal.SetNextItemWidth(item_width);
        }

        public static float CalcItemWidth()
        {
            var __ret = __Internal.CalcItemWidth();
            return __ret;
        }

        public static void PushTextWrapPos(float wrap_local_pos_x)
        {
            __Internal.PushTextWrapPos(wrap_local_pos_x);
        }

        public static void PopTextWrapPos()
        {
            __Internal.PopTextWrapPos();
        }

        public static global::DearImguiSharp.ImFont GetFont()
        {
            var __ret = __Internal.GetFont();
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetFontSize()
        {
            var __ret = __Internal.GetFontSize();
            return __ret;
        }

        public static void GetFontTexUvWhitePixel(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetFontTexUvWhitePixel(__arg0);
        }

        public static uint GetColorU32Col(int idx, float alpha_mul)
        {
            var __ret = __Internal.GetColorU32Col(idx, alpha_mul);
            return __ret;
        }

        public static uint GetColorU32Vec4(global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.GetColorU32Vec4(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static uint GetColorU32U32(uint col)
        {
            var __ret = __Internal.GetColorU32U32(col);
            return __ret;
        }

        public static global::DearImguiSharp.ImVec4 GetStyleColorVec4(int idx)
        {
            var __ret = __Internal.GetStyleColorVec4(idx);
            var __result0 = global::DearImguiSharp.ImVec4.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Separator()
        {
            __Internal.Separator();
        }

        public static void SameLine(float offset_from_start_x, float spacing)
        {
            __Internal.SameLine(offset_from_start_x, spacing);
        }

        public static void NewLine()
        {
            __Internal.NewLine();
        }

        public static void Spacing()
        {
            __Internal.Spacing();
        }

        public static void Dummy(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.Dummy(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void Indent(float indent_w)
        {
            __Internal.Indent(indent_w);
        }

        public static void Unindent(float indent_w)
        {
            __Internal.Unindent(indent_w);
        }

        public static void BeginGroup()
        {
            __Internal.BeginGroup();
        }

        public static void EndGroup()
        {
            __Internal.EndGroup();
        }

        public static void GetCursorPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorPos(__arg0);
        }

        public static float GetCursorPosX()
        {
            var __ret = __Internal.GetCursorPosX();
            return __ret;
        }

        public static float GetCursorPosY()
        {
            var __ret = __Internal.GetCursorPosY();
            return __ret;
        }

        public static void SetCursorPos(global::DearImguiSharp.ImVec2 local_pos)
        {
            if (ReferenceEquals(local_pos, null))
                throw new global::System.ArgumentNullException("local_pos", "Cannot be null because it is passed by value.");
            var __arg0 = local_pos.__Instance;
            __Internal.SetCursorPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetCursorPosX(float local_x)
        {
            __Internal.SetCursorPosX(local_x);
        }

        public static void SetCursorPosY(float local_y)
        {
            __Internal.SetCursorPosY(local_y);
        }

        public static void GetCursorStartPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorStartPos(__arg0);
        }

        public static void GetCursorScreenPos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetCursorScreenPos(__arg0);
        }

        public static void SetCursorScreenPos(global::DearImguiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.SetCursorScreenPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void AlignTextToFramePadding()
        {
            __Internal.AlignTextToFramePadding();
        }

        public static float GetTextLineHeight()
        {
            var __ret = __Internal.GetTextLineHeight();
            return __ret;
        }

        public static float GetTextLineHeightWithSpacing()
        {
            var __ret = __Internal.GetTextLineHeightWithSpacing();
            return __ret;
        }

        public static float GetFrameHeight()
        {
            var __ret = __Internal.GetFrameHeight();
            return __ret;
        }

        public static float GetFrameHeightWithSpacing()
        {
            var __ret = __Internal.GetFrameHeightWithSpacing();
            return __ret;
        }

        public static void PushID_Str(string str_id)
        {
            __Internal.PushID_Str(str_id);
        }

        public static void PushID_StrStr(string str_id_begin, string str_id_end)
        {
            __Internal.PushID_StrStr(str_id_begin, str_id_end);
        }

        public static void PushID_Ptr(__IntPtr ptr_id)
        {
            __Internal.PushID_Ptr(ptr_id);
        }

        public static void PushID_Int(int int_id)
        {
            __Internal.PushID_Int(int_id);
        }

        public static void PopID()
        {
            __Internal.PopID();
        }

        public static uint GetID_Str(string str_id)
        {
            var __ret = __Internal.GetID_Str(str_id);
            return __ret;
        }

        public static uint GetID_StrStr(string str_id_begin, string str_id_end)
        {
            var __ret = __Internal.GetID_StrStr(str_id_begin, str_id_end);
            return __ret;
        }

        public static uint GetID_Ptr(__IntPtr ptr_id)
        {
            var __ret = __Internal.GetID_Ptr(ptr_id);
            return __ret;
        }

        public static void TextUnformatted(string text, string text_end)
        {
            __Internal.TextUnformatted(text, text_end);
        }

        public static void Text(string fmt)
        {
            __Internal.Text(fmt);
        }

        public static void TextColored(global::DearImguiSharp.ImVec4 col, string fmt)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            __Internal.TextColored(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0, fmt);
        }

        public static void TextDisabled(string fmt)
        {
            __Internal.TextDisabled(fmt);
        }

        public static void TextWrapped(string fmt)
        {
            __Internal.TextWrapped(fmt);
        }

        public static void LabelText(string label, string fmt)
        {
            __Internal.LabelText(label, fmt);
        }

        public static void BulletText(string fmt)
        {
            __Internal.BulletText(fmt);
        }

        public static bool Button(string label, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.Button(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool SmallButton(string label)
        {
            var __ret = __Internal.SmallButton(label);
            return __ret;
        }

        public static bool InvisibleButton(string str_id, global::DearImguiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.InvisibleButton(str_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool ArrowButton(string str_id, int dir)
        {
            var __ret = __Internal.ArrowButton(str_id, dir);
            return __ret;
        }

        public static void Image(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2 size, global::DearImguiSharp.ImVec2 uv0, global::DearImguiSharp.ImVec2 uv1, global::DearImguiSharp.ImVec4 tint_col, global::DearImguiSharp.ImVec4 border_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg4 = tint_col.__Instance;
            if (ReferenceEquals(border_col, null))
                throw new global::System.ArgumentNullException("border_col", "Cannot be null because it is passed by value.");
            var __arg5 = border_col.__Instance;
            __Internal.Image(user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec4.__Internal*) __arg4, *(global::DearImguiSharp.ImVec4.__Internal*) __arg5);
        }

        public static bool ImageButton(__IntPtr user_texture_id, global::DearImguiSharp.ImVec2 size, global::DearImguiSharp.ImVec2 uv0, global::DearImguiSharp.ImVec2 uv1, int frame_padding, global::DearImguiSharp.ImVec4 bg_col, global::DearImguiSharp.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg2 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg3 = uv1.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg5 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg6 = tint_col.__Instance;
            var __ret = __Internal.ImageButton(user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, frame_padding, *(global::DearImguiSharp.ImVec4.__Internal*) __arg5, *(global::DearImguiSharp.ImVec4.__Internal*) __arg6);
            return __ret;
        }

        public static bool Checkbox(string label, ref bool v)
        {
            fixed (bool* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.Checkbox(label, __arg1);
                return __ret;
            }
        }

        public static bool CheckboxFlagsIntPtr(string label, ref int flags, int flags_value)
        {
            fixed (int* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsIntPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool CheckboxFlagsUintPtr(string label, ref uint flags, uint flags_value)
        {
            fixed (uint* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsUintPtr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool RadioButtonBool(string label, bool active)
        {
            var __ret = __Internal.RadioButtonBool(label, active);
            return __ret;
        }

        public static bool RadioButtonIntPtr(string label, ref int v, int v_button)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.RadioButtonIntPtr(label, __arg1, v_button);
                return __ret;
            }
        }

        public static void ProgressBar(float fraction, global::DearImguiSharp.ImVec2 size_arg, string overlay)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            __Internal.ProgressBar(fraction, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, overlay);
        }

        public static void Bullet()
        {
            __Internal.Bullet();
        }

        public static bool BeginCombo(string label, string preview_value, int flags)
        {
            var __ret = __Internal.BeginCombo(label, preview_value, flags);
            return __ret;
        }

        public static void EndCombo()
        {
            __Internal.EndCombo();
        }

        public static bool ComboStr_arr(string label, ref int current_item, string[] items, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr_arr(label, __arg1, items, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboStr(string label, ref int current_item, string items_separated_by_zeros, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ComboStr(label, __arg1, items_separated_by_zeros, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool ComboFnBoolPtr(string label, ref int current_item, global::DearImguiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int popup_max_height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ComboFnBoolPtr(label, __arg1, __arg2, data, items_count, popup_max_height_in_items);
                return __ret;
            }
        }

        public static bool DragFloat(string label, ref float v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragFloat(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragFloat2(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat3(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloat4(string label, float[] v, float v_speed, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragFloat4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragFloatRange2(string label, ref float v_current_min, ref float v_current_max, float v_speed, float v_min, float v_max, string format, string format_max, int flags)
        {
            fixed (float* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (float* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragFloatRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragInt(string label, ref int v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.DragInt(label, __arg1, v_speed, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool DragInt2(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt2(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt3(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt3(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragInt4(string label, int[] v, float v_speed, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.DragInt4(label, v, v_speed, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool DragIntRange2(string label, ref int v_current_min, ref int v_current_max, float v_speed, int v_min, int v_max, string format, string format_max, int flags)
        {
            fixed (int* __v_current_min1 = &v_current_min)
            {
                var __arg1 = __v_current_min1;
                fixed (int* __v_current_max2 = &v_current_max)
                {
                    var __arg2 = __v_current_max2;
                    var __ret = __Internal.DragIntRange2(label, __arg1, __arg2, v_speed, v_min, v_max, format, format_max, flags);
                    return __ret;
                }
            }
        }

        public static bool DragScalar(string label, int data_type, __IntPtr p_data, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool DragScalarN(string label, int data_type, __IntPtr p_data, int components, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat(string label, ref float v, float v_min, float v_max, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderFloat(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderFloat2(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat3(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderFloat4(string label, float[] v, float v_min, float v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderFloat4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderAngle(string label, ref float v_rad, float v_degrees_min, float v_degrees_max, string format, int flags)
        {
            fixed (float* __v_rad1 = &v_rad)
            {
                var __arg1 = __v_rad1;
                var __ret = __Internal.SliderAngle(label, __arg1, v_degrees_min, v_degrees_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt(string label, ref int v, int v_min, int v_max, string format, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.SliderInt(label, __arg1, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool SliderInt2(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt2(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt3(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt3(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderInt4(string label, int[] v, int v_min, int v_max, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.SliderInt4(label, v, v_min, v_max, format, flags);
            return __ret;
        }

        public static bool SliderScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalar(label, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.SliderScalarN(label, data_type, p_data, components, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool VSliderFloat(string label, global::DearImguiSharp.ImVec2 size, ref float v, float v_min, float v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (float* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderFloat(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderInt(string label, global::DearImguiSharp.ImVec2 size, ref int v, int v_min, int v_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            fixed (int* __v2 = &v)
            {
                var __arg2 = __v2;
                var __ret = __Internal.VSliderInt(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2, v_min, v_max, format, flags);
                return __ret;
            }
        }

        public static bool VSliderScalar(string label, global::DearImguiSharp.ImVec2 size, int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.VSliderScalar(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, data_type, p_data, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool InputText(string label, sbyte* buf, IntPtr buf_size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg4 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputText(label, buf, buf_size, flags, __arg4, user_data);
            return __ret;
        }

        public static bool InputTextMultiline(string label, sbyte* buf, IntPtr buf_size, global::DearImguiSharp.ImVec2 size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextMultiline(label, buf, buf_size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputTextWithHint(string label, string hint, sbyte* buf, IntPtr buf_size, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            var __arg5 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextWithHint(label, hint, buf, buf_size, flags, __arg5, user_data);
            return __ret;
        }

        public static bool InputFloat(string label, ref float v, float step, float step_fast, string format, int flags)
        {
            fixed (float* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputFloat(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputFloat2(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat2(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat3(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat3(label, v, format, flags);
            return __ret;
        }

        public static bool InputFloat4(string label, float[] v, string format, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputFloat4(label, v, format, flags);
            return __ret;
        }

        public static bool InputInt(string label, ref int v, int step, int step_fast, int flags)
        {
            fixed (int* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputInt(label, __arg1, step, step_fast, flags);
                return __ret;
            }
        }

        public static bool InputInt2(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 2)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt2(label, v, flags);
            return __ret;
        }

        public static bool InputInt3(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 3)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt3(label, v, flags);
            return __ret;
        }

        public static bool InputInt4(string label, int[] v, int flags)
        {
            if (v == null || v.Length != 4)
                throw new ArgumentOutOfRangeException("v", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.InputInt4(label, v, flags);
            return __ret;
        }

        public static bool InputDouble(string label, ref double v, double step, double step_fast, string format, int flags)
        {
            fixed (double* __v1 = &v)
            {
                var __arg1 = __v1;
                var __ret = __Internal.InputDouble(label, __arg1, step, step_fast, format, flags);
                return __ret;
            }
        }

        public static bool InputScalar(string label, int data_type, __IntPtr p_data, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool InputScalarN(string label, int data_type, __IntPtr p_data, int components, __IntPtr p_step, __IntPtr p_step_fast, string format, int flags)
        {
            var __ret = __Internal.InputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
            return __ret;
        }

        public static bool ColorEdit3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit3(label, col, flags);
            return __ret;
        }

        public static bool ColorEdit4(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorEdit4(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker3(string label, float[] col, int flags)
        {
            if (col == null || col.Length != 3)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ColorPicker3(label, col, flags);
            return __ret;
        }

        public static bool ColorPicker4(string label, float[] col, int flags, ref float ref_col)
        {
            if (col == null || col.Length != 4)
                throw new ArgumentOutOfRangeException("col", "The dimensions of the provided array don't match the required size.");
            fixed (float* __ref_col3 = &ref_col)
            {
                var __arg3 = __ref_col3;
                var __ret = __Internal.ColorPicker4(label, col, flags, __arg3);
                return __ret;
            }
        }

        public static bool ColorButton(string desc_id, global::DearImguiSharp.ImVec4 col, int flags, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg1 = col.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.ColorButton(desc_id, *(global::DearImguiSharp.ImVec4.__Internal*) __arg1, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void SetColorEditOptions(int flags)
        {
            __Internal.SetColorEditOptions(flags);
        }

        public static bool TreeNodeStr(string label)
        {
            var __ret = __Internal.TreeNodeStr(label);
            return __ret;
        }

        public static bool TreeNodeStrStr(string str_id, string fmt)
        {
            var __ret = __Internal.TreeNodeStrStr(str_id, fmt);
            return __ret;
        }

        public static bool TreeNodePtr(__IntPtr ptr_id, string fmt)
        {
            var __ret = __Internal.TreeNodePtr(ptr_id, fmt);
            return __ret;
        }

        public static bool TreeNodeExStr(string label, int flags)
        {
            var __ret = __Internal.TreeNodeExStr(label, flags);
            return __ret;
        }

        public static bool TreeNodeExStrStr(string str_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExStrStr(str_id, flags, fmt);
            return __ret;
        }

        public static bool TreeNodeExPtr(__IntPtr ptr_id, int flags, string fmt)
        {
            var __ret = __Internal.TreeNodeExPtr(ptr_id, flags, fmt);
            return __ret;
        }

        public static void TreePushStr(string str_id)
        {
            __Internal.TreePushStr(str_id);
        }

        public static void TreePushPtr(__IntPtr ptr_id)
        {
            __Internal.TreePushPtr(ptr_id);
        }

        public static void TreePop()
        {
            __Internal.TreePop();
        }

        public static float GetTreeNodeToLabelSpacing()
        {
            var __ret = __Internal.GetTreeNodeToLabelSpacing();
            return __ret;
        }

        public static bool CollapsingHeaderTreeNodeFlags(string label, int flags)
        {
            var __ret = __Internal.CollapsingHeaderTreeNodeFlags(label, flags);
            return __ret;
        }

        public static bool CollapsingHeaderBoolPtr(string label, ref bool p_visible, int flags)
        {
            fixed (bool* __p_visible1 = &p_visible)
            {
                var __arg1 = __p_visible1;
                var __ret = __Internal.CollapsingHeaderBoolPtr(label, __arg1, flags);
                return __ret;
            }
        }

        public static void SetNextItemOpen(bool is_open, int cond)
        {
            __Internal.SetNextItemOpen(is_open, cond);
        }

        public static bool SelectableBool(string label, bool selected, int flags, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg3 = size.__Instance;
            var __ret = __Internal.SelectableBool(label, selected, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static bool SelectableBoolPtr(string label, ref bool p_selected, int flags, global::DearImguiSharp.ImVec2 size)
        {
            fixed (bool* __p_selected1 = &p_selected)
            {
                var __arg1 = __p_selected1;
                if (ReferenceEquals(size, null))
                    throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
                var __arg3 = size.__Instance;
                var __ret = __Internal.SelectableBoolPtr(label, __arg1, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
                return __ret;
            }
        }

        public static bool BeginListBox(string label, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginListBox(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void EndListBox()
        {
            __Internal.EndListBox();
        }

        public static bool ListBoxStr_arr(string label, ref int current_item, string[] items, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __ret = __Internal.ListBoxStr_arr(label, __arg1, items, items_count, height_in_items);
                return __ret;
            }
        }

        public static bool ListBoxFnBoolPtr(string label, ref int current_item, global::DearImguiSharp.Delegates.Func_bool___IntPtr_int_sbytePtrPtr items_getter, __IntPtr data, int items_count, int height_in_items)
        {
            fixed (int* __current_item1 = &current_item)
            {
                var __arg1 = __current_item1;
                var __arg2 = items_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(items_getter);
                var __ret = __Internal.ListBoxFnBoolPtr(label, __arg1, __arg2, data, items_count, height_in_items);
                return __ret;
            }
        }

        public static void PlotLinesFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotLinesFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotLinesFnFloatPtr(string label, global::DearImguiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotLinesFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void PlotHistogramFloatPtr(string label, ref float values, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size, int stride)
        {
            fixed (float* __values1 = &values)
            {
                var __arg1 = __values1;
                if (ReferenceEquals(graph_size, null))
                    throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
                var __arg7 = graph_size.__Instance;
                __Internal.PlotHistogramFloatPtr(label, __arg1, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, stride);
            }
        }

        public static void PlotHistogramFnFloatPtr(string label, global::DearImguiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 graph_size)
        {
            var __arg1 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(graph_size, null))
                throw new global::System.ArgumentNullException("graph_size", "Cannot be null because it is passed by value.");
            var __arg8 = graph_size.__Instance;
            __Internal.PlotHistogramFnFloatPtr(label, __arg1, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8);
        }

        public static void ValueBool(string prefix, bool b)
        {
            __Internal.ValueBool(prefix, b);
        }

        public static void ValueInt(string prefix, int v)
        {
            __Internal.ValueInt(prefix, v);
        }

        public static void ValueUint(string prefix, uint v)
        {
            __Internal.ValueUint(prefix, v);
        }

        public static void ValueFloat(string prefix, float v, string float_format)
        {
            __Internal.ValueFloat(prefix, v, float_format);
        }

        public static bool BeginMenuBar()
        {
            var __ret = __Internal.BeginMenuBar();
            return __ret;
        }

        public static void EndMenuBar()
        {
            __Internal.EndMenuBar();
        }

        public static bool BeginMainMenuBar()
        {
            var __ret = __Internal.BeginMainMenuBar();
            return __ret;
        }

        public static void EndMainMenuBar()
        {
            __Internal.EndMainMenuBar();
        }

        public static bool BeginMenu(string label, bool enabled)
        {
            var __ret = __Internal.BeginMenu(label, enabled);
            return __ret;
        }

        public static void EndMenu()
        {
            __Internal.EndMenu();
        }

        public static bool MenuItemBool(string label, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemBool(label, shortcut, selected, enabled);
            return __ret;
        }

        public static bool MenuItemBoolPtr(string label, string shortcut, ref bool p_selected, bool enabled)
        {
            fixed (bool* __p_selected2 = &p_selected)
            {
                var __arg2 = __p_selected2;
                var __ret = __Internal.MenuItemBoolPtr(label, shortcut, __arg2, enabled);
                return __ret;
            }
        }

        public static void BeginTooltip()
        {
            __Internal.BeginTooltip();
        }

        public static void EndTooltip()
        {
            __Internal.EndTooltip();
        }

        public static void SetTooltip(string fmt)
        {
            __Internal.SetTooltip(fmt);
        }

        public static bool BeginPopup(string str_id, int flags)
        {
            var __ret = __Internal.BeginPopup(str_id, flags);
            return __ret;
        }

        public static bool BeginPopupModal(string name, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginPopupModal(name, __arg1, flags);
                return __ret;
            }
        }

        public static void EndPopup()
        {
            __Internal.EndPopup();
        }

        public static void OpenPopupStr(string str_id, int popup_flags)
        {
            __Internal.OpenPopupStr(str_id, popup_flags);
        }

        public static void OpenPopupID(uint id, int popup_flags)
        {
            __Internal.OpenPopupID(id, popup_flags);
        }

        public static void OpenPopupOnItemClick(string str_id, int popup_flags)
        {
            __Internal.OpenPopupOnItemClick(str_id, popup_flags);
        }

        public static void CloseCurrentPopup()
        {
            __Internal.CloseCurrentPopup();
        }

        public static bool BeginPopupContextItem(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextItem(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextWindow(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextWindow(str_id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupContextVoid(string str_id, int popup_flags)
        {
            var __ret = __Internal.BeginPopupContextVoid(str_id, popup_flags);
            return __ret;
        }

        public static bool IsPopupOpenStr(string str_id, int flags)
        {
            var __ret = __Internal.IsPopupOpenStr(str_id, flags);
            return __ret;
        }

        public static bool BeginTable(string str_id, int column, int flags, global::DearImguiSharp.ImVec2 outer_size, float inner_width)
        {
            if (ReferenceEquals(outer_size, null))
                throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is passed by value.");
            var __arg3 = outer_size.__Instance;
            var __ret = __Internal.BeginTable(str_id, column, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, inner_width);
            return __ret;
        }

        public static void EndTable()
        {
            __Internal.EndTable();
        }

        public static void TableNextRow(int row_flags, float min_row_height)
        {
            __Internal.TableNextRow(row_flags, min_row_height);
        }

        public static bool TableNextColumn()
        {
            var __ret = __Internal.TableNextColumn();
            return __ret;
        }

        public static bool TableSetColumnIndex(int column_n)
        {
            var __ret = __Internal.TableSetColumnIndex(column_n);
            return __ret;
        }

        public static void TableSetupColumn(string label, int flags, float init_width_or_weight, uint user_id)
        {
            __Internal.TableSetupColumn(label, flags, init_width_or_weight, user_id);
        }

        public static void TableSetupScrollFreeze(int cols, int rows)
        {
            __Internal.TableSetupScrollFreeze(cols, rows);
        }

        public static void TableHeadersRow()
        {
            __Internal.TableHeadersRow();
        }

        public static void TableHeader(string label)
        {
            __Internal.TableHeader(label);
        }

        public static global::DearImguiSharp.ImGuiTableSortSpecs TableGetSortSpecs()
        {
            var __ret = __Internal.TableGetSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static int TableGetColumnCount()
        {
            var __ret = __Internal.TableGetColumnCount();
            return __ret;
        }

        public static int TableGetColumnIndex()
        {
            var __ret = __Internal.TableGetColumnIndex();
            return __ret;
        }

        public static int TableGetRowIndex()
        {
            var __ret = __Internal.TableGetRowIndex();
            return __ret;
        }

        public static string TableGetColumnNameInt(int column_n)
        {
            var __ret = __Internal.TableGetColumnNameInt(column_n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int TableGetColumnFlags(int column_n)
        {
            var __ret = __Internal.TableGetColumnFlags(column_n);
            return __ret;
        }

        public static void TableSetColumnEnabled(int column_n, bool v)
        {
            __Internal.TableSetColumnEnabled(column_n, v);
        }

        public static void TableSetBgColor(int target, uint color, int column_n)
        {
            __Internal.TableSetBgColor(target, color, column_n);
        }

        public static void Columns(int count, string id, bool border)
        {
            __Internal.Columns(count, id, border);
        }

        public static void NextColumn()
        {
            __Internal.NextColumn();
        }

        public static int GetColumnIndex()
        {
            var __ret = __Internal.GetColumnIndex();
            return __ret;
        }

        public static float GetColumnWidth(int column_index)
        {
            var __ret = __Internal.GetColumnWidth(column_index);
            return __ret;
        }

        public static void SetColumnWidth(int column_index, float width)
        {
            __Internal.SetColumnWidth(column_index, width);
        }

        public static float GetColumnOffset(int column_index)
        {
            var __ret = __Internal.GetColumnOffset(column_index);
            return __ret;
        }

        public static void SetColumnOffset(int column_index, float offset_x)
        {
            __Internal.SetColumnOffset(column_index, offset_x);
        }

        public static int GetColumnsCount()
        {
            var __ret = __Internal.GetColumnsCount();
            return __ret;
        }

        public static bool BeginTabBar(string str_id, int flags)
        {
            var __ret = __Internal.BeginTabBar(str_id, flags);
            return __ret;
        }

        public static void EndTabBar()
        {
            __Internal.EndTabBar();
        }

        public static bool BeginTabItem(string label, ref bool p_open, int flags)
        {
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                var __ret = __Internal.BeginTabItem(label, __arg1, flags);
                return __ret;
            }
        }

        public static void EndTabItem()
        {
            __Internal.EndTabItem();
        }

        public static bool TabItemButton(string label, int flags)
        {
            var __ret = __Internal.TabItemButton(label, flags);
            return __ret;
        }

        public static void SetTabItemClosed(string tab_or_docked_window_label)
        {
            __Internal.SetTabItemClosed(tab_or_docked_window_label);
        }

        public static uint DockSpace(uint id, global::DearImguiSharp.ImVec2 size, int flags, global::DearImguiSharp.ImGuiWindowClass window_class)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __arg3 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
            var __ret = __Internal.DockSpace(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags, __arg3);
            return __ret;
        }

        public static uint DockSpaceOverViewport(global::DearImguiSharp.ImGuiViewport viewport, int flags, global::DearImguiSharp.ImGuiWindowClass window_class)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __arg2 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
            var __ret = __Internal.DockSpaceOverViewport(__arg0, flags, __arg2);
            return __ret;
        }

        public static void SetNextWindowDockID(uint dock_id, int cond)
        {
            __Internal.SetNextWindowDockID(dock_id, cond);
        }

        public static void SetNextWindowClass(global::DearImguiSharp.ImGuiWindowClass window_class)
        {
            var __arg0 = window_class is null ? __IntPtr.Zero : window_class.__Instance;
            __Internal.SetNextWindowClass(__arg0);
        }

        public static uint GetWindowDockID()
        {
            var __ret = __Internal.GetWindowDockID();
            return __ret;
        }

        public static bool IsWindowDocked()
        {
            var __ret = __Internal.IsWindowDocked();
            return __ret;
        }

        public static void LogToTTY(int auto_open_depth)
        {
            __Internal.LogToTTY(auto_open_depth);
        }

        public static void LogToFile(int auto_open_depth, string filename)
        {
            __Internal.LogToFile(auto_open_depth, filename);
        }

        public static void LogToClipboard(int auto_open_depth)
        {
            __Internal.LogToClipboard(auto_open_depth);
        }

        public static void LogFinish()
        {
            __Internal.LogFinish();
        }

        public static void LogButtons()
        {
            __Internal.LogButtons();
        }

        public static bool BeginDragDropSource(int flags)
        {
            var __ret = __Internal.BeginDragDropSource(flags);
            return __ret;
        }

        public static bool SetDragDropPayload(string type, __IntPtr data, IntPtr sz, int cond)
        {
            var __ret = __Internal.SetDragDropPayload(type, data, sz, cond);
            return __ret;
        }

        public static void EndDragDropSource()
        {
            __Internal.EndDragDropSource();
        }

        public static bool BeginDragDropTarget()
        {
            var __ret = __Internal.BeginDragDropTarget();
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiPayload AcceptDragDropPayload(string type, int flags)
        {
            var __ret = __Internal.AcceptDragDropPayload(type, flags);
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void EndDragDropTarget()
        {
            __Internal.EndDragDropTarget();
        }

        public static global::DearImguiSharp.ImGuiPayload GetDragDropPayload()
        {
            var __ret = __Internal.GetDragDropPayload();
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void BeginDisabled(bool disabled)
        {
            __Internal.BeginDisabled(disabled);
        }

        public static void EndDisabled()
        {
            __Internal.EndDisabled();
        }

        public static void PushClipRect(global::DearImguiSharp.ImVec2 clip_rect_min, global::DearImguiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_max.__Instance;
            __Internal.PushClipRect(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, intersect_with_current_clip_rect);
        }

        public static void PopClipRect()
        {
            __Internal.PopClipRect();
        }

        public static void SetItemDefaultFocus()
        {
            __Internal.SetItemDefaultFocus();
        }

        public static void SetKeyboardFocusHere(int offset)
        {
            __Internal.SetKeyboardFocusHere(offset);
        }

        public static bool IsItemHovered(int flags)
        {
            var __ret = __Internal.IsItemHovered(flags);
            return __ret;
        }

        public static bool IsItemActive()
        {
            var __ret = __Internal.IsItemActive();
            return __ret;
        }

        public static bool IsItemFocused()
        {
            var __ret = __Internal.IsItemFocused();
            return __ret;
        }

        public static bool IsItemClicked(int mouse_button)
        {
            var __ret = __Internal.IsItemClicked(mouse_button);
            return __ret;
        }

        public static bool IsItemVisible()
        {
            var __ret = __Internal.IsItemVisible();
            return __ret;
        }

        public static bool IsItemEdited()
        {
            var __ret = __Internal.IsItemEdited();
            return __ret;
        }

        public static bool IsItemActivated()
        {
            var __ret = __Internal.IsItemActivated();
            return __ret;
        }

        public static bool IsItemDeactivated()
        {
            var __ret = __Internal.IsItemDeactivated();
            return __ret;
        }

        public static bool IsItemDeactivatedAfterEdit()
        {
            var __ret = __Internal.IsItemDeactivatedAfterEdit();
            return __ret;
        }

        public static bool IsItemToggledOpen()
        {
            var __ret = __Internal.IsItemToggledOpen();
            return __ret;
        }

        public static bool IsAnyItemHovered()
        {
            var __ret = __Internal.IsAnyItemHovered();
            return __ret;
        }

        public static bool IsAnyItemActive()
        {
            var __ret = __Internal.IsAnyItemActive();
            return __ret;
        }

        public static bool IsAnyItemFocused()
        {
            var __ret = __Internal.IsAnyItemFocused();
            return __ret;
        }

        public static void GetItemRectMin(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMin(__arg0);
        }

        public static void GetItemRectMax(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectMax(__arg0);
        }

        public static void GetItemRectSize(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetItemRectSize(__arg0);
        }

        public static void SetItemAllowOverlap()
        {
            __Internal.SetItemAllowOverlap();
        }

        public static global::DearImguiSharp.ImGuiViewport GetMainViewport()
        {
            var __ret = __Internal.GetMainViewport();
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetBackgroundDrawListNil()
        {
            var __ret = __Internal.GetBackgroundDrawListNil();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetForegroundDrawListNil()
        {
            var __ret = __Internal.GetForegroundDrawListNil();
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetBackgroundDrawListViewportPtr(global::DearImguiSharp.ImGuiViewport viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.GetBackgroundDrawListViewportPtr(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetForegroundDrawListViewportPtr(global::DearImguiSharp.ImGuiViewport viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.GetForegroundDrawListViewportPtr(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool IsRectVisibleNil(global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            var __ret = __Internal.IsRectVisibleNil(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static bool IsRectVisibleVec2(global::DearImguiSharp.ImVec2 rect_min, global::DearImguiSharp.ImVec2 rect_max)
        {
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg0 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg1 = rect_max.__Instance;
            var __ret = __Internal.IsRectVisibleVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static double GetTime()
        {
            var __ret = __Internal.GetTime();
            return __ret;
        }

        public static int GetFrameCount()
        {
            var __ret = __Internal.GetFrameCount();
            return __ret;
        }

        public static global::DearImguiSharp.ImDrawListSharedData GetDrawListSharedData()
        {
            var __ret = __Internal.GetDrawListSharedData();
            var __result0 = global::DearImguiSharp.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static string GetStyleColorName(int idx)
        {
            var __ret = __Internal.GetStyleColorName(idx);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetStateStorage(global::DearImguiSharp.ImGuiStorage storage)
        {
            var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
            __Internal.SetStateStorage(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStorage GetStateStorage()
        {
            var __ret = __Internal.GetStateStorage();
            var __result0 = global::DearImguiSharp.ImGuiStorage.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginChildFrame(uint id, global::DearImguiSharp.ImVec2 size, int flags)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            var __ret = __Internal.BeginChildFrame(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static void EndChildFrame()
        {
            __Internal.EndChildFrame();
        }

        public static void CalcTextSize(global::DearImguiSharp.ImVec2 pOut, string text, string text_end, bool hide_text_after_double_hash, float wrap_width)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.CalcTextSize(__arg0, text, text_end, hide_text_after_double_hash, wrap_width);
        }

        public static void ColorConvertU32ToFloat4(global::DearImguiSharp.ImVec4 pOut, uint @in)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ColorConvertU32ToFloat4(__arg0, @in);
        }

        public static uint ColorConvertFloat4ToU32(global::DearImguiSharp.ImVec4 @in)
        {
            if (ReferenceEquals(@in, null))
                throw new global::System.ArgumentNullException("@in", "Cannot be null because it is passed by value.");
            var __arg0 = @in.__Instance;
            var __ret = __Internal.ColorConvertFloat4ToU32(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static void ColorConvertRGBtoHSV(float r, float g, float b, ref float out_h, ref float out_s, ref float out_v)
        {
            fixed (float* __out_h3 = &out_h)
            {
                var __arg3 = __out_h3;
                fixed (float* __out_s4 = &out_s)
                {
                    var __arg4 = __out_s4;
                    fixed (float* __out_v5 = &out_v)
                    {
                        var __arg5 = __out_v5;
                        __Internal.ColorConvertRGBtoHSV(r, g, b, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static void ColorConvertHSVtoRGB(float h, float s, float v, ref float out_r, ref float out_g, ref float out_b)
        {
            fixed (float* __out_r3 = &out_r)
            {
                var __arg3 = __out_r3;
                fixed (float* __out_g4 = &out_g)
                {
                    var __arg4 = __out_g4;
                    fixed (float* __out_b5 = &out_b)
                    {
                        var __arg5 = __out_b5;
                        __Internal.ColorConvertHSVtoRGB(h, s, v, __arg3, __arg4, __arg5);
                    }
                }
            }
        }

        public static bool IsKeyDown(int key)
        {
            var __ret = __Internal.IsKeyDown(key);
            return __ret;
        }

        public static bool IsKeyPressed(int key, bool repeat)
        {
            var __ret = __Internal.IsKeyPressed(key, repeat);
            return __ret;
        }

        public static bool IsKeyReleased(int key)
        {
            var __ret = __Internal.IsKeyReleased(key);
            return __ret;
        }

        public static int GetKeyPressedAmount(int key, float repeat_delay, float rate)
        {
            var __ret = __Internal.GetKeyPressedAmount(key, repeat_delay, rate);
            return __ret;
        }

        public static string GetKeyName(int key)
        {
            var __ret = __Internal.GetKeyName(key);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetNextFrameWantCaptureKeyboard(bool want_capture_keyboard)
        {
            __Internal.SetNextFrameWantCaptureKeyboard(want_capture_keyboard);
        }

        public static bool IsMouseDown(int button)
        {
            var __ret = __Internal.IsMouseDown(button);
            return __ret;
        }

        public static bool IsMouseClicked(int button, bool repeat)
        {
            var __ret = __Internal.IsMouseClicked(button, repeat);
            return __ret;
        }

        public static bool IsMouseReleased(int button)
        {
            var __ret = __Internal.IsMouseReleased(button);
            return __ret;
        }

        public static bool IsMouseDoubleClicked(int button)
        {
            var __ret = __Internal.IsMouseDoubleClicked(button);
            return __ret;
        }

        public static int GetMouseClickedCount(int button)
        {
            var __ret = __Internal.GetMouseClickedCount(button);
            return __ret;
        }

        public static bool IsMouseHoveringRect(global::DearImguiSharp.ImVec2 r_min, global::DearImguiSharp.ImVec2 r_max, bool clip)
        {
            if (ReferenceEquals(r_min, null))
                throw new global::System.ArgumentNullException("r_min", "Cannot be null because it is passed by value.");
            var __arg0 = r_min.__Instance;
            if (ReferenceEquals(r_max, null))
                throw new global::System.ArgumentNullException("r_max", "Cannot be null because it is passed by value.");
            var __arg1 = r_max.__Instance;
            var __ret = __Internal.IsMouseHoveringRect(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, clip);
            return __ret;
        }

        public static bool IsMousePosValid(global::DearImguiSharp.ImVec2 mouse_pos)
        {
            var __arg0 = mouse_pos is null ? __IntPtr.Zero : mouse_pos.__Instance;
            var __ret = __Internal.IsMousePosValid(__arg0);
            return __ret;
        }

        public static bool IsAnyMouseDown()
        {
            var __ret = __Internal.IsAnyMouseDown();
            return __ret;
        }

        public static void GetMousePos(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePos(__arg0);
        }

        public static void GetMousePosOnOpeningCurrentPopup(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMousePosOnOpeningCurrentPopup(__arg0);
        }

        public static bool IsMouseDragging(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragging(button, lock_threshold);
            return __ret;
        }

        public static void GetMouseDragDelta(global::DearImguiSharp.ImVec2 pOut, int button, float lock_threshold)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetMouseDragDelta(__arg0, button, lock_threshold);
        }

        public static void ResetMouseDragDelta(int button)
        {
            __Internal.ResetMouseDragDelta(button);
        }

        public static int GetMouseCursor()
        {
            var __ret = __Internal.GetMouseCursor();
            return __ret;
        }

        public static void SetMouseCursor(int cursor_type)
        {
            __Internal.SetMouseCursor(cursor_type);
        }

        public static void SetNextFrameWantCaptureMouse(bool want_capture_mouse)
        {
            __Internal.SetNextFrameWantCaptureMouse(want_capture_mouse);
        }

        public static string GetClipboardText()
        {
            var __ret = __Internal.GetClipboardText();
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void SetClipboardText(string text)
        {
            __Internal.SetClipboardText(text);
        }

        public static void LoadIniSettingsFromDisk(string ini_filename)
        {
            __Internal.LoadIniSettingsFromDisk(ini_filename);
        }

        public static void LoadIniSettingsFromMemory(string ini_data, IntPtr ini_size)
        {
            __Internal.LoadIniSettingsFromMemory(ini_data, ini_size);
        }

        public static void SaveIniSettingsToDisk(string ini_filename)
        {
            __Internal.SaveIniSettingsToDisk(ini_filename);
        }

        public static string SaveIniSettingsToMemory(ref IntPtr out_ini_size)
        {
            fixed (IntPtr* __out_ini_size0 = &out_ini_size)
            {
                var __arg0 = __out_ini_size0;
                var __ret = __Internal.SaveIniSettingsToMemory(__arg0);
                return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
            }
        }

        public static void DebugTextEncoding(string text)
        {
            __Internal.DebugTextEncoding(text);
        }

        public static bool DebugCheckVersionAndDataLayout(string version_str, IntPtr sz_io, IntPtr sz_style, IntPtr sz_vec2, IntPtr sz_vec4, IntPtr sz_drawvert, IntPtr sz_drawidx)
        {
            var __ret = __Internal.DebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
            return __ret;
        }

        public static void SetAllocatorFunctions(global::DearImguiSharp.ImGuiMemAllocFunc alloc_func, global::DearImguiSharp.ImGuiMemFreeFunc free_func, __IntPtr user_data)
        {
            var __arg0 = alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(alloc_func);
            var __arg1 = free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(free_func);
            __Internal.SetAllocatorFunctions(__arg0, __arg1, user_data);
        }

        public static void GetAllocatorFunctions(global::DearImguiSharp.ImGuiMemAllocFunc p_alloc_func, global::DearImguiSharp.ImGuiMemFreeFunc p_free_func, __IntPtr* p_user_data)
        {
            var __arg0 = p_alloc_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_alloc_func);
            var __arg1 = p_free_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(p_free_func);
            __Internal.GetAllocatorFunctions(__arg0, __arg1, p_user_data);
        }

        public static __IntPtr MemAlloc(IntPtr size)
        {
            var __ret = __Internal.MemAlloc(size);
            return __ret;
        }

        public static void MemFree(__IntPtr ptr)
        {
            __Internal.MemFree(ptr);
        }

        public static global::DearImguiSharp.ImGuiPlatformIO GetPlatformIO()
        {
            var __ret = __Internal.GetPlatformIO();
            var __result0 = global::DearImguiSharp.ImGuiPlatformIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void UpdatePlatformWindows()
        {
            __Internal.UpdatePlatformWindows();
        }

        public static void RenderPlatformWindowsDefault(__IntPtr platform_render_arg, __IntPtr renderer_render_arg)
        {
            __Internal.RenderPlatformWindowsDefault(platform_render_arg, renderer_render_arg);
        }

        public static void DestroyPlatformWindows()
        {
            __Internal.DestroyPlatformWindows();
        }

        public static global::DearImguiSharp.ImGuiViewport FindViewportByID(uint id)
        {
            var __ret = __Internal.FindViewportByID(id);
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiViewport FindViewportByPlatformHandle(__IntPtr platform_handle)
        {
            var __ret = __Internal.FindViewportByPlatformHandle(platform_handle);
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStyle ImGuiStyleImGuiStyle()
        {
            var __ret = __Internal.ImGuiStyleImGuiStyle();
            var __result0 = global::DearImguiSharp.ImGuiStyle.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStyle_destroy(global::DearImguiSharp.ImGuiStyle self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyle_destroy(__arg0);
        }

        public static void ImGuiStyleScaleAllSizes(global::DearImguiSharp.ImGuiStyle self, float scale_factor)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleScaleAllSizes(__arg0, scale_factor);
        }

        public static void ImGuiIO_AddKeyEvent(global::DearImguiSharp.ImGuiIO self, int key, bool down)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddKeyEvent(__arg0, key, down);
        }

        public static void ImGuiIO_AddKeyAnalogEvent(global::DearImguiSharp.ImGuiIO self, int key, bool down, float v)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddKeyAnalogEvent(__arg0, key, down, v);
        }

        public static void ImGuiIO_AddMousePosEvent(global::DearImguiSharp.ImGuiIO self, float x, float y)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMousePosEvent(__arg0, x, y);
        }

        public static void ImGuiIO_AddMouseButtonEvent(global::DearImguiSharp.ImGuiIO self, int button, bool down)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMouseButtonEvent(__arg0, button, down);
        }

        public static void ImGuiIO_AddMouseWheelEvent(global::DearImguiSharp.ImGuiIO self, float wh_x, float wh_y)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMouseWheelEvent(__arg0, wh_x, wh_y);
        }

        public static void ImGuiIO_AddMouseViewportEvent(global::DearImguiSharp.ImGuiIO self, uint id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddMouseViewportEvent(__arg0, id);
        }

        public static void ImGuiIO_AddFocusEvent(global::DearImguiSharp.ImGuiIO self, bool focused)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddFocusEvent(__arg0, focused);
        }

        public static void ImGuiIO_AddInputCharacter(global::DearImguiSharp.ImGuiIO self, uint c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacter(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharacterUTF16(global::DearImguiSharp.ImGuiIO self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharacterUTF16(__arg0, c);
        }

        public static void ImGuiIO_AddInputCharactersUTF8(global::DearImguiSharp.ImGuiIO self, string str)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_AddInputCharactersUTF8(__arg0, str);
        }

        public static void ImGuiIO_SetKeyEventNativeData(global::DearImguiSharp.ImGuiIO self, int key, int native_keycode, int native_scancode, int native_legacy_index)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_SetKeyEventNativeData(__arg0, key, native_keycode, native_scancode, native_legacy_index);
        }

        public static void ImGuiIO_SetAppAcceptingEvents(global::DearImguiSharp.ImGuiIO self, bool accepting_events)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_SetAppAcceptingEvents(__arg0, accepting_events);
        }

        public static void ImGuiIO_ClearInputCharacters(global::DearImguiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputCharacters(__arg0);
        }

        public static void ImGuiIO_ClearInputKeys(global::DearImguiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_ClearInputKeys(__arg0);
        }

        public static global::DearImguiSharp.ImGuiIO ImGuiIO_ImGuiIO()
        {
            var __ret = __Internal.ImGuiIO_ImGuiIO();
            var __result0 = global::DearImguiSharp.ImGuiIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiIO_destroy(global::DearImguiSharp.ImGuiIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiIO_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiInputTextCallbackData ImGuiInputTextCallbackDataImGuiInputTextCallbackData()
        {
            var __ret = __Internal.ImGuiInputTextCallbackDataImGuiInputTextCallbackData();
            var __result0 = global::DearImguiSharp.ImGuiInputTextCallbackData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputTextCallbackData_destroy(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackData_destroy(__arg0);
        }

        public static void ImGuiInputTextCallbackDataDeleteChars(global::DearImguiSharp.ImGuiInputTextCallbackData self, int pos, int bytes_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataDeleteChars(__arg0, pos, bytes_count);
        }

        public static void ImGuiInputTextCallbackDataInsertChars(global::DearImguiSharp.ImGuiInputTextCallbackData self, int pos, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataInsertChars(__arg0, pos, text, text_end);
        }

        public static void ImGuiInputTextCallbackDataSelectAll(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataSelectAll(__arg0);
        }

        public static void ImGuiInputTextCallbackDataClearSelection(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextCallbackDataClearSelection(__arg0);
        }

        public static bool ImGuiInputTextCallbackDataHasSelection(global::DearImguiSharp.ImGuiInputTextCallbackData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextCallbackDataHasSelection(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiWindowClass ImGuiWindowClassImGuiWindowClass()
        {
            var __ret = __Internal.ImGuiWindowClassImGuiWindowClass();
            var __result0 = global::DearImguiSharp.ImGuiWindowClass.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiWindowClass_destroy(global::DearImguiSharp.ImGuiWindowClass self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowClass_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPayload ImGuiPayloadImGuiPayload()
        {
            var __ret = __Internal.ImGuiPayloadImGuiPayload();
            var __result0 = global::DearImguiSharp.ImGuiPayload.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPayload_destroy(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayload_destroy(__arg0);
        }

        public static void ImGuiPayloadClear(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPayloadClear(__arg0);
        }

        public static bool ImGuiPayloadIsDataType(global::DearImguiSharp.ImGuiPayload self, string type)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDataType(__arg0, type);
            return __ret;
        }

        public static bool ImGuiPayloadIsPreview(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsPreview(__arg0);
            return __ret;
        }

        public static bool ImGuiPayloadIsDelivery(global::DearImguiSharp.ImGuiPayload self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiPayloadIsDelivery(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiTableColumnSortSpecs ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs()
        {
            var __ret = __Internal.ImGuiTableColumnSortSpecsImGuiTableColumnSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableColumnSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumnSortSpecs_destroy(global::DearImguiSharp.ImGuiTableColumnSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumnSortSpecs_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableSortSpecs ImGuiTableSortSpecsImGuiTableSortSpecs()
        {
            var __ret = __Internal.ImGuiTableSortSpecsImGuiTableSortSpecs();
            var __result0 = global::DearImguiSharp.ImGuiTableSortSpecs.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableSortSpecs_destroy(global::DearImguiSharp.ImGuiTableSortSpecs self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableSortSpecs_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiOnceUponAFrame ImGuiOnceUponAFrameImGuiOnceUponAFrame()
        {
            var __ret = __Internal.ImGuiOnceUponAFrameImGuiOnceUponAFrame();
            var __result0 = global::DearImguiSharp.ImGuiOnceUponAFrame.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOnceUponAFrame_destroy(global::DearImguiSharp.ImGuiOnceUponAFrame self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOnceUponAFrame_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTextFilter ImGuiTextFilterImGuiTextFilter(string default_filter)
        {
            var __ret = __Internal.ImGuiTextFilterImGuiTextFilter(default_filter);
            var __result0 = global::DearImguiSharp.ImGuiTextFilter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextFilter_destroy(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilter_destroy(__arg0);
        }

        public static bool ImGuiTextFilterDraw(global::DearImguiSharp.ImGuiTextFilter self, string label, float width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterDraw(__arg0, label, width);
            return __ret;
        }

        public static bool ImGuiTextFilterPassFilter(global::DearImguiSharp.ImGuiTextFilter self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterPassFilter(__arg0, text, text_end);
            return __ret;
        }

        public static void ImGuiTextFilterBuild(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterBuild(__arg0);
        }

        public static void ImGuiTextFilterClear(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextFilterClear(__arg0);
        }

        public static bool ImGuiTextFilterIsActive(global::DearImguiSharp.ImGuiTextFilter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextFilterIsActive(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeNil()
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeNil();
            var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextRange_destroy(global::DearImguiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextRange_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTextRange ImGuiTextRangeImGuiTextRangeStr(string _b, string _e)
        {
            var __ret = __Internal.ImGuiTextRangeImGuiTextRangeStr(_b, _e);
            var __result0 = global::DearImguiSharp.ImGuiTextRange.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool ImGuiTextRange_empty(global::DearImguiSharp.ImGuiTextRange self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextRange_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextRange_split(global::DearImguiSharp.ImGuiTextRange self, sbyte separator, global::DearImguiSharp.ImVectorImGuiTextRange @out)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = @out is null ? __IntPtr.Zero : @out.__Instance;
            __Internal.ImGuiTextRange_split(__arg0, separator, __arg2);
        }

        public static global::DearImguiSharp.ImGuiTextBuffer ImGuiTextBufferImGuiTextBuffer()
        {
            var __ret = __Internal.ImGuiTextBufferImGuiTextBuffer();
            var __result0 = global::DearImguiSharp.ImGuiTextBuffer.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTextBuffer_destroy(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_destroy(__arg0);
        }

        public static string ImGuiTextBuffer_begin(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_begin(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImGuiTextBuffer_end(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_end(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImGuiTextBuffer_size(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_size(__arg0);
            return __ret;
        }

        public static bool ImGuiTextBuffer_empty(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_empty(__arg0);
            return __ret;
        }

        public static void ImGuiTextBuffer_clear(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_clear(__arg0);
        }

        public static void ImGuiTextBuffer_reserve(global::DearImguiSharp.ImGuiTextBuffer self, int capacity)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_reserve(__arg0, capacity);
        }

        public static string ImGuiTextBuffer_c_str(global::DearImguiSharp.ImGuiTextBuffer self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTextBuffer_c_str(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImGuiTextBuffer_append(global::DearImguiSharp.ImGuiTextBuffer self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTextBuffer_append(__arg0, str, str_end);
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairInt(uint _key, int _val_i)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairInt(_key, _val_i);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStoragePair_destroy(global::DearImguiSharp.ImGuiStoragePair self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStoragePair_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairFloat(uint _key, float _val_f)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairFloat(_key, _val_f);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStoragePair ImGuiStoragePairImGuiStoragePairPtr(uint _key, __IntPtr _val_p)
        {
            var __ret = __Internal.ImGuiStoragePairImGuiStoragePairPtr(_key, _val_p);
            var __result0 = global::DearImguiSharp.ImGuiStoragePair.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStorageClear(global::DearImguiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageClear(__arg0);
        }

        public static int ImGuiStorageGetInt(global::DearImguiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetInt(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetInt(global::DearImguiSharp.ImGuiStorage self, uint key, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetInt(__arg0, key, val);
        }

        public static bool ImGuiStorageGetBool(global::DearImguiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBool(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetBool(global::DearImguiSharp.ImGuiStorage self, uint key, bool val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetBool(__arg0, key, val);
        }

        public static float ImGuiStorageGetFloat(global::DearImguiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloat(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetFloat(global::DearImguiSharp.ImGuiStorage self, uint key, float val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetFloat(__arg0, key, val);
        }

        public static __IntPtr ImGuiStorageGetVoidPtr(global::DearImguiSharp.ImGuiStorage self, uint key)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtr(__arg0, key);
            return __ret;
        }

        public static void ImGuiStorageSetVoidPtr(global::DearImguiSharp.ImGuiStorage self, uint key, __IntPtr val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetVoidPtr(__arg0, key, val);
        }

        public static int* ImGuiStorageGetIntRef(global::DearImguiSharp.ImGuiStorage self, uint key, int default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetIntRef(__arg0, key, default_val);
            return __ret;
        }

        public static bool* ImGuiStorageGetBoolRef(global::DearImguiSharp.ImGuiStorage self, uint key, bool default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetBoolRef(__arg0, key, default_val);
            return __ret;
        }

        public static float* ImGuiStorageGetFloatRef(global::DearImguiSharp.ImGuiStorage self, uint key, float default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetFloatRef(__arg0, key, default_val);
            return __ret;
        }

        public static __IntPtr* ImGuiStorageGetVoidPtrRef(global::DearImguiSharp.ImGuiStorage self, uint key, __IntPtr default_val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiStorageGetVoidPtrRef(__arg0, key, default_val);
            return __ret;
        }

        public static void ImGuiStorageSetAllInt(global::DearImguiSharp.ImGuiStorage self, int val)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageSetAllInt(__arg0, val);
        }

        public static void ImGuiStorageBuildSortByKey(global::DearImguiSharp.ImGuiStorage self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStorageBuildSortByKey(__arg0);
        }

        public static global::DearImguiSharp.ImGuiListClipper ImGuiListClipperImGuiListClipper()
        {
            var __ret = __Internal.ImGuiListClipperImGuiListClipper();
            var __result0 = global::DearImguiSharp.ImGuiListClipper.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiListClipper_destroy(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipper_destroy(__arg0);
        }

        public static void ImGuiListClipperBegin(global::DearImguiSharp.ImGuiListClipper self, int items_count, float items_height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperBegin(__arg0, items_count, items_height);
        }

        public static void ImGuiListClipperEnd(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperEnd(__arg0);
        }

        public static bool ImGuiListClipperStep(global::DearImguiSharp.ImGuiListClipper self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiListClipperStep(__arg0);
            return __ret;
        }

        public static void ImGuiListClipperForceDisplayRangeByIndices(global::DearImguiSharp.ImGuiListClipper self, int item_min, int item_max)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperForceDisplayRangeByIndices(__arg0, item_min, item_max);
        }

        public static global::DearImguiSharp.ImColor ImColorImColorNil()
        {
            var __ret = __Internal.ImColorImColorNil();
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColor_destroy(global::DearImguiSharp.ImColor self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColor_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImColor ImColorImColorFloat(float r, float g, float b, float a)
        {
            var __ret = __Internal.ImColorImColorFloat(r, g, b, a);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorVec4(global::DearImguiSharp.ImVec4 col)
        {
            if (ReferenceEquals(col, null))
                throw new global::System.ArgumentNullException("col", "Cannot be null because it is passed by value.");
            var __arg0 = col.__Instance;
            var __ret = __Internal.ImColorImColorVec4(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorInt(int r, int g, int b, int a)
        {
            var __ret = __Internal.ImColorImColorInt(r, g, b, a);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImColor ImColorImColorU32(uint rgba)
        {
            var __ret = __Internal.ImColorImColorU32(rgba);
            var __result0 = global::DearImguiSharp.ImColor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImColorSetHSV(global::DearImguiSharp.ImColor self, float h, float s, float v, float a)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImColorSetHSV(__arg0, h, s, v, a);
        }

        public static void ImColorHSV(global::DearImguiSharp.ImColor pOut, float h, float s, float v, float a)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.ImColorHSV(__arg0, h, s, v, a);
        }

        public static global::DearImguiSharp.ImDrawCmd ImDrawCmdImDrawCmd()
        {
            var __ret = __Internal.ImDrawCmdImDrawCmd();
            var __result0 = global::DearImguiSharp.ImDrawCmd.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawCmd_destroy(global::DearImguiSharp.ImDrawCmd self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawCmd_destroy(__arg0);
        }

        public static __IntPtr ImDrawCmdGetTexID(global::DearImguiSharp.ImDrawCmd self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawCmdGetTexID(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImDrawListSplitter ImDrawListSplitterImDrawListSplitter()
        {
            var __ret = __Internal.ImDrawListSplitterImDrawListSplitter();
            var __result0 = global::DearImguiSharp.ImDrawListSplitter.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListSplitter_destroy(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitter_destroy(__arg0);
        }

        public static void ImDrawListSplitterClear(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClear(__arg0);
        }

        public static void ImDrawListSplitterClearFreeMemory(global::DearImguiSharp.ImDrawListSplitter self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSplitterClearFreeMemory(__arg0);
        }

        public static void ImDrawListSplitterSplit(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSplit(__arg0, __arg1, count);
        }

        public static void ImDrawListSplitterMerge(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterMerge(__arg0, __arg1);
        }

        public static void ImDrawListSplitterSetCurrentChannel(global::DearImguiSharp.ImDrawListSplitter self, global::DearImguiSharp.ImDrawList draw_list, int channel_idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.ImDrawListSplitterSetCurrentChannel(__arg0, __arg1, channel_idx);
        }

        public static global::DearImguiSharp.ImDrawList ImDrawListImDrawList(global::DearImguiSharp.ImDrawListSharedData shared_data)
        {
            var __arg0 = shared_data is null ? __IntPtr.Zero : shared_data.__Instance;
            var __ret = __Internal.ImDrawListImDrawList(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawList_destroy(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawList_destroy(__arg0);
        }

        public static void ImDrawListPushClipRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 clip_rect_min, global::DearImguiSharp.ImVec2 clip_rect_max, bool intersect_with_current_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(clip_rect_min, null))
                throw new global::System.ArgumentNullException("clip_rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect_min.__Instance;
            if (ReferenceEquals(clip_rect_max, null))
                throw new global::System.ArgumentNullException("clip_rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = clip_rect_max.__Instance;
            __Internal.ImDrawListPushClipRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, intersect_with_current_clip_rect);
        }

        public static void ImDrawListPushClipRectFullScreen(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushClipRectFullScreen(__arg0);
        }

        public static void ImDrawListPopClipRect(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopClipRect(__arg0);
        }

        public static void ImDrawListPushTextureID(global::DearImguiSharp.ImDrawList self, __IntPtr texture_id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPushTextureID(__arg0, texture_id);
        }

        public static void ImDrawListPopTextureID(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopTextureID(__arg0);
        }

        public static void ImDrawListGetClipRectMin(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMin(__arg0, __arg1);
        }

        public static void ImDrawListGetClipRectMax(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListGetClipRectMax(__arg0, __arg1);
        }

        public static void ImDrawListAddLine(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            __Internal.ImDrawListAddLine(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, thickness);
        }

        public static void ImDrawListAddRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col, float rounding, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, rounding, flags, thickness);
        }

        public static void ImDrawListAddRectFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col, rounding, flags);
        }

        public static void ImDrawListAddRectFilledMultiColor(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint col_upr_left, uint col_upr_right, uint col_bot_right, uint col_bot_left)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            __Internal.ImDrawListAddRectFilledMultiColor(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col_upr_left, col_upr_right, col_bot_right, col_bot_left);
        }

        public static void ImDrawListAddQuad(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuad(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col, thickness);
        }

        public static void ImDrawListAddQuadFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddQuadFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListAddTriangle(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangle(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, thickness);
        }

        public static void ImDrawListAddTriangleFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddTriangleFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col);
        }

        public static void ImDrawListAddCircle(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircle(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddCircleFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddCircleFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddNgon(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgon(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments, thickness);
        }

        public static void ImDrawListAddNgonFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, uint col, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListAddNgonFilled(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, col, num_segments);
        }

        public static void ImDrawListAddTextVec2(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, uint col, string text_begin, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListAddTextVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, col, text_begin, text_end);
        }

        public static void ImDrawListAddTextFontPtr(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImFont font, float font_size, global::DearImguiSharp.ImVec2 pos, uint col, string text_begin, string text_end, float wrap_width, global::DearImguiSharp.ImVec4 cpu_fine_clip_rect)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            var __arg8 = cpu_fine_clip_rect is null ? __IntPtr.Zero : cpu_fine_clip_rect.__Instance;
            __Internal.ImDrawListAddTextFontPtr(__arg0, __arg1, font_size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, text_begin, text_end, wrap_width, __arg8);
        }

        public static void ImDrawListAddPolyline(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 points, int num_points, uint col, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddPolyline(__arg0, __arg1, num_points, col, flags, thickness);
        }

        public static void ImDrawListAddConvexPolyFilled(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 points, int num_points, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = points is null ? __IntPtr.Zero : points.__Instance;
            __Internal.ImDrawListAddConvexPolyFilled(__arg0, __arg1, num_points, col);
        }

        public static void ImDrawListAddBezierCubic(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImDrawListAddBezierCubic(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col, thickness, num_segments);
        }

        public static void ImDrawListAddBezierQuadratic(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, uint col, float thickness, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImDrawListAddBezierQuadratic(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, thickness, num_segments);
        }

        public static void ImDrawListAddImage(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, global::DearImguiSharp.ImVec2 uv_min, global::DearImguiSharp.ImVec2 uv_max, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImage(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, col);
        }

        public static void ImDrawListAddImageQuad(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, global::DearImguiSharp.ImVec2 uv1, global::DearImguiSharp.ImVec2 uv2, global::DearImguiSharp.ImVec2 uv3, global::DearImguiSharp.ImVec2 uv4, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg2 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg3 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg4 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg5 = p4.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg6 = uv1.__Instance;
            if (ReferenceEquals(uv2, null))
                throw new global::System.ArgumentNullException("uv2", "Cannot be null because it is passed by value.");
            var __arg7 = uv2.__Instance;
            if (ReferenceEquals(uv3, null))
                throw new global::System.ArgumentNullException("uv3", "Cannot be null because it is passed by value.");
            var __arg8 = uv3.__Instance;
            if (ReferenceEquals(uv4, null))
                throw new global::System.ArgumentNullException("uv4", "Cannot be null because it is passed by value.");
            var __arg9 = uv4.__Instance;
            __Internal.ImDrawListAddImageQuad(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8, *(global::DearImguiSharp.ImVec2.__Internal*) __arg9, col);
        }

        public static void ImDrawListAddImageRounded(global::DearImguiSharp.ImDrawList self, __IntPtr user_texture_id, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, global::DearImguiSharp.ImVec2 uv_min, global::DearImguiSharp.ImVec2 uv_max, uint col, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg2 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg3 = p_max.__Instance;
            if (ReferenceEquals(uv_min, null))
                throw new global::System.ArgumentNullException("uv_min", "Cannot be null because it is passed by value.");
            var __arg4 = uv_min.__Instance;
            if (ReferenceEquals(uv_max, null))
                throw new global::System.ArgumentNullException("uv_max", "Cannot be null because it is passed by value.");
            var __arg5 = uv_max.__Instance;
            __Internal.ImDrawListAddImageRounded(__arg0, user_texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, col, rounding, flags);
        }

        public static void ImDrawListPathClear(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathClear(__arg0);
        }

        public static void ImDrawListPathLineTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathLineToMergeDuplicate(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.ImDrawListPathLineToMergeDuplicate(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImDrawListPathFillConvex(global::DearImguiSharp.ImDrawList self, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathFillConvex(__arg0, col);
        }

        public static void ImDrawListPathStroke(global::DearImguiSharp.ImDrawList self, uint col, int flags, float thickness)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPathStroke(__arg0, col, flags, thickness);
        }

        public static void ImDrawListPathArcTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static void ImDrawListPathArcToFast(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, int a_min_of_12, int a_max_of_12)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFast(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min_of_12, a_max_of_12);
        }

        public static void ImDrawListPathBezierCubicCurveTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg3 = p4.__Instance;
            __Internal.ImDrawListPathBezierCubicCurveTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, num_segments);
        }

        public static void ImDrawListPathBezierQuadraticCurveTo(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg1 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg2 = p3.__Instance;
            __Internal.ImDrawListPathBezierQuadraticCurveTo(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, num_segments);
        }

        public static void ImDrawListPathRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 rect_min, global::DearImguiSharp.ImVec2 rect_max, float rounding, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(rect_min, null))
                throw new global::System.ArgumentNullException("rect_min", "Cannot be null because it is passed by value.");
            var __arg1 = rect_min.__Instance;
            if (ReferenceEquals(rect_max, null))
                throw new global::System.ArgumentNullException("rect_max", "Cannot be null because it is passed by value.");
            var __arg2 = rect_max.__Instance;
            __Internal.ImDrawListPathRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, rounding, flags);
        }

        public static void ImDrawListAddCallback(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImDrawCallback callback, __IntPtr callback_data)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            __Internal.ImDrawListAddCallback(__arg0, __arg1, callback_data);
        }

        public static void ImDrawListAddDrawCmd(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListAddDrawCmd(__arg0);
        }

        public static global::DearImguiSharp.ImDrawList ImDrawListCloneOutput(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCloneOutput(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListChannelsSplit(global::DearImguiSharp.ImDrawList self, int count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSplit(__arg0, count);
        }

        public static void ImDrawListChannelsMerge(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsMerge(__arg0);
        }

        public static void ImDrawListChannelsSetCurrent(global::DearImguiSharp.ImDrawList self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListChannelsSetCurrent(__arg0, n);
        }

        public static void ImDrawListPrimReserve(global::DearImguiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimReserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimUnreserve(global::DearImguiSharp.ImDrawList self, int idx_count, int vtx_count)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimUnreserve(__arg0, idx_count, vtx_count);
        }

        public static void ImDrawListPrimRect(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImDrawListPrimRect(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimRectUV(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 uv_a, global::DearImguiSharp.ImVec2 uv_b, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg3 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg4 = uv_b.__Instance;
            __Internal.ImDrawListPrimRectUV(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col);
        }

        public static void ImDrawListPrimQuadUV(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c, global::DearImguiSharp.ImVec2 d, global::DearImguiSharp.ImVec2 uv_a, global::DearImguiSharp.ImVec2 uv_b, global::DearImguiSharp.ImVec2 uv_c, global::DearImguiSharp.ImVec2 uv_d, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg4 = d.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            if (ReferenceEquals(uv_c, null))
                throw new global::System.ArgumentNullException("uv_c", "Cannot be null because it is passed by value.");
            var __arg7 = uv_c.__Instance;
            if (ReferenceEquals(uv_d, null))
                throw new global::System.ArgumentNullException("uv_d", "Cannot be null because it is passed by value.");
            var __arg8 = uv_d.__Instance;
            __Internal.ImDrawListPrimQuadUV(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, *(global::DearImguiSharp.ImVec2.__Internal*) __arg7, *(global::DearImguiSharp.ImVec2.__Internal*) __arg8, col);
        }

        public static void ImDrawListPrimWriteVtx(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimWriteVtx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListPrimWriteIdx(global::DearImguiSharp.ImDrawList self, ushort idx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPrimWriteIdx(__arg0, idx);
        }

        public static void ImDrawListPrimVtx(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 uv, uint col)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(uv, null))
                throw new global::System.ArgumentNullException("uv", "Cannot be null because it is passed by value.");
            var __arg2 = uv.__Instance;
            __Internal.ImDrawListPrimVtx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, col);
        }

        public static void ImDrawListResetForNewFrame(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListResetForNewFrame(__arg0);
        }

        public static void ImDrawListClearFreeMemory(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListClearFreeMemory(__arg0);
        }

        public static void ImDrawListPopUnusedDrawCmd(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListPopUnusedDrawCmd(__arg0);
        }

        public static void ImDrawListTryMergeDrawCmds(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListTryMergeDrawCmds(__arg0);
        }

        public static void ImDrawListOnChangedClipRect(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedClipRect(__arg0);
        }

        public static void ImDrawListOnChangedTextureID(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedTextureID(__arg0);
        }

        public static void ImDrawListOnChangedVtxOffset(global::DearImguiSharp.ImDrawList self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListOnChangedVtxOffset(__arg0);
        }

        public static int ImDrawListCalcCircleAutoSegmentCount(global::DearImguiSharp.ImDrawList self, float radius)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawListCalcCircleAutoSegmentCount(__arg0, radius);
            return __ret;
        }

        public static void ImDrawListPathArcToFastEx(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, int a_min_sample, int a_max_sample, int a_step)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToFastEx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min_sample, a_max_sample, a_step);
        }

        public static void ImDrawListPathArcToN(global::DearImguiSharp.ImDrawList self, global::DearImguiSharp.ImVec2 center, float radius, float a_min, float a_max, int num_segments)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(center, null))
                throw new global::System.ArgumentNullException("center", "Cannot be null because it is passed by value.");
            var __arg1 = center.__Instance;
            __Internal.ImDrawListPathArcToN(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, radius, a_min, a_max, num_segments);
        }

        public static global::DearImguiSharp.ImDrawData ImDrawDataImDrawData()
        {
            var __ret = __Internal.ImDrawDataImDrawData();
            var __result0 = global::DearImguiSharp.ImDrawData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawData_destroy(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawData_destroy(__arg0);
        }

        public static void ImDrawDataClear(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataClear(__arg0);
        }

        public static void ImDrawDataDeIndexAllBuffers(global::DearImguiSharp.ImDrawData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataDeIndexAllBuffers(__arg0);
        }

        public static void ImDrawDataScaleClipRects(global::DearImguiSharp.ImDrawData self, global::DearImguiSharp.ImVec2 fb_scale)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(fb_scale, null))
                throw new global::System.ArgumentNullException("fb_scale", "Cannot be null because it is passed by value.");
            var __arg1 = fb_scale.__Instance;
            __Internal.ImDrawDataScaleClipRects(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static global::DearImguiSharp.ImFontConfig ImFontConfigImFontConfig()
        {
            var __ret = __Internal.ImFontConfigImFontConfig();
            var __result0 = global::DearImguiSharp.ImFontConfig.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontConfig_destroy(global::DearImguiSharp.ImFontConfig self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontConfig_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFontGlyphRangesBuilder ImFontGlyphRangesBuilderImFontGlyphRangesBuilder()
        {
            var __ret = __Internal.ImFontGlyphRangesBuilderImFontGlyphRangesBuilder();
            var __result0 = global::DearImguiSharp.ImFontGlyphRangesBuilder.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontGlyphRangesBuilder_destroy(global::DearImguiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilder_destroy(__arg0);
        }

        public static void ImFontGlyphRangesBuilderClear(global::DearImguiSharp.ImFontGlyphRangesBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderClear(__arg0);
        }

        public static bool ImFontGlyphRangesBuilderGetBit(global::DearImguiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGlyphRangesBuilderGetBit(__arg0, n);
            return __ret;
        }

        public static void ImFontGlyphRangesBuilderSetBit(global::DearImguiSharp.ImFontGlyphRangesBuilder self, IntPtr n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderSetBit(__arg0, n);
        }

        public static void ImFontGlyphRangesBuilderAddChar(global::DearImguiSharp.ImFontGlyphRangesBuilder self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddChar(__arg0, c);
        }

        public static void ImFontGlyphRangesBuilderAddText(global::DearImguiSharp.ImFontGlyphRangesBuilder self, string text, string text_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGlyphRangesBuilderAddText(__arg0, text, text_end);
        }

        public static void ImFontGlyphRangesBuilderAddRanges(global::DearImguiSharp.ImFontGlyphRangesBuilder self, ref ushort ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (ushort* __ranges1 = &ranges)
            {
                var __arg1 = __ranges1;
                __Internal.ImFontGlyphRangesBuilderAddRanges(__arg0, __arg1);
            }
        }

        public static void ImFontGlyphRangesBuilderBuildRanges(global::DearImguiSharp.ImFontGlyphRangesBuilder self, global::DearImguiSharp.ImVectorImWchar out_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = out_ranges is null ? __IntPtr.Zero : out_ranges.__Instance;
            __Internal.ImFontGlyphRangesBuilderBuildRanges(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImFontAtlasCustomRect ImFontAtlasCustomRectImFontAtlasCustomRect()
        {
            var __ret = __Internal.ImFontAtlasCustomRectImFontAtlasCustomRect();
            var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCustomRect_destroy(global::DearImguiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasCustomRect_destroy(__arg0);
        }

        public static bool ImFontAtlasCustomRectIsPacked(global::DearImguiSharp.ImFontAtlasCustomRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasCustomRectIsPacked(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImFontAtlas ImFontAtlasImFontAtlas()
        {
            var __ret = __Internal.ImFontAtlasImFontAtlas();
            var __result0 = global::DearImguiSharp.ImFontAtlas.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlas_destroy(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlas_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFont(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFont(__arg0, __arg1);
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontDefault(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontConfig font_cfg)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            var __ret = __Internal.ImFontAtlasAddFontDefault(__arg0, __arg1);
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromFileTTF(global::DearImguiSharp.ImFontAtlas self, string filename, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromFileTTF(__arg0, filename, size_pixels, __arg3, __arg4);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryTTF(global::DearImguiSharp.ImFontAtlas self, __IntPtr font_data, int font_size, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryTTF(__arg0, font_data, font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedTTF(global::DearImguiSharp.ImFontAtlas self, __IntPtr compressed_font_data, int compressed_font_size, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg4 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges5 = &glyph_ranges)
            {
                var __arg5 = __glyph_ranges5;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedTTF(__arg0, compressed_font_data, compressed_font_size, size_pixels, __arg4, __arg5);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static global::DearImguiSharp.ImFont ImFontAtlasAddFontFromMemoryCompressedBase85TTF(global::DearImguiSharp.ImFontAtlas self, string compressed_font_data_base85, float size_pixels, global::DearImguiSharp.ImFontConfig font_cfg, ref ushort glyph_ranges)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg3 = font_cfg is null ? __IntPtr.Zero : font_cfg.__Instance;
            fixed (ushort* __glyph_ranges4 = &glyph_ranges)
            {
                var __arg4 = __glyph_ranges4;
                var __ret = __Internal.ImFontAtlasAddFontFromMemoryCompressedBase85TTF(__arg0, compressed_font_data_base85, size_pixels, __arg3, __arg4);
                var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
                return __result0;
            }
        }

        public static void ImFontAtlasClearInputData(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearInputData(__arg0);
        }

        public static void ImFontAtlasClearTexData(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearTexData(__arg0);
        }

        public static void ImFontAtlasClearFonts(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClearFonts(__arg0);
        }

        public static void ImFontAtlasClear(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasClear(__arg0);
        }

        public static bool ImFontAtlasBuild(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasBuild(__arg0);
            return __ret;
        }

        public static void ImFontAtlasGetTexDataAsAlpha8(global::DearImguiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsAlpha8(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static void ImFontAtlasGetTexDataAsRGBA32(global::DearImguiSharp.ImFontAtlas self, byte** out_pixels, ref int out_width, ref int out_height, ref int out_bytes_per_pixel)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            fixed (int* __out_width2 = &out_width)
            {
                var __arg2 = __out_width2;
                fixed (int* __out_height3 = &out_height)
                {
                    var __arg3 = __out_height3;
                    fixed (int* __out_bytes_per_pixel4 = &out_bytes_per_pixel)
                    {
                        var __arg4 = __out_bytes_per_pixel4;
                        __Internal.ImFontAtlasGetTexDataAsRGBA32(__arg0, out_pixels, __arg2, __arg3, __arg4);
                    }
                }
            }
        }

        public static bool ImFontAtlasIsBuilt(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasIsBuilt(__arg0);
            return __ret;
        }

        public static void ImFontAtlasSetTexID(global::DearImguiSharp.ImFontAtlas self, __IntPtr id)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAtlasSetTexID(__arg0, id);
        }

        public static ushort* ImFontAtlasGetGlyphRangesDefault(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesDefault(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesKorean(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesKorean(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesJapanese(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesJapanese(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseFull(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseFull(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesChineseSimplifiedCommon(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesCyrillic(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesCyrillic(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesThai(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesThai(__arg0);
            return __ret;
        }

        public static ushort* ImFontAtlasGetGlyphRangesVietnamese(global::DearImguiSharp.ImFontAtlas self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetGlyphRangesVietnamese(__arg0);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectRegular(global::DearImguiSharp.ImFontAtlas self, int width, int height)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectRegular(__arg0, width, height);
            return __ret;
        }

        public static int ImFontAtlasAddCustomRectFontGlyph(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFont font, ushort id, int width, int height, float advance_x, global::DearImguiSharp.ImVec2 offset)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            if (ReferenceEquals(offset, null))
                throw new global::System.ArgumentNullException("offset", "Cannot be null because it is passed by value.");
            var __arg6 = offset.__Instance;
            var __ret = __Internal.ImFontAtlasAddCustomRectFontGlyph(__arg0, __arg1, id, width, height, advance_x, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6);
            return __ret;
        }

        public static global::DearImguiSharp.ImFontAtlasCustomRect ImFontAtlasGetCustomRectByIndex(global::DearImguiSharp.ImFontAtlas self, int index)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontAtlasGetCustomRectByIndex(__arg0, index);
            var __result0 = global::DearImguiSharp.ImFontAtlasCustomRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasCalcCustomRectUV(global::DearImguiSharp.ImFontAtlas self, global::DearImguiSharp.ImFontAtlasCustomRect rect, global::DearImguiSharp.ImVec2 out_uv_min, global::DearImguiSharp.ImVec2 out_uv_max)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = rect is null ? __IntPtr.Zero : rect.__Instance;
            var __arg2 = out_uv_min is null ? __IntPtr.Zero : out_uv_min.__Instance;
            var __arg3 = out_uv_max is null ? __IntPtr.Zero : out_uv_max.__Instance;
            __Internal.ImFontAtlasCalcCustomRectUV(__arg0, __arg1, __arg2, __arg3);
        }

        public static bool ImFontAtlasGetMouseCursorTexData(global::DearImguiSharp.ImFontAtlas self, int cursor, global::DearImguiSharp.ImVec2 out_offset, global::DearImguiSharp.ImVec2 out_size, global::DearImguiSharp.ImVec2[] out_uv_border, global::DearImguiSharp.ImVec2[] out_uv_fill)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg2 = out_offset is null ? __IntPtr.Zero : out_offset.__Instance;
            var __arg3 = out_size is null ? __IntPtr.Zero : out_size.__Instance;
            if (out_uv_border == null || out_uv_border.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_border", "The dimensions of the provided array don't match the required size.");
            global::DearImguiSharp.ImVec2.__Internal[] __out_uv_border;
            if (out_uv_border == null)
                __out_uv_border = null;
            else
            {
                __out_uv_border = new global::DearImguiSharp.ImVec2.__Internal[out_uv_border.Length];
                for (int i = 0; i < __out_uv_border.Length; i++)
                {
                    var __element = out_uv_border[i];
                    __out_uv_border[i] = __element is null ? new global::DearImguiSharp.ImVec2.__Internal() : *(global::DearImguiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg4 = __out_uv_border;
            if (out_uv_fill == null || out_uv_fill.Length != 2)
                throw new ArgumentOutOfRangeException("out_uv_fill", "The dimensions of the provided array don't match the required size.");
            global::DearImguiSharp.ImVec2.__Internal[] __out_uv_fill;
            if (out_uv_fill == null)
                __out_uv_fill = null;
            else
            {
                __out_uv_fill = new global::DearImguiSharp.ImVec2.__Internal[out_uv_fill.Length];
                for (int i = 0; i < __out_uv_fill.Length; i++)
                {
                    var __element = out_uv_fill[i];
                    __out_uv_fill[i] = __element is null ? new global::DearImguiSharp.ImVec2.__Internal() : *(global::DearImguiSharp.ImVec2.__Internal*) __element.__Instance;
                }
            }
            var __arg5 = __out_uv_fill;
            var __ret = __Internal.ImFontAtlasGetMouseCursorTexData(__arg0, cursor, __arg2, __arg3, __arg4, __arg5);
            return __ret;
        }

        public static global::DearImguiSharp.ImFont ImFontImFont()
        {
            var __ret = __Internal.ImFontImFont();
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFont_destroy(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFont_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImFontGlyph ImFontFindGlyph(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyph(__arg0, c);
            var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImFontGlyph ImFontFindGlyphNoFallback(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontFindGlyphNoFallback(__arg0, c);
            var __result0 = global::DearImguiSharp.ImFontGlyph.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float ImFontGetCharAdvance(global::DearImguiSharp.ImFont self, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetCharAdvance(__arg0, c);
            return __ret;
        }

        public static bool ImFontIsLoaded(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsLoaded(__arg0);
            return __ret;
        }

        public static string ImFontGetDebugName(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontGetDebugName(__arg0);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontCalcTextSizeA(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImFont self, float size, float max_width, float wrap_width, string text_begin, string text_end, sbyte** remaining)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontCalcTextSizeA(__arg0, __arg1, size, max_width, wrap_width, text_begin, text_end, remaining);
        }

        public static string ImFontCalcWordWrapPositionA(global::DearImguiSharp.ImFont self, float scale, string text, string text_end, float wrap_width)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontCalcWordWrapPositionA(__arg0, scale, text, text_end, wrap_width);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImFontRenderChar(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImDrawList draw_list, float size, global::DearImguiSharp.ImVec2 pos, uint col, ushort c)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            __Internal.ImFontRenderChar(__arg0, __arg1, size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, c);
        }

        public static void ImFontRenderText(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImDrawList draw_list, float size, global::DearImguiSharp.ImVec2 pos, uint col, global::DearImguiSharp.ImVec4 clip_rect, string text_begin, string text_end, float wrap_width, bool cpu_fine_clip)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg3 = pos.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg5 = clip_rect.__Instance;
            __Internal.ImFontRenderText(__arg0, __arg1, size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, col, *(global::DearImguiSharp.ImVec4.__Internal*) __arg5, text_begin, text_end, wrap_width, cpu_fine_clip);
        }

        public static void ImFontBuildLookupTable(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontBuildLookupTable(__arg0);
        }

        public static void ImFontClearOutputData(global::DearImguiSharp.ImFont self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontClearOutputData(__arg0);
        }

        public static void ImFontGrowIndex(global::DearImguiSharp.ImFont self, int new_size)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontGrowIndex(__arg0, new_size);
        }

        public static void ImFontAddGlyph(global::DearImguiSharp.ImFont self, global::DearImguiSharp.ImFontConfig src_cfg, ushort c, float x0, float y0, float x1, float y1, float u0, float v0, float u1, float v1, float advance_x)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = src_cfg is null ? __IntPtr.Zero : src_cfg.__Instance;
            __Internal.ImFontAddGlyph(__arg0, __arg1, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
        }

        public static void ImFontAddRemapChar(global::DearImguiSharp.ImFont self, ushort dst, ushort src, bool overwrite_dst)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontAddRemapChar(__arg0, dst, src, overwrite_dst);
        }

        public static void ImFontSetGlyphVisible(global::DearImguiSharp.ImFont self, ushort c, bool visible)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImFontSetGlyphVisible(__arg0, c, visible);
        }

        public static bool ImFontIsGlyphRangeUnused(global::DearImguiSharp.ImFont self, uint c_begin, uint c_last)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImFontIsGlyphRangeUnused(__arg0, c_begin, c_last);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiViewport ImGuiViewportImGuiViewport()
        {
            var __ret = __Internal.ImGuiViewportImGuiViewport();
            var __result0 = global::DearImguiSharp.ImGuiViewport.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiViewport_destroy(global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewport_destroy(__arg0);
        }

        public static void ImGuiViewportGetCenter(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetCenter(__arg0, __arg1);
        }

        public static void ImGuiViewportGetWorkCenter(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewport self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportGetWorkCenter(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiPlatformIO ImGuiPlatformIO_ImGuiPlatformIO()
        {
            var __ret = __Internal.ImGuiPlatformIO_ImGuiPlatformIO();
            var __result0 = global::DearImguiSharp.ImGuiPlatformIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPlatformIO_destroy(global::DearImguiSharp.ImGuiPlatformIO self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPlatformIO_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPlatformMonitor ImGuiPlatformMonitorImGuiPlatformMonitor()
        {
            var __ret = __Internal.ImGuiPlatformMonitorImGuiPlatformMonitor();
            var __result0 = global::DearImguiSharp.ImGuiPlatformMonitor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPlatformMonitor_destroy(global::DearImguiSharp.ImGuiPlatformMonitor self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPlatformMonitor_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPlatformImeData ImGuiPlatformImeDataImGuiPlatformImeData()
        {
            var __ret = __Internal.ImGuiPlatformImeDataImGuiPlatformImeData();
            var __result0 = global::DearImguiSharp.ImGuiPlatformImeData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPlatformImeData_destroy(global::DearImguiSharp.ImGuiPlatformImeData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPlatformImeData_destroy(__arg0);
        }

        public static int GetKeyIndex(int key)
        {
            var __ret = __Internal.GetKeyIndex(key);
            return __ret;
        }

        public static uint ImHashData(__IntPtr data, IntPtr data_size, uint seed)
        {
            var __ret = __Internal.ImHashData(data, data_size, seed);
            return __ret;
        }

        public static uint ImHashStr(string data, IntPtr data_size, uint seed)
        {
            var __ret = __Internal.ImHashStr(data, data_size, seed);
            return __ret;
        }

        public static void ImQsort(__IntPtr @base, IntPtr count, IntPtr size_of_element, global::DearImguiSharp.Delegates.Func_int___IntPtr___IntPtr compare_func)
        {
            var __arg3 = compare_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(compare_func);
            __Internal.ImQsort(@base, count, size_of_element, __arg3);
        }

        public static uint ImAlphaBlendColors(uint col_a, uint col_b)
        {
            var __ret = __Internal.ImAlphaBlendColors(col_a, col_b);
            return __ret;
        }

        public static bool ImIsPowerOfTwoInt(int v)
        {
            var __ret = __Internal.ImIsPowerOfTwoInt(v);
            return __ret;
        }

        public static bool ImIsPowerOfTwoU64(ulong v)
        {
            var __ret = __Internal.ImIsPowerOfTwoU64(v);
            return __ret;
        }

        public static int ImUpperPowerOfTwo(int v)
        {
            var __ret = __Internal.ImUpperPowerOfTwo(v);
            return __ret;
        }

        public static int ImStricmp(string str1, string str2)
        {
            var __ret = __Internal.ImStricmp(str1, str2);
            return __ret;
        }

        public static int ImStrnicmp(string str1, string str2, IntPtr count)
        {
            var __ret = __Internal.ImStrnicmp(str1, str2, count);
            return __ret;
        }

        public static void ImStrncpy(sbyte* dst, string src, IntPtr count)
        {
            __Internal.ImStrncpy(dst, src, count);
        }

        public static sbyte* ImStrdup(string str)
        {
            var __ret = __Internal.ImStrdup(str);
            return __ret;
        }

        public static sbyte* ImStrdupcpy(sbyte* dst, ref IntPtr p_dst_size, string str)
        {
            fixed (IntPtr* __p_dst_size1 = &p_dst_size)
            {
                var __arg1 = __p_dst_size1;
                var __ret = __Internal.ImStrdupcpy(dst, __arg1, str);
                return __ret;
            }
        }

        public static string ImStrchrRange(string str_begin, string str_end, sbyte c)
        {
            var __ret = __Internal.ImStrchrRange(str_begin, str_end, c);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImStrlenW(ref ushort str)
        {
            fixed (ushort* __str0 = &str)
            {
                var __arg0 = __str0;
                var __ret = __Internal.ImStrlenW(__arg0);
                return __ret;
            }
        }

        public static string ImStreolRange(string str, string str_end)
        {
            var __ret = __Internal.ImStreolRange(str, str_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static ushort* ImStrbolW(ref ushort buf_mid_line, ref ushort buf_begin)
        {
            fixed (ushort* __buf_mid_line0 = &buf_mid_line)
            {
                var __arg0 = __buf_mid_line0;
                fixed (ushort* __buf_begin1 = &buf_begin)
                {
                    var __arg1 = __buf_begin1;
                    var __ret = __Internal.ImStrbolW(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static string ImStristr(string haystack, string haystack_end, string needle, string needle_end)
        {
            var __ret = __Internal.ImStristr(haystack, haystack_end, needle, needle_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImStrTrimBlanks(sbyte* str)
        {
            __Internal.ImStrTrimBlanks(str);
        }

        public static string ImStrSkipBlank(string str)
        {
            var __ret = __Internal.ImStrSkipBlank(str);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static bool ImCharIsBlankA(sbyte c)
        {
            var __ret = __Internal.ImCharIsBlankA(c);
            return __ret;
        }

        public static bool ImCharIsBlankW(uint c)
        {
            var __ret = __Internal.ImCharIsBlankW(c);
            return __ret;
        }

        public static int ImFormatString(sbyte* buf, IntPtr buf_size, string fmt)
        {
            var __ret = __Internal.ImFormatString(buf, buf_size, fmt);
            return __ret;
        }

        public static void ImFormatStringToTempBuffer(sbyte** out_buf, sbyte** out_buf_end, string fmt)
        {
            __Internal.ImFormatStringToTempBuffer(out_buf, out_buf_end, fmt);
        }

        public static string ImParseFormatFindStart(string format)
        {
            var __ret = __Internal.ImParseFormatFindStart(format);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImParseFormatFindEnd(string format)
        {
            var __ret = __Internal.ImParseFormatFindEnd(format);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static string ImParseFormatTrimDecorations(string format, sbyte* buf, IntPtr buf_size)
        {
            var __ret = __Internal.ImParseFormatTrimDecorations(format, buf, buf_size);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void ImParseFormatSanitizeForPrinting(string fmt_in, sbyte* fmt_out, IntPtr fmt_out_size)
        {
            __Internal.ImParseFormatSanitizeForPrinting(fmt_in, fmt_out, fmt_out_size);
        }

        public static string ImParseFormatSanitizeForScanning(string fmt_in, sbyte* fmt_out, IntPtr fmt_out_size)
        {
            var __ret = __Internal.ImParseFormatSanitizeForScanning(fmt_in, fmt_out, fmt_out_size);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImParseFormatPrecision(string format, int default_value)
        {
            var __ret = __Internal.ImParseFormatPrecision(format, default_value);
            return __ret;
        }

        public static string ImTextCharToUtf8(sbyte[] out_buf, uint c)
        {
            if (out_buf == null || out_buf.Length != 5)
                throw new ArgumentOutOfRangeException("out_buf", "The dimensions of the provided array don't match the required size.");
            var __ret = __Internal.ImTextCharToUtf8(out_buf, c);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static int ImTextStrToUtf8(sbyte* out_buf, int out_buf_size, ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text2 = &in_text)
            {
                var __arg2 = __in_text2;
                fixed (ushort* __in_text_end3 = &in_text_end)
                {
                    var __arg3 = __in_text_end3;
                    var __ret = __Internal.ImTextStrToUtf8(out_buf, out_buf_size, __arg2, __arg3);
                    return __ret;
                }
            }
        }

        public static int ImTextCharFromUtf8(ref uint out_char, string in_text, string in_text_end)
        {
            fixed (uint* __out_char0 = &out_char)
            {
                var __arg0 = __out_char0;
                var __ret = __Internal.ImTextCharFromUtf8(__arg0, in_text, in_text_end);
                return __ret;
            }
        }

        public static int ImTextStrFromUtf8(ref ushort out_buf, int out_buf_size, string in_text, string in_text_end, sbyte** in_remaining)
        {
            fixed (ushort* __out_buf0 = &out_buf)
            {
                var __arg0 = __out_buf0;
                var __ret = __Internal.ImTextStrFromUtf8(__arg0, out_buf_size, in_text, in_text_end, in_remaining);
                return __ret;
            }
        }

        public static int ImTextCountCharsFromUtf8(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountCharsFromUtf8(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromChar(string in_text, string in_text_end)
        {
            var __ret = __Internal.ImTextCountUtf8BytesFromChar(in_text, in_text_end);
            return __ret;
        }

        public static int ImTextCountUtf8BytesFromStr(ref ushort in_text, ref ushort in_text_end)
        {
            fixed (ushort* __in_text0 = &in_text)
            {
                var __arg0 = __in_text0;
                fixed (ushort* __in_text_end1 = &in_text_end)
                {
                    var __arg1 = __in_text_end1;
                    var __ret = __Internal.ImTextCountUtf8BytesFromStr(__arg0, __arg1);
                    return __ret;
                }
            }
        }

        public static global::System.IntPtr ImFileOpen(string filename, string mode)
        {
            var __ret = __Internal.ImFileOpen(filename, mode);
            return __ret;
        }

        public static bool ImFileClose(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileClose(file);
            return __ret;
        }

        public static ulong ImFileGetSize(global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileGetSize(file);
            return __ret;
        }

        public static ulong ImFileRead(__IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileRead(data, size, count, file);
            return __ret;
        }

        public static ulong ImFileWrite(__IntPtr data, ulong size, ulong count, global::System.IntPtr file)
        {
            var __ret = __Internal.ImFileWrite(data, size, count, file);
            return __ret;
        }

        public static __IntPtr ImFileLoadToMemory(string filename, string mode, ref IntPtr out_file_size, int padding_bytes)
        {
            fixed (IntPtr* __out_file_size2 = &out_file_size)
            {
                var __arg2 = __out_file_size2;
                var __ret = __Internal.ImFileLoadToMemory(filename, mode, __arg2, padding_bytes);
                return __ret;
            }
        }

        public static float ImPowFloat(float x, float y)
        {
            var __ret = __Internal.ImPowFloat(x, y);
            return __ret;
        }

        public static double ImPow_double(double x, double y)
        {
            var __ret = __Internal.ImPow_double(x, y);
            return __ret;
        }

        public static float ImLogFloat(float x)
        {
            var __ret = __Internal.ImLogFloat(x);
            return __ret;
        }

        public static double ImLog_double(double x)
        {
            var __ret = __Internal.ImLog_double(x);
            return __ret;
        }

        public static int ImAbsInt(int x)
        {
            var __ret = __Internal.ImAbsInt(x);
            return __ret;
        }

        public static float ImAbsFloat(float x)
        {
            var __ret = __Internal.ImAbsFloat(x);
            return __ret;
        }

        public static double ImAbs_double(double x)
        {
            var __ret = __Internal.ImAbs_double(x);
            return __ret;
        }

        public static float ImSignFloat(float x)
        {
            var __ret = __Internal.ImSignFloat(x);
            return __ret;
        }

        public static double ImSign_double(double x)
        {
            var __ret = __Internal.ImSign_double(x);
            return __ret;
        }

        public static float ImRsqrtFloat(float x)
        {
            var __ret = __Internal.ImRsqrtFloat(x);
            return __ret;
        }

        public static double ImRsqrt_double(double x)
        {
            var __ret = __Internal.ImRsqrt_double(x);
            return __ret;
        }

        public static void ImMin(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 lhs, global::DearImguiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMin(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImMax(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 lhs, global::DearImguiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMax(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImClamp(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 v, global::DearImguiSharp.ImVec2 mn, global::DearImguiSharp.ImVec2 mx)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            if (ReferenceEquals(mn, null))
                throw new global::System.ArgumentNullException("mn", "Cannot be null because it is passed by value.");
            var __arg2 = mn.__Instance;
            if (ReferenceEquals(mx, null))
                throw new global::System.ArgumentNullException("mx", "Cannot be null because it is passed by value.");
            var __arg3 = mx.__Instance;
            __Internal.ImClamp(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec2Float(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec2Float(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, t);
        }

        public static void ImLerpVec2Vec2(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(t, null))
                throw new global::System.ArgumentNullException("t", "Cannot be null because it is passed by value.");
            var __arg3 = t.__Instance;
            __Internal.ImLerpVec2Vec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImLerpVec4(global::DearImguiSharp.ImVec4 pOut, global::DearImguiSharp.ImVec4 a, global::DearImguiSharp.ImVec4 b, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            __Internal.ImLerpVec4(__arg0, *(global::DearImguiSharp.ImVec4.__Internal*) __arg1, *(global::DearImguiSharp.ImVec4.__Internal*) __arg2, t);
        }

        public static float ImSaturate(float f)
        {
            var __ret = __Internal.ImSaturate(f);
            return __ret;
        }

        public static float ImLengthSqrVec2(global::DearImguiSharp.ImVec2 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
            return __ret;
        }

        public static float ImLengthSqrVec4(global::DearImguiSharp.ImVec4 lhs)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImLengthSqrVec4(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0);
            return __ret;
        }

        public static float ImInvLength(global::DearImguiSharp.ImVec2 lhs, float fail_value)
        {
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg0 = lhs.__Instance;
            var __ret = __Internal.ImInvLength(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, fail_value);
            return __ret;
        }

        public static float ImFloorFloat(float f)
        {
            var __ret = __Internal.ImFloorFloat(f);
            return __ret;
        }

        public static float ImFloorSignedFloat(float f)
        {
            var __ret = __Internal.ImFloorSignedFloat(f);
            return __ret;
        }

        public static void ImFloorVec2(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 v)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImFloorVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImFloorSignedVec2(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 v)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImFloorSignedVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static int ImModPositive(int a, int b)
        {
            var __ret = __Internal.ImModPositive(a, b);
            return __ret;
        }

        public static float ImDot(global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            var __ret = __Internal.ImDot(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static void ImRotate(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 v, float cos_a, float sin_a)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            __Internal.ImRotate(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cos_a, sin_a);
        }

        public static float ImLinearSweep(float current, float target, float speed)
        {
            var __ret = __Internal.ImLinearSweep(current, target, speed);
            return __ret;
        }

        public static void ImMul(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 lhs, global::DearImguiSharp.ImVec2 rhs)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(lhs, null))
                throw new global::System.ArgumentNullException("lhs", "Cannot be null because it is passed by value.");
            var __arg1 = lhs.__Instance;
            if (ReferenceEquals(rhs, null))
                throw new global::System.ArgumentNullException("rhs", "Cannot be null because it is passed by value.");
            var __arg2 = rhs.__Instance;
            __Internal.ImMul(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static bool ImIsFloatAboveGuaranteedIntegerPrecision(float f)
        {
            var __ret = __Internal.ImIsFloatAboveGuaranteedIntegerPrecision(f);
            return __ret;
        }

        public static void ImBezierCubicCalc(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            __Internal.ImBezierCubicCalc(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, t);
        }

        public static void ImBezierCubicClosestPoint(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, global::DearImguiSharp.ImVec2 p, int num_segments)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierCubicClosestPoint(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, num_segments);
        }

        public static void ImBezierCubicClosestPointCasteljau(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, global::DearImguiSharp.ImVec2 p4, global::DearImguiSharp.ImVec2 p, float tess_tol)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            if (ReferenceEquals(p4, null))
                throw new global::System.ArgumentNullException("p4", "Cannot be null because it is passed by value.");
            var __arg4 = p4.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg5 = p.__Instance;
            __Internal.ImBezierCubicClosestPointCasteljau(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, tess_tol);
        }

        public static void ImBezierQuadraticCalc(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 p1, global::DearImguiSharp.ImVec2 p2, global::DearImguiSharp.ImVec2 p3, float t)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(p1, null))
                throw new global::System.ArgumentNullException("p1", "Cannot be null because it is passed by value.");
            var __arg1 = p1.__Instance;
            if (ReferenceEquals(p2, null))
                throw new global::System.ArgumentNullException("p2", "Cannot be null because it is passed by value.");
            var __arg2 = p2.__Instance;
            if (ReferenceEquals(p3, null))
                throw new global::System.ArgumentNullException("p3", "Cannot be null because it is passed by value.");
            var __arg3 = p3.__Instance;
            __Internal.ImBezierQuadraticCalc(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, t);
        }

        public static void ImLineClosestPoint(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 p)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            __Internal.ImLineClosestPoint(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
        }

        public static bool ImTriangleContainsPoint(global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c, global::DearImguiSharp.ImVec2 p)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            var __ret = __Internal.ImTriangleContainsPoint(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
            return __ret;
        }

        public static void ImTriangleClosestPoint(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c, global::DearImguiSharp.ImVec2 p)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg1 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg2 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg3 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg4 = p.__Instance;
            __Internal.ImTriangleClosestPoint(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4);
        }

        public static void ImTriangleBarycentricCoords(global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c, global::DearImguiSharp.ImVec2 p, ref float out_u, ref float out_v, ref float out_w)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg3 = p.__Instance;
            fixed (float* __out_u4 = &out_u)
            {
                var __arg4 = __out_u4;
                fixed (float* __out_v5 = &out_v)
                {
                    var __arg5 = __out_v5;
                    fixed (float* __out_w6 = &out_w)
                    {
                        var __arg6 = __out_w6;
                        __Internal.ImTriangleBarycentricCoords(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, __arg4, __arg5, __arg6);
                    }
                }
            }
        }

        public static float ImTriangleArea(global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 c)
        {
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg0 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg1 = b.__Instance;
            if (ReferenceEquals(c, null))
                throw new global::System.ArgumentNullException("c", "Cannot be null because it is passed by value.");
            var __arg2 = c.__Instance;
            var __ret = __Internal.ImTriangleArea(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
            return __ret;
        }

        public static int ImGetDirQuadrantFromDelta(float dx, float dy)
        {
            var __ret = __Internal.ImGetDirQuadrantFromDelta(dx, dy);
            return __ret;
        }

        public static global::DearImguiSharp.ImVec1 ImVec1ImVec1Nil()
        {
            var __ret = __Internal.ImVec1ImVec1Nil();
            var __result0 = global::DearImguiSharp.ImVec1.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec1_destroy(global::DearImguiSharp.ImVec1 self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec1_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec1 ImVec1ImVec1Float(float _x)
        {
            var __ret = __Internal.ImVec1ImVec1Float(_x);
            var __result0 = global::DearImguiSharp.ImVec1.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImVec2ih ImVec2ihImVec2ihNil()
        {
            var __ret = __Internal.ImVec2ihImVec2ihNil();
            var __result0 = global::DearImguiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVec2ih_destroy(global::DearImguiSharp.ImVec2ih self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVec2ih_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImVec2ih ImVec2ihImVec2ih_short(short _x, short _y)
        {
            var __ret = __Internal.ImVec2ihImVec2ih_short(_x, _y);
            var __result0 = global::DearImguiSharp.ImVec2ih.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImRect ImRectImRectNil()
        {
            var __ret = __Internal.ImRectImRectNil();
            var __result0 = global::DearImguiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImRect_destroy(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRect_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImRect ImRectImRectVec2(global::DearImguiSharp.ImVec2 min, global::DearImguiSharp.ImVec2 max)
        {
            if (ReferenceEquals(min, null))
                throw new global::System.ArgumentNullException("min", "Cannot be null because it is passed by value.");
            var __arg0 = min.__Instance;
            if (ReferenceEquals(max, null))
                throw new global::System.ArgumentNullException("max", "Cannot be null because it is passed by value.");
            var __arg1 = max.__Instance;
            var __ret = __Internal.ImRectImRectVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            var __result0 = global::DearImguiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImRect ImRectImRectVec4(global::DearImguiSharp.ImVec4 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg0 = v.__Instance;
            var __ret = __Internal.ImRectImRectVec4(*(global::DearImguiSharp.ImVec4.__Internal*) __arg0);
            var __result0 = global::DearImguiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImRect ImRectImRectFloat(float x1, float y1, float x2, float y2)
        {
            var __ret = __Internal.ImRectImRectFloat(x1, y1, x2, y2);
            var __result0 = global::DearImguiSharp.ImRect.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImRectGetCenter(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetCenter(__arg0, __arg1);
        }

        public static void ImRectGetSize(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetSize(__arg0, __arg1);
        }

        public static float ImRectGetWidth(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetWidth(__arg0);
            return __ret;
        }

        public static float ImRectGetHeight(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetHeight(__arg0);
            return __ret;
        }

        public static float ImRectGetArea(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectGetArea(__arg0);
            return __ret;
        }

        public static void ImRectGetTL(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTL(__arg0, __arg1);
        }

        public static void ImRectGetTR(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetTR(__arg0, __arg1);
        }

        public static void ImRectGetBL(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBL(__arg0, __arg1);
        }

        public static void ImRectGetBR(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectGetBR(__arg0, __arg1);
        }

        public static bool ImRectContainsVec2(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImVec2 p)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            var __ret = __Internal.ImRectContainsVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool ImRectContainsRect(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectContainsRect(__arg0, __arg1);
            return __ret;
        }

        public static bool ImRectOverlaps(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            var __ret = __Internal.ImRectOverlaps(__arg0, __arg1);
            return __ret;
        }

        public static void ImRectAddVec2(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImVec2 p)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(p, null))
                throw new global::System.ArgumentNullException("p", "Cannot be null because it is passed by value.");
            var __arg1 = p.__Instance;
            __Internal.ImRectAddVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectAddRect(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectAddRect(__arg0, __arg1);
        }

        public static void ImRectExpandFloat(global::DearImguiSharp.ImRect self, float amount)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectExpandFloat(__arg0, amount);
        }

        public static void ImRectExpandVec2(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImVec2 amount)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(amount, null))
                throw new global::System.ArgumentNullException("amount", "Cannot be null because it is passed by value.");
            var __arg1 = amount.__Instance;
            __Internal.ImRectExpandVec2(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslate(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImVec2 d)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(d, null))
                throw new global::System.ArgumentNullException("d", "Cannot be null because it is passed by value.");
            var __arg1 = d.__Instance;
            __Internal.ImRectTranslate(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void ImRectTranslateX(global::DearImguiSharp.ImRect self, float dx)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateX(__arg0, dx);
        }

        public static void ImRectTranslateY(global::DearImguiSharp.ImRect self, float dy)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectTranslateY(__arg0, dy);
        }

        public static void ImRectClipWith(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWith(__arg0, __arg1);
        }

        public static void ImRectClipWithFull(global::DearImguiSharp.ImRect self, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg1 = r.__Instance;
            __Internal.ImRectClipWithFull(__arg0, __arg1);
        }

        public static void ImRectFloor(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectFloor(__arg0);
        }

        public static bool ImRectIsInverted(global::DearImguiSharp.ImRect self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImRectIsInverted(__arg0);
            return __ret;
        }

        public static void ImRectToVec4(global::DearImguiSharp.ImVec4 pOut, global::DearImguiSharp.ImRect self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImRectToVec4(__arg0, __arg1);
        }

        public static bool ImBitArrayTestBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                var __ret = __Internal.ImBitArrayTestBit(__arg0, n);
                return __ret;
            }
        }

        public static void ImBitArrayClearBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArrayClearBit(__arg0, n);
            }
        }

        public static void ImBitArraySetBit(ref uint arr, int n)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArraySetBit(__arg0, n);
            }
        }

        public static void ImBitArraySetBitRange(ref uint arr, int n, int n2)
        {
            fixed (uint* __arr0 = &arr)
            {
                var __arg0 = __arr0;
                __Internal.ImBitArraySetBitRange(__arg0, n, n2);
            }
        }

        public static void ImBitVectorCreate(global::DearImguiSharp.ImBitVector self, int sz)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorCreate(__arg0, sz);
        }

        public static void ImBitVectorClear(global::DearImguiSharp.ImBitVector self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorClear(__arg0);
        }

        public static bool ImBitVectorTestBit(global::DearImguiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImBitVectorTestBit(__arg0, n);
            return __ret;
        }

        public static void ImBitVectorSetBit(global::DearImguiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorSetBit(__arg0, n);
        }

        public static void ImBitVectorClearBit(global::DearImguiSharp.ImBitVector self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImBitVectorClearBit(__arg0, n);
        }

        public static global::DearImguiSharp.ImDrawListSharedData ImDrawListSharedDataImDrawListSharedData()
        {
            var __ret = __Internal.ImDrawListSharedDataImDrawListSharedData();
            var __result0 = global::DearImguiSharp.ImDrawListSharedData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImDrawListSharedData_destroy(global::DearImguiSharp.ImDrawListSharedData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedData_destroy(__arg0);
        }

        public static void ImDrawListSharedDataSetCircleTessellationMaxError(global::DearImguiSharp.ImDrawListSharedData self, float max_error)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawListSharedDataSetCircleTessellationMaxError(__arg0, max_error);
        }

        public static void ImDrawDataBuilderClear(global::DearImguiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClear(__arg0);
        }

        public static void ImDrawDataBuilderClearFreeMemory(global::DearImguiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderClearFreeMemory(__arg0);
        }

        public static int ImDrawDataBuilderGetDrawListCount(global::DearImguiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImDrawDataBuilderGetDrawListCount(__arg0);
            return __ret;
        }

        public static void ImDrawDataBuilderFlattenIntoSingleLayer(global::DearImguiSharp.ImDrawDataBuilder self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImDrawDataBuilderFlattenIntoSingleLayer(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModInt(int idx, int v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModInt(idx, v);
            var __result0 = global::DearImguiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStyleMod_destroy(global::DearImguiSharp.ImGuiStyleMod self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStyleMod_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModFloat(int idx, float v)
        {
            var __ret = __Internal.ImGuiStyleModImGuiStyleModFloat(idx, v);
            var __result0 = global::DearImguiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiStyleMod ImGuiStyleModImGuiStyleModVec2(int idx, global::DearImguiSharp.ImVec2 v)
        {
            if (ReferenceEquals(v, null))
                throw new global::System.ArgumentNullException("v", "Cannot be null because it is passed by value.");
            var __arg1 = v.__Instance;
            var __ret = __Internal.ImGuiStyleModImGuiStyleModVec2(idx, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            var __result0 = global::DearImguiSharp.ImGuiStyleMod.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiComboPreviewData ImGuiComboPreviewDataImGuiComboPreviewData()
        {
            var __ret = __Internal.ImGuiComboPreviewDataImGuiComboPreviewData();
            var __result0 = global::DearImguiSharp.ImGuiComboPreviewData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiComboPreviewData_destroy(global::DearImguiSharp.ImGuiComboPreviewData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiComboPreviewData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiMenuColumns ImGuiMenuColumnsImGuiMenuColumns()
        {
            var __ret = __Internal.ImGuiMenuColumnsImGuiMenuColumns();
            var __result0 = global::DearImguiSharp.ImGuiMenuColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiMenuColumns_destroy(global::DearImguiSharp.ImGuiMenuColumns self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumns_destroy(__arg0);
        }

        public static void ImGuiMenuColumnsUpdate(global::DearImguiSharp.ImGuiMenuColumns self, float spacing, bool window_reappearing)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumnsUpdate(__arg0, spacing, window_reappearing);
        }

        public static float ImGuiMenuColumnsDeclColumns(global::DearImguiSharp.ImGuiMenuColumns self, float w_icon, float w_label, float w_shortcut, float w_mark)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiMenuColumnsDeclColumns(__arg0, w_icon, w_label, w_shortcut, w_mark);
            return __ret;
        }

        public static void ImGuiMenuColumnsCalcNextTotalWidth(global::DearImguiSharp.ImGuiMenuColumns self, bool update_offsets)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMenuColumnsCalcNextTotalWidth(__arg0, update_offsets);
        }

        public static global::DearImguiSharp.ImGuiInputTextState ImGuiInputTextStateImGuiInputTextState()
        {
            var __ret = __Internal.ImGuiInputTextStateImGuiInputTextState();
            var __result0 = global::DearImguiSharp.ImGuiInputTextState.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputTextState_destroy(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextState_destroy(__arg0);
        }

        public static void ImGuiInputTextStateClearText(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearText(__arg0);
        }

        public static void ImGuiInputTextStateClearFreeMemory(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearFreeMemory(__arg0);
        }

        public static int ImGuiInputTextStateGetUndoAvailCount(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetUndoAvailCount(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetRedoAvailCount(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetRedoAvailCount(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateOnKeyPressed(global::DearImguiSharp.ImGuiInputTextState self, int key)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateOnKeyPressed(__arg0, key);
        }

        public static void ImGuiInputTextStateCursorAnimReset(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorAnimReset(__arg0);
        }

        public static void ImGuiInputTextStateCursorClamp(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateCursorClamp(__arg0);
        }

        public static bool ImGuiInputTextStateHasSelection(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateHasSelection(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateClearSelection(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateClearSelection(__arg0);
        }

        public static int ImGuiInputTextStateGetCursorPos(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetCursorPos(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetSelectionStart(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetSelectionStart(__arg0);
            return __ret;
        }

        public static int ImGuiInputTextStateGetSelectionEnd(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiInputTextStateGetSelectionEnd(__arg0);
            return __ret;
        }

        public static void ImGuiInputTextStateSelectAll(global::DearImguiSharp.ImGuiInputTextState self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputTextStateSelectAll(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPopupData ImGuiPopupDataImGuiPopupData()
        {
            var __ret = __Internal.ImGuiPopupDataImGuiPopupData();
            var __result0 = global::DearImguiSharp.ImGuiPopupData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPopupData_destroy(global::DearImguiSharp.ImGuiPopupData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPopupData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiNextWindowData ImGuiNextWindowDataImGuiNextWindowData()
        {
            var __ret = __Internal.ImGuiNextWindowDataImGuiNextWindowData();
            var __result0 = global::DearImguiSharp.ImGuiNextWindowData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNextWindowData_destroy(global::DearImguiSharp.ImGuiNextWindowData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowData_destroy(__arg0);
        }

        public static void ImGuiNextWindowDataClearFlags(global::DearImguiSharp.ImGuiNextWindowData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextWindowDataClearFlags(__arg0);
        }

        public static global::DearImguiSharp.ImGuiNextItemData ImGuiNextItemDataImGuiNextItemData()
        {
            var __ret = __Internal.ImGuiNextItemDataImGuiNextItemData();
            var __result0 = global::DearImguiSharp.ImGuiNextItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNextItemData_destroy(global::DearImguiSharp.ImGuiNextItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemData_destroy(__arg0);
        }

        public static void ImGuiNextItemDataClearFlags(global::DearImguiSharp.ImGuiNextItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNextItemDataClearFlags(__arg0);
        }

        public static global::DearImguiSharp.ImGuiLastItemData ImGuiLastItemDataImGuiLastItemData()
        {
            var __ret = __Internal.ImGuiLastItemDataImGuiLastItemData();
            var __result0 = global::DearImguiSharp.ImGuiLastItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiLastItemData_destroy(global::DearImguiSharp.ImGuiLastItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiLastItemData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStackSizes ImGuiStackSizesImGuiStackSizes()
        {
            var __ret = __Internal.ImGuiStackSizesImGuiStackSizes();
            var __result0 = global::DearImguiSharp.ImGuiStackSizes.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackSizes_destroy(global::DearImguiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizes_destroy(__arg0);
        }

        public static void ImGuiStackSizesSetToCurrentState(global::DearImguiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizesSetToCurrentState(__arg0);
        }

        public static void ImGuiStackSizesCompareWithCurrentState(global::DearImguiSharp.ImGuiStackSizes self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackSizesCompareWithCurrentState(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexPtr(__IntPtr ptr)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexPtr(ptr);
            var __result0 = global::DearImguiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiPtrOrIndex_destroy(global::DearImguiSharp.ImGuiPtrOrIndex self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiPtrOrIndex_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiPtrOrIndex ImGuiPtrOrIndexImGuiPtrOrIndexInt(int index)
        {
            var __ret = __Internal.ImGuiPtrOrIndexImGuiPtrOrIndexInt(index);
            var __result0 = global::DearImguiSharp.ImGuiPtrOrIndex.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiInputEvent ImGuiInputEventImGuiInputEvent()
        {
            var __ret = __Internal.ImGuiInputEventImGuiInputEvent();
            var __result0 = global::DearImguiSharp.ImGuiInputEvent.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiInputEvent_destroy(global::DearImguiSharp.ImGuiInputEvent self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiInputEvent_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiListClipperRange ImGuiListClipperRangeFromIndices(int min, int max)
        {
            var __ret = new global::DearImguiSharp.ImGuiListClipperRange.__Internal();
            __Internal.ImGuiListClipperRangeFromIndices(new IntPtr(&__ret), min, max);
            return global::DearImguiSharp.ImGuiListClipperRange.__CreateInstance(__ret);
        }

        public static global::DearImguiSharp.ImGuiListClipperRange ImGuiListClipperRangeFromPositions(float y1, float y2, int off_min, int off_max)
        {
            var __ret = new global::DearImguiSharp.ImGuiListClipperRange.__Internal();
            __Internal.ImGuiListClipperRangeFromPositions(new IntPtr(&__ret), y1, y2, off_min, off_max);
            return global::DearImguiSharp.ImGuiListClipperRange.__CreateInstance(__ret);
        }

        public static global::DearImguiSharp.ImGuiListClipperData ImGuiListClipperDataImGuiListClipperData()
        {
            var __ret = __Internal.ImGuiListClipperDataImGuiListClipperData();
            var __result0 = global::DearImguiSharp.ImGuiListClipperData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiListClipperData_destroy(global::DearImguiSharp.ImGuiListClipperData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiListClipperData_destroy(__arg0);
        }

        public static void ImGuiListClipperDataReset(global::DearImguiSharp.ImGuiListClipperData self, global::DearImguiSharp.ImGuiListClipper clipper)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = clipper is null ? __IntPtr.Zero : clipper.__Instance;
            __Internal.ImGuiListClipperDataReset(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiNavItemData ImGuiNavItemDataImGuiNavItemData()
        {
            var __ret = __Internal.ImGuiNavItemDataImGuiNavItemData();
            var __result0 = global::DearImguiSharp.ImGuiNavItemData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiNavItemData_destroy(global::DearImguiSharp.ImGuiNavItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavItemData_destroy(__arg0);
        }

        public static void ImGuiNavItemDataClear(global::DearImguiSharp.ImGuiNavItemData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiNavItemDataClear(__arg0);
        }

        public static global::DearImguiSharp.ImGuiOldColumnData ImGuiOldColumnDataImGuiOldColumnData()
        {
            var __ret = __Internal.ImGuiOldColumnDataImGuiOldColumnData();
            var __result0 = global::DearImguiSharp.ImGuiOldColumnData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOldColumnData_destroy(global::DearImguiSharp.ImGuiOldColumnData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOldColumnData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiOldColumns ImGuiOldColumnsImGuiOldColumns()
        {
            var __ret = __Internal.ImGuiOldColumnsImGuiOldColumns();
            var __result0 = global::DearImguiSharp.ImGuiOldColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiOldColumns_destroy(global::DearImguiSharp.ImGuiOldColumns self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiOldColumns_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiDockNode ImGuiDockNodeImGuiDockNode(uint id)
        {
            var __ret = __Internal.ImGuiDockNodeImGuiDockNode(id);
            var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiDockNode_destroy(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiDockNode_destroy(__arg0);
        }

        public static bool ImGuiDockNodeIsRootNode(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsRootNode(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsDockSpace(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsDockSpace(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsFloatingNode(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsFloatingNode(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsCentralNode(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsCentralNode(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsHiddenTabBar(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsHiddenTabBar(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsNoTabBar(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsNoTabBar(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsSplitNode(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsSplitNode(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsLeafNode(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsLeafNode(__arg0);
            return __ret;
        }

        public static bool ImGuiDockNodeIsEmpty(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiDockNodeIsEmpty(__arg0);
            return __ret;
        }

        public static void ImGuiDockNodeRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiDockNodeRect(__arg0, __arg1);
        }

        public static void ImGuiDockNodeSetLocalFlags(global::DearImguiSharp.ImGuiDockNode self, int flags)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiDockNodeSetLocalFlags(__arg0, flags);
        }

        public static void ImGuiDockNodeUpdateMergedFlags(global::DearImguiSharp.ImGuiDockNode self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiDockNodeUpdateMergedFlags(__arg0);
        }

        public static global::DearImguiSharp.ImGuiDockContext ImGuiDockContextImGuiDockContext()
        {
            var __ret = __Internal.ImGuiDockContextImGuiDockContext();
            var __result0 = global::DearImguiSharp.ImGuiDockContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiDockContext_destroy(global::DearImguiSharp.ImGuiDockContext self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiDockContext_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiViewportP ImGuiViewportP_ImGuiViewportP()
        {
            var __ret = __Internal.ImGuiViewportP_ImGuiViewportP();
            var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiViewportP_destroy(global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_destroy(__arg0);
        }

        public static void ImGuiViewportP_ClearRequestFlags(global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_ClearRequestFlags(__arg0);
        }

        public static void ImGuiViewportP_CalcWorkRectPos(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewportP self, global::DearImguiSharp.ImVec2 off_min)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(off_min, null))
                throw new global::System.ArgumentNullException("off_min", "Cannot be null because it is passed by value.");
            var __arg2 = off_min.__Instance;
            __Internal.ImGuiViewportP_CalcWorkRectPos(__arg0, __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ImGuiViewportP_CalcWorkRectSize(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiViewportP self, global::DearImguiSharp.ImVec2 off_min, global::DearImguiSharp.ImVec2 off_max)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(off_min, null))
                throw new global::System.ArgumentNullException("off_min", "Cannot be null because it is passed by value.");
            var __arg2 = off_min.__Instance;
            if (ReferenceEquals(off_max, null))
                throw new global::System.ArgumentNullException("off_max", "Cannot be null because it is passed by value.");
            var __arg3 = off_max.__Instance;
            __Internal.ImGuiViewportP_CalcWorkRectSize(__arg0, __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3);
        }

        public static void ImGuiViewportP_UpdateWorkRect(global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_UpdateWorkRect(__arg0);
        }

        public static void ImGuiViewportP_GetMainRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetMainRect(__arg0, __arg1);
        }

        public static void ImGuiViewportP_GetWorkRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetWorkRect(__arg0, __arg1);
        }

        public static void ImGuiViewportP_GetBuildWorkRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiViewportP self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiViewportP_GetBuildWorkRect(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiWindowSettings ImGuiWindowSettingsImGuiWindowSettings()
        {
            var __ret = __Internal.ImGuiWindowSettingsImGuiWindowSettings();
            var __result0 = global::DearImguiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiWindowSettings_destroy(global::DearImguiSharp.ImGuiWindowSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowSettings_destroy(__arg0);
        }

        public static sbyte* ImGuiWindowSettingsGetName(global::DearImguiSharp.ImGuiWindowSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowSettingsGetName(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiSettingsHandler ImGuiSettingsHandlerImGuiSettingsHandler()
        {
            var __ret = __Internal.ImGuiSettingsHandlerImGuiSettingsHandler();
            var __result0 = global::DearImguiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiSettingsHandler_destroy(global::DearImguiSharp.ImGuiSettingsHandler self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiSettingsHandler_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiMetricsConfig ImGuiMetricsConfigImGuiMetricsConfig()
        {
            var __ret = __Internal.ImGuiMetricsConfigImGuiMetricsConfig();
            var __result0 = global::DearImguiSharp.ImGuiMetricsConfig.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiMetricsConfig_destroy(global::DearImguiSharp.ImGuiMetricsConfig self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiMetricsConfig_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStackLevelInfo ImGuiStackLevelInfoImGuiStackLevelInfo()
        {
            var __ret = __Internal.ImGuiStackLevelInfoImGuiStackLevelInfo();
            var __result0 = global::DearImguiSharp.ImGuiStackLevelInfo.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackLevelInfo_destroy(global::DearImguiSharp.ImGuiStackLevelInfo self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackLevelInfo_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiStackTool ImGuiStackToolImGuiStackTool()
        {
            var __ret = __Internal.ImGuiStackToolImGuiStackTool();
            var __result0 = global::DearImguiSharp.ImGuiStackTool.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiStackTool_destroy(global::DearImguiSharp.ImGuiStackTool self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiStackTool_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiContextHook ImGuiContextHookImGuiContextHook()
        {
            var __ret = __Internal.ImGuiContextHookImGuiContextHook();
            var __result0 = global::DearImguiSharp.ImGuiContextHook.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiContextHook_destroy(global::DearImguiSharp.ImGuiContextHook self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiContextHook_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiContext ImGuiContextImGuiContext(global::DearImguiSharp.ImFontAtlas shared_font_atlas)
        {
            var __arg0 = shared_font_atlas is null ? __IntPtr.Zero : shared_font_atlas.__Instance;
            var __ret = __Internal.ImGuiContextImGuiContext(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiContext.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiContext_destroy(global::DearImguiSharp.ImGuiContext self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiContext_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiWindow ImGuiWindowImGuiWindow(global::DearImguiSharp.ImGuiContext context, string name)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __ret = __Internal.ImGuiWindowImGuiWindow(__arg0, name);
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiWindow_destroy(global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindow_destroy(__arg0);
        }

        public static uint ImGuiWindowGetID_Str(global::DearImguiSharp.ImGuiWindow self, string str, string str_end)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Str(__arg0, str, str_end);
            return __ret;
        }

        public static uint ImGuiWindowGetID_Ptr(global::DearImguiSharp.ImGuiWindow self, __IntPtr ptr)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Ptr(__arg0, ptr);
            return __ret;
        }

        public static uint ImGuiWindowGetID_Int(global::DearImguiSharp.ImGuiWindow self, int n)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowGetID_Int(__arg0, n);
            return __ret;
        }

        public static uint ImGuiWindowGetIDFromRectangle(global::DearImguiSharp.ImGuiWindow self, global::DearImguiSharp.ImRect r_abs)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            if (ReferenceEquals(r_abs, null))
                throw new global::System.ArgumentNullException("r_abs", "Cannot be null because it is passed by value.");
            var __arg1 = r_abs.__Instance;
            var __ret = __Internal.ImGuiWindowGetIDFromRectangle(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiWindowRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowRect(__arg0, __arg1);
        }

        public static float ImGuiWindowCalcFontSize(global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowCalcFontSize(__arg0);
            return __ret;
        }

        public static float ImGuiWindowTitleBarHeight(global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowTitleBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowTitleBarRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowTitleBarRect(__arg0, __arg1);
        }

        public static float ImGuiWindowMenuBarHeight(global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiWindowMenuBarHeight(__arg0);
            return __ret;
        }

        public static void ImGuiWindowMenuBarRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow self)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiWindowMenuBarRect(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiTabItem ImGuiTabItemImGuiTabItem()
        {
            var __ret = __Internal.ImGuiTabItemImGuiTabItem();
            var __result0 = global::DearImguiSharp.ImGuiTabItem.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTabItem_destroy(global::DearImguiSharp.ImGuiTabItem self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabItem_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTabBar ImGuiTabBarImGuiTabBar()
        {
            var __ret = __Internal.ImGuiTabBarImGuiTabBar();
            var __result0 = global::DearImguiSharp.ImGuiTabBar.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTabBar_destroy(global::DearImguiSharp.ImGuiTabBar self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTabBar_destroy(__arg0);
        }

        public static int ImGuiTabBarGetTabOrder(global::DearImguiSharp.ImGuiTabBar self, global::DearImguiSharp.ImGuiTabItem tab)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabOrder(__arg0, __arg1);
            return __ret;
        }

        public static string ImGuiTabBarGetTabName(global::DearImguiSharp.ImGuiTabBar self, global::DearImguiSharp.ImGuiTabItem tab)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            var __ret = __Internal.ImGuiTabBarGetTabName(__arg0, __arg1);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static global::DearImguiSharp.ImGuiTableColumn ImGuiTableColumnImGuiTableColumn()
        {
            var __ret = __Internal.ImGuiTableColumnImGuiTableColumn();
            var __result0 = global::DearImguiSharp.ImGuiTableColumn.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumn_destroy(global::DearImguiSharp.ImGuiTableColumn self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumn_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableInstanceData ImGuiTableInstanceDataImGuiTableInstanceData()
        {
            var __ret = __Internal.ImGuiTableInstanceDataImGuiTableInstanceData();
            var __result0 = global::DearImguiSharp.ImGuiTableInstanceData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableInstanceData_destroy(global::DearImguiSharp.ImGuiTableInstanceData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableInstanceData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTable ImGuiTableImGuiTable()
        {
            var __ret = __Internal.ImGuiTableImGuiTable();
            var __result0 = global::DearImguiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTable_destroy(global::DearImguiSharp.ImGuiTable self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTable_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableTempData ImGuiTableTempDataImGuiTableTempData()
        {
            var __ret = __Internal.ImGuiTableTempDataImGuiTableTempData();
            var __result0 = global::DearImguiSharp.ImGuiTableTempData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableTempData_destroy(global::DearImguiSharp.ImGuiTableTempData self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableTempData_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableColumnSettings ImGuiTableColumnSettingsImGuiTableColumnSettings()
        {
            var __ret = __Internal.ImGuiTableColumnSettingsImGuiTableColumnSettings();
            var __result0 = global::DearImguiSharp.ImGuiTableColumnSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableColumnSettings_destroy(global::DearImguiSharp.ImGuiTableColumnSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableColumnSettings_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableSettings ImGuiTableSettingsImGuiTableSettings()
        {
            var __ret = __Internal.ImGuiTableSettingsImGuiTableSettings();
            var __result0 = global::DearImguiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImGuiTableSettings_destroy(global::DearImguiSharp.ImGuiTableSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImGuiTableSettings_destroy(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableColumnSettings ImGuiTableSettingsGetColumnSettings(global::DearImguiSharp.ImGuiTableSettings self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            var __ret = __Internal.ImGuiTableSettingsGetColumnSettings(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiTableColumnSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindow GetCurrentWindowRead()
        {
            var __ret = __Internal.GetCurrentWindowRead();
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindow GetCurrentWindow()
        {
            var __ret = __Internal.GetCurrentWindow();
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindow FindWindowByID(uint id)
        {
            var __ret = __Internal.FindWindowByID(id);
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindow FindWindowByName(string name)
        {
            var __ret = __Internal.FindWindowByName(name);
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void UpdateWindowParentAndRootLinks(global::DearImguiSharp.ImGuiWindow window, int flags, global::DearImguiSharp.ImGuiWindow parent_window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg2 = parent_window is null ? __IntPtr.Zero : parent_window.__Instance;
            __Internal.UpdateWindowParentAndRootLinks(__arg0, flags, __arg2);
        }

        public static void CalcWindowNextAutoFitSize(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.CalcWindowNextAutoFitSize(__arg0, __arg1);
        }

        public static bool IsWindowChildOf(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiWindow potential_parent, bool popup_hierarchy, bool dock_hierarchy)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = potential_parent is null ? __IntPtr.Zero : potential_parent.__Instance;
            var __ret = __Internal.IsWindowChildOf(__arg0, __arg1, popup_hierarchy, dock_hierarchy);
            return __ret;
        }

        public static bool IsWindowWithinBeginStackOf(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiWindow potential_parent)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = potential_parent is null ? __IntPtr.Zero : potential_parent.__Instance;
            var __ret = __Internal.IsWindowWithinBeginStackOf(__arg0, __arg1);
            return __ret;
        }

        public static bool IsWindowAbove(global::DearImguiSharp.ImGuiWindow potential_above, global::DearImguiSharp.ImGuiWindow potential_below)
        {
            var __arg0 = potential_above is null ? __IntPtr.Zero : potential_above.__Instance;
            var __arg1 = potential_below is null ? __IntPtr.Zero : potential_below.__Instance;
            var __ret = __Internal.IsWindowAbove(__arg0, __arg1);
            return __ret;
        }

        public static bool IsWindowNavFocusable(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.IsWindowNavFocusable(__arg0);
            return __ret;
        }

        public static void SetWindowPosWindowPtr(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImVec2 pos, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.SetWindowPosWindowPtr(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowSizeWindowPtr(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImVec2 size, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.SetWindowSizeWindowPtr(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, cond);
        }

        public static void SetWindowCollapsedWindowPtr(global::DearImguiSharp.ImGuiWindow window, bool collapsed, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetWindowCollapsedWindowPtr(__arg0, collapsed, cond);
        }

        public static void SetWindowHitTestHole(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 size)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            __Internal.SetWindowHitTestHole(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void WindowRectAbsToRel(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg2 = r.__Instance;
            __Internal.WindowRectAbsToRel(__arg0, __arg1, __arg2);
        }

        public static void WindowRectRelToAbs(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect r)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(r, null))
                throw new global::System.ArgumentNullException("r", "Cannot be null because it is passed by value.");
            var __arg2 = r.__Instance;
            __Internal.WindowRectRelToAbs(__arg0, __arg1, __arg2);
        }

        public static void FocusWindow(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.FocusWindow(__arg0);
        }

        public static void FocusTopMostWindowUnderOne(global::DearImguiSharp.ImGuiWindow under_this_window, global::DearImguiSharp.ImGuiWindow ignore_window)
        {
            var __arg0 = under_this_window is null ? __IntPtr.Zero : under_this_window.__Instance;
            var __arg1 = ignore_window is null ? __IntPtr.Zero : ignore_window.__Instance;
            __Internal.FocusTopMostWindowUnderOne(__arg0, __arg1);
        }

        public static void BringWindowToFocusFront(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToFocusFront(__arg0);
        }

        public static void BringWindowToDisplayFront(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayFront(__arg0);
        }

        public static void BringWindowToDisplayBack(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BringWindowToDisplayBack(__arg0);
        }

        public static void BringWindowToDisplayBehind(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiWindow above_window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = above_window is null ? __IntPtr.Zero : above_window.__Instance;
            __Internal.BringWindowToDisplayBehind(__arg0, __arg1);
        }

        public static int FindWindowDisplayIndex(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindWindowDisplayIndex(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiWindow FindBottomMostVisibleWindowWithinBeginStack(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindBottomMostVisibleWindowWithinBeginStack(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetCurrentFont(global::DearImguiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.SetCurrentFont(__arg0);
        }

        public static global::DearImguiSharp.ImFont GetDefaultFont()
        {
            var __ret = __Internal.GetDefaultFont();
            var __result0 = global::DearImguiSharp.ImFont.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImDrawList GetForegroundDrawListWindowPtr(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetForegroundDrawListWindowPtr(__arg0);
            var __result0 = global::DearImguiSharp.ImDrawList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void Initialize()
        {
            __Internal.Initialize();
        }

        public static void Shutdown()
        {
            __Internal.Shutdown();
        }

        public static void UpdateInputEvents(bool trickle_fast_inputs)
        {
            __Internal.UpdateInputEvents(trickle_fast_inputs);
        }

        public static void UpdateHoveredWindowAndCaptureFlags()
        {
            __Internal.UpdateHoveredWindowAndCaptureFlags();
        }

        public static void StartMouseMovingWindow(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.StartMouseMovingWindow(__arg0);
        }

        public static void StartMouseMovingWindowOrNode(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiDockNode node, bool undock_floating_node)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = node is null ? __IntPtr.Zero : node.__Instance;
            __Internal.StartMouseMovingWindowOrNode(__arg0, __arg1, undock_floating_node);
        }

        public static void UpdateMouseMovingWindowNewFrame()
        {
            __Internal.UpdateMouseMovingWindowNewFrame();
        }

        public static void UpdateMouseMovingWindowEndFrame()
        {
            __Internal.UpdateMouseMovingWindowEndFrame();
        }

        public static uint AddContextHook(global::DearImguiSharp.ImGuiContext context, global::DearImguiSharp.ImGuiContextHook hook)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            var __arg1 = hook is null ? __IntPtr.Zero : hook.__Instance;
            var __ret = __Internal.AddContextHook(__arg0, __arg1);
            return __ret;
        }

        public static void RemoveContextHook(global::DearImguiSharp.ImGuiContext context, uint hook_to_remove)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.RemoveContextHook(__arg0, hook_to_remove);
        }

        public static void CallContextHooks(global::DearImguiSharp.ImGuiContext context, global::DearImguiSharp.ImGuiContextHookType type)
        {
            var __arg0 = context is null ? __IntPtr.Zero : context.__Instance;
            __Internal.CallContextHooks(__arg0, type);
        }

        public static void TranslateWindowsInViewport(global::DearImguiSharp.ImGuiViewportP viewport, global::DearImguiSharp.ImVec2 old_pos, global::DearImguiSharp.ImVec2 new_pos)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            if (ReferenceEquals(old_pos, null))
                throw new global::System.ArgumentNullException("old_pos", "Cannot be null because it is passed by value.");
            var __arg1 = old_pos.__Instance;
            if (ReferenceEquals(new_pos, null))
                throw new global::System.ArgumentNullException("new_pos", "Cannot be null because it is passed by value.");
            var __arg2 = new_pos.__Instance;
            __Internal.TranslateWindowsInViewport(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static void ScaleWindowsInViewport(global::DearImguiSharp.ImGuiViewportP viewport, float scale)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.ScaleWindowsInViewport(__arg0, scale);
        }

        public static void DestroyPlatformWindow(global::DearImguiSharp.ImGuiViewportP viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.DestroyPlatformWindow(__arg0);
        }

        public static void SetWindowViewport(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiViewportP viewport)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.SetWindowViewport(__arg0, __arg1);
        }

        public static void SetCurrentViewport(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiViewportP viewport)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.SetCurrentViewport(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiPlatformMonitor GetViewportPlatformMonitor(global::DearImguiSharp.ImGuiViewport viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.GetViewportPlatformMonitor(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiPlatformMonitor.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiViewportP FindHoveredViewportFromPlatformWindowStack(global::DearImguiSharp.ImVec2 mouse_platform_pos)
        {
            if (ReferenceEquals(mouse_platform_pos, null))
                throw new global::System.ArgumentNullException("mouse_platform_pos", "Cannot be null because it is passed by value.");
            var __arg0 = mouse_platform_pos.__Instance;
            var __ret = __Internal.FindHoveredViewportFromPlatformWindowStack(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
            var __result0 = global::DearImguiSharp.ImGuiViewportP.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void MarkIniSettingsDirtyNil()
        {
            __Internal.MarkIniSettingsDirtyNil();
        }

        public static void MarkIniSettingsDirtyWindowPtr(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.MarkIniSettingsDirtyWindowPtr(__arg0);
        }

        public static void ClearIniSettings()
        {
            __Internal.ClearIniSettings();
        }

        public static global::DearImguiSharp.ImGuiWindowSettings CreateNewWindowSettings(string name)
        {
            var __ret = __Internal.CreateNewWindowSettings(name);
            var __result0 = global::DearImguiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindowSettings FindWindowSettings(uint id)
        {
            var __ret = __Internal.FindWindowSettings(id);
            var __result0 = global::DearImguiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindowSettings FindOrCreateWindowSettings(string name)
        {
            var __ret = __Internal.FindOrCreateWindowSettings(name);
            var __result0 = global::DearImguiSharp.ImGuiWindowSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void AddSettingsHandler(global::DearImguiSharp.ImGuiSettingsHandler handler)
        {
            var __arg0 = handler is null ? __IntPtr.Zero : handler.__Instance;
            __Internal.AddSettingsHandler(__arg0);
        }

        public static void RemoveSettingsHandler(string type_name)
        {
            __Internal.RemoveSettingsHandler(type_name);
        }

        public static global::DearImguiSharp.ImGuiSettingsHandler FindSettingsHandler(string type_name)
        {
            var __ret = __Internal.FindSettingsHandler(type_name);
            var __result0 = global::DearImguiSharp.ImGuiSettingsHandler.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetNextWindowScroll(global::DearImguiSharp.ImVec2 scroll)
        {
            if (ReferenceEquals(scroll, null))
                throw new global::System.ArgumentNullException("scroll", "Cannot be null because it is passed by value.");
            var __arg0 = scroll.__Instance;
            __Internal.SetNextWindowScroll(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0);
        }

        public static void SetScrollX_WindowPtr(global::DearImguiSharp.ImGuiWindow window, float scroll_x)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollX_WindowPtr(__arg0, scroll_x);
        }

        public static void SetScrollY_WindowPtr(global::DearImguiSharp.ImGuiWindow window, float scroll_y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollY_WindowPtr(__arg0, scroll_y);
        }

        public static void SetScrollFromPosX_WindowPtr(global::DearImguiSharp.ImGuiWindow window, float local_x, float center_x_ratio)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosX_WindowPtr(__arg0, local_x, center_x_ratio);
        }

        public static void SetScrollFromPosY_WindowPtr(global::DearImguiSharp.ImGuiWindow window, float local_y, float center_y_ratio)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetScrollFromPosY_WindowPtr(__arg0, local_y, center_y_ratio);
        }

        public static void ScrollToItem(int flags)
        {
            __Internal.ScrollToItem(flags);
        }

        public static void ScrollToRect(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect rect, int flags)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.ScrollToRect(__arg0, __arg1, flags);
        }

        public static void ScrollToRectEx(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect rect, int flags)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg2 = rect.__Instance;
            __Internal.ScrollToRectEx(__arg0, __arg1, __arg2, flags);
        }

        public static void ScrollToBringRectIntoView(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect rect)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.ScrollToBringRectIntoView(__arg0, __arg1);
        }

        public static uint GetItemID()
        {
            var __ret = __Internal.GetItemID();
            return __ret;
        }

        public static int GetItemStatusFlags()
        {
            var __ret = __Internal.GetItemStatusFlags();
            return __ret;
        }

        public static int GetItemFlags()
        {
            var __ret = __Internal.GetItemFlags();
            return __ret;
        }

        public static uint GetActiveID()
        {
            var __ret = __Internal.GetActiveID();
            return __ret;
        }

        public static uint GetFocusID()
        {
            var __ret = __Internal.GetFocusID();
            return __ret;
        }

        public static void SetActiveID(uint id, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetActiveID(id, __arg1);
        }

        public static void SetFocusID(uint id, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetFocusID(id, __arg1);
        }

        public static void ClearActiveID()
        {
            __Internal.ClearActiveID();
        }

        public static uint GetHoveredID()
        {
            var __ret = __Internal.GetHoveredID();
            return __ret;
        }

        public static void SetHoveredID(uint id)
        {
            __Internal.SetHoveredID(id);
        }

        public static void KeepAliveID(uint id)
        {
            __Internal.KeepAliveID(id);
        }

        public static void MarkItemEdited(uint id)
        {
            __Internal.MarkItemEdited(id);
        }

        public static void PushOverrideID(uint id)
        {
            __Internal.PushOverrideID(id);
        }

        public static uint GetIDWithSeed(string str_id_begin, string str_id_end, uint seed)
        {
            var __ret = __Internal.GetIDWithSeed(str_id_begin, str_id_end, seed);
            return __ret;
        }

        public static void ItemSizeVec2(global::DearImguiSharp.ImVec2 size, float text_baseline_y)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg0 = size.__Instance;
            __Internal.ItemSizeVec2(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, text_baseline_y);
        }

        public static void ItemSizeRect(global::DearImguiSharp.ImRect bb, float text_baseline_y)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.ItemSizeRect(__arg0, text_baseline_y);
        }

        public static bool ItemAdd(global::DearImguiSharp.ImRect bb, uint id, global::DearImguiSharp.ImRect nav_bb, int extra_flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg2 = nav_bb is null ? __IntPtr.Zero : nav_bb.__Instance;
            var __ret = __Internal.ItemAdd(__arg0, id, __arg2, extra_flags);
            return __ret;
        }

        public static bool ItemHoverable(global::DearImguiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.ItemHoverable(__arg0, id);
            return __ret;
        }

        public static bool IsClippedEx(global::DearImguiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.IsClippedEx(__arg0, id);
            return __ret;
        }

        public static void SetLastItemData(uint item_id, int in_flags, int status_flags, global::DearImguiSharp.ImRect item_rect)
        {
            if (ReferenceEquals(item_rect, null))
                throw new global::System.ArgumentNullException("item_rect", "Cannot be null because it is passed by value.");
            var __arg3 = item_rect.__Instance;
            __Internal.SetLastItemData(item_id, in_flags, status_flags, __arg3);
        }

        public static void CalcItemSize(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 size, float default_w, float default_h)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.CalcItemSize(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, default_w, default_h);
        }

        public static float CalcWrapWidthForPos(global::DearImguiSharp.ImVec2 pos, float wrap_pos_x)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            var __ret = __Internal.CalcWrapWidthForPos(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, wrap_pos_x);
            return __ret;
        }

        public static void PushMultiItemsWidths(int components, float width_full)
        {
            __Internal.PushMultiItemsWidths(components, width_full);
        }

        public static bool IsItemToggledSelection()
        {
            var __ret = __Internal.IsItemToggledSelection();
            return __ret;
        }

        public static void GetContentRegionMaxAbs(global::DearImguiSharp.ImVec2 pOut)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetContentRegionMaxAbs(__arg0);
        }

        public static void ShrinkWidths(global::DearImguiSharp.ImGuiShrinkWidthItem items, int count, float width_excess)
        {
            var __arg0 = items is null ? __IntPtr.Zero : items.__Instance;
            __Internal.ShrinkWidths(__arg0, count, width_excess);
        }

        public static void PushItemFlag(int option, bool enabled)
        {
            __Internal.PushItemFlag(option, enabled);
        }

        public static void PopItemFlag()
        {
            __Internal.PopItemFlag();
        }

        public static void LogBegin(global::DearImguiSharp.ImGuiLogType type, int auto_open_depth)
        {
            __Internal.LogBegin(type, auto_open_depth);
        }

        public static void LogToBuffer(int auto_open_depth)
        {
            __Internal.LogToBuffer(auto_open_depth);
        }

        public static void LogRenderedText(global::DearImguiSharp.ImVec2 ref_pos, string text, string text_end)
        {
            var __arg0 = ref_pos is null ? __IntPtr.Zero : ref_pos.__Instance;
            __Internal.LogRenderedText(__arg0, text, text_end);
        }

        public static void LogSetNextTextDecoration(string prefix, string suffix)
        {
            __Internal.LogSetNextTextDecoration(prefix, suffix);
        }

        public static bool BeginChildEx(string name, uint id, global::DearImguiSharp.ImVec2 size_arg, bool border, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.BeginChildEx(name, id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, border, flags);
            return __ret;
        }

        public static void OpenPopupEx(uint id, int popup_flags)
        {
            __Internal.OpenPopupEx(id, popup_flags);
        }

        public static void ClosePopupToLevel(int remaining, bool restore_focus_to_window_under_popup)
        {
            __Internal.ClosePopupToLevel(remaining, restore_focus_to_window_under_popup);
        }

        public static void ClosePopupsOverWindow(global::DearImguiSharp.ImGuiWindow ref_window, bool restore_focus_to_window_under_popup)
        {
            var __arg0 = ref_window is null ? __IntPtr.Zero : ref_window.__Instance;
            __Internal.ClosePopupsOverWindow(__arg0, restore_focus_to_window_under_popup);
        }

        public static void ClosePopupsExceptModals()
        {
            __Internal.ClosePopupsExceptModals();
        }

        public static bool IsPopupOpenID(uint id, int popup_flags)
        {
            var __ret = __Internal.IsPopupOpenID(id, popup_flags);
            return __ret;
        }

        public static bool BeginPopupEx(uint id, int extra_flags)
        {
            var __ret = __Internal.BeginPopupEx(id, extra_flags);
            return __ret;
        }

        public static void BeginTooltipEx(int tooltip_flags, int extra_window_flags)
        {
            __Internal.BeginTooltipEx(tooltip_flags, extra_window_flags);
        }

        public static void GetPopupAllowedExtentRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GetPopupAllowedExtentRect(__arg0, __arg1);
        }

        public static global::DearImguiSharp.ImGuiWindow GetTopMostPopupModal()
        {
            var __ret = __Internal.GetTopMostPopupModal();
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiWindow GetTopMostAndVisiblePopupModal()
        {
            var __ret = __Internal.GetTopMostAndVisiblePopupModal();
            var __result0 = global::DearImguiSharp.ImGuiWindow.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void FindBestWindowPosForPopup(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.FindBestWindowPosForPopup(__arg0, __arg1);
        }

        public static void FindBestWindowPosForPopupEx(global::DearImguiSharp.ImVec2 pOut, global::DearImguiSharp.ImVec2 ref_pos, global::DearImguiSharp.ImVec2 size, ref int last_dir, global::DearImguiSharp.ImRect r_outer, global::DearImguiSharp.ImRect r_avoid, global::DearImguiSharp.ImGuiPopupPositionPolicy policy)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            if (ReferenceEquals(ref_pos, null))
                throw new global::System.ArgumentNullException("ref_pos", "Cannot be null because it is passed by value.");
            var __arg1 = ref_pos.__Instance;
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            fixed (int* __last_dir3 = &last_dir)
            {
                var __arg3 = __last_dir3;
                if (ReferenceEquals(r_outer, null))
                    throw new global::System.ArgumentNullException("r_outer", "Cannot be null because it is passed by value.");
                var __arg4 = r_outer.__Instance;
                if (ReferenceEquals(r_avoid, null))
                    throw new global::System.ArgumentNullException("r_avoid", "Cannot be null because it is passed by value.");
                var __arg5 = r_avoid.__Instance;
                __Internal.FindBestWindowPosForPopupEx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, __arg3, __arg4, __arg5, policy);
            }
        }

        public static bool BeginViewportSideBar(string name, global::DearImguiSharp.ImGuiViewport viewport, int dir, float size, int window_flags)
        {
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __ret = __Internal.BeginViewportSideBar(name, __arg1, dir, size, window_flags);
            return __ret;
        }

        public static bool BeginMenuEx(string label, string icon, bool enabled)
        {
            var __ret = __Internal.BeginMenuEx(label, icon, enabled);
            return __ret;
        }

        public static bool MenuItemEx(string label, string icon, string shortcut, bool selected, bool enabled)
        {
            var __ret = __Internal.MenuItemEx(label, icon, shortcut, selected, enabled);
            return __ret;
        }

        public static bool BeginComboPopup(uint popup_id, global::DearImguiSharp.ImRect bb, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            var __ret = __Internal.BeginComboPopup(popup_id, __arg1, flags);
            return __ret;
        }

        public static bool BeginComboPreview()
        {
            var __ret = __Internal.BeginComboPreview();
            return __ret;
        }

        public static void EndComboPreview()
        {
            __Internal.EndComboPreview();
        }

        public static void NavInitWindow(global::DearImguiSharp.ImGuiWindow window, bool force_reinit)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.NavInitWindow(__arg0, force_reinit);
        }

        public static void NavInitRequestApplyResult()
        {
            __Internal.NavInitRequestApplyResult();
        }

        public static bool NavMoveRequestButNoResultYet()
        {
            var __ret = __Internal.NavMoveRequestButNoResultYet();
            return __ret;
        }

        public static void NavMoveRequestSubmit(int move_dir, int clip_dir, int move_flags, int scroll_flags)
        {
            __Internal.NavMoveRequestSubmit(move_dir, clip_dir, move_flags, scroll_flags);
        }

        public static void NavMoveRequestForward(int move_dir, int clip_dir, int move_flags, int scroll_flags)
        {
            __Internal.NavMoveRequestForward(move_dir, clip_dir, move_flags, scroll_flags);
        }

        public static void NavMoveRequestResolveWithLastItem(global::DearImguiSharp.ImGuiNavItemData result)
        {
            var __arg0 = result is null ? __IntPtr.Zero : result.__Instance;
            __Internal.NavMoveRequestResolveWithLastItem(__arg0);
        }

        public static void NavMoveRequestCancel()
        {
            __Internal.NavMoveRequestCancel();
        }

        public static void NavMoveRequestApplyResult()
        {
            __Internal.NavMoveRequestApplyResult();
        }

        public static void NavMoveRequestTryWrapping(global::DearImguiSharp.ImGuiWindow window, int move_flags)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.NavMoveRequestTryWrapping(__arg0, move_flags);
        }

        public static string GetNavInputName(int n)
        {
            var __ret = __Internal.GetNavInputName(n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static float GetNavInputAmount(int n, global::DearImguiSharp.ImGuiNavReadMode mode)
        {
            var __ret = __Internal.GetNavInputAmount(n, mode);
            return __ret;
        }

        public static void GetNavInputAmount2d(global::DearImguiSharp.ImVec2 pOut, int dir_sources, global::DearImguiSharp.ImGuiNavReadMode mode, float slow_factor, float fast_factor)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.GetNavInputAmount2d(__arg0, dir_sources, mode, slow_factor, fast_factor);
        }

        public static int CalcTypematicRepeatAmount(float t0, float t1, float repeat_delay, float repeat_rate)
        {
            var __ret = __Internal.CalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate);
            return __ret;
        }

        public static void ActivateItem(uint id)
        {
            __Internal.ActivateItem(id);
        }

        public static void SetNavWindow(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetNavWindow(__arg0);
        }

        public static void SetNavID(uint id, global::DearImguiSharp.ImGuiNavLayer nav_layer, uint focus_scope_id, global::DearImguiSharp.ImRect rect_rel)
        {
            if (ReferenceEquals(rect_rel, null))
                throw new global::System.ArgumentNullException("rect_rel", "Cannot be null because it is passed by value.");
            var __arg3 = rect_rel.__Instance;
            __Internal.SetNavID(id, nav_layer, focus_scope_id, __arg3);
        }

        public static void PushFocusScope(uint id)
        {
            __Internal.PushFocusScope(id);
        }

        public static void PopFocusScope()
        {
            __Internal.PopFocusScope();
        }

        public static uint GetFocusedFocusScope()
        {
            var __ret = __Internal.GetFocusedFocusScope();
            return __ret;
        }

        public static uint GetFocusScope()
        {
            var __ret = __Internal.GetFocusScope();
            return __ret;
        }

        public static bool IsNamedKey(int key)
        {
            var __ret = __Internal.IsNamedKey(key);
            return __ret;
        }

        public static bool IsLegacyKey(int key)
        {
            var __ret = __Internal.IsLegacyKey(key);
            return __ret;
        }

        public static bool IsGamepadKey(int key)
        {
            var __ret = __Internal.IsGamepadKey(key);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiKeyData GetKeyData(int key)
        {
            var __ret = __Internal.GetKeyData(key);
            var __result0 = global::DearImguiSharp.ImGuiKeyData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void SetItemUsingMouseWheel()
        {
            __Internal.SetItemUsingMouseWheel();
        }

        public static void SetActiveIdUsingNavAndKeys()
        {
            __Internal.SetActiveIdUsingNavAndKeys();
        }

        public static bool IsActiveIdUsingNavDir(int dir)
        {
            var __ret = __Internal.IsActiveIdUsingNavDir(dir);
            return __ret;
        }

        public static bool IsActiveIdUsingNavInput(int input)
        {
            var __ret = __Internal.IsActiveIdUsingNavInput(input);
            return __ret;
        }

        public static bool IsActiveIdUsingKey(int key)
        {
            var __ret = __Internal.IsActiveIdUsingKey(key);
            return __ret;
        }

        public static void SetActiveIdUsingKey(int key)
        {
            __Internal.SetActiveIdUsingKey(key);
        }

        public static bool IsMouseDragPastThreshold(int button, float lock_threshold)
        {
            var __ret = __Internal.IsMouseDragPastThreshold(button, lock_threshold);
            return __ret;
        }

        public static bool IsNavInputDown(int n)
        {
            var __ret = __Internal.IsNavInputDown(n);
            return __ret;
        }

        public static bool IsNavInputTest(int n, global::DearImguiSharp.ImGuiNavReadMode rm)
        {
            var __ret = __Internal.IsNavInputTest(n, rm);
            return __ret;
        }

        public static int GetMergedModFlags()
        {
            var __ret = __Internal.GetMergedModFlags();
            return __ret;
        }

        public static bool IsKeyPressedMap(int key, bool repeat)
        {
            var __ret = __Internal.IsKeyPressedMap(key, repeat);
            return __ret;
        }

        public static void DockContextInitialize(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextInitialize(__arg0);
        }

        public static void DockContextShutdown(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextShutdown(__arg0);
        }

        public static void DockContextClearNodes(global::DearImguiSharp.ImGuiContext ctx, uint root_id, bool clear_settings_refs)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextClearNodes(__arg0, root_id, clear_settings_refs);
        }

        public static void DockContextRebuildNodes(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextRebuildNodes(__arg0);
        }

        public static void DockContextNewFrameUpdateUndocking(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextNewFrameUpdateUndocking(__arg0);
        }

        public static void DockContextNewFrameUpdateDocking(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextNewFrameUpdateDocking(__arg0);
        }

        public static void DockContextEndFrame(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            __Internal.DockContextEndFrame(__arg0);
        }

        public static uint DockContextGenNodeID(global::DearImguiSharp.ImGuiContext ctx)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __ret = __Internal.DockContextGenNodeID(__arg0);
            return __ret;
        }

        public static void DockContextQueueDock(global::DearImguiSharp.ImGuiContext ctx, global::DearImguiSharp.ImGuiWindow target, global::DearImguiSharp.ImGuiDockNode target_node, global::DearImguiSharp.ImGuiWindow payload, int split_dir, float split_ratio, bool split_outer)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = target is null ? __IntPtr.Zero : target.__Instance;
            var __arg2 = target_node is null ? __IntPtr.Zero : target_node.__Instance;
            var __arg3 = payload is null ? __IntPtr.Zero : payload.__Instance;
            __Internal.DockContextQueueDock(__arg0, __arg1, __arg2, __arg3, split_dir, split_ratio, split_outer);
        }

        public static void DockContextQueueUndockWindow(global::DearImguiSharp.ImGuiContext ctx, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.DockContextQueueUndockWindow(__arg0, __arg1);
        }

        public static void DockContextQueueUndockNode(global::DearImguiSharp.ImGuiContext ctx, global::DearImguiSharp.ImGuiDockNode node)
        {
            var __arg0 = ctx is null ? __IntPtr.Zero : ctx.__Instance;
            var __arg1 = node is null ? __IntPtr.Zero : node.__Instance;
            __Internal.DockContextQueueUndockNode(__arg0, __arg1);
        }

        public static bool DockContextCalcDropPosForDocking(global::DearImguiSharp.ImGuiWindow target, global::DearImguiSharp.ImGuiDockNode target_node, global::DearImguiSharp.ImGuiWindow payload, int split_dir, bool split_outer, global::DearImguiSharp.ImVec2 out_pos)
        {
            var __arg0 = target is null ? __IntPtr.Zero : target.__Instance;
            var __arg1 = target_node is null ? __IntPtr.Zero : target_node.__Instance;
            var __arg2 = payload is null ? __IntPtr.Zero : payload.__Instance;
            var __arg5 = out_pos is null ? __IntPtr.Zero : out_pos.__Instance;
            var __ret = __Internal.DockContextCalcDropPosForDocking(__arg0, __arg1, __arg2, split_dir, split_outer, __arg5);
            return __ret;
        }

        public static bool DockNodeBeginAmendTabBar(global::DearImguiSharp.ImGuiDockNode node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var __ret = __Internal.DockNodeBeginAmendTabBar(__arg0);
            return __ret;
        }

        public static void DockNodeEndAmendTabBar()
        {
            __Internal.DockNodeEndAmendTabBar();
        }

        public static global::DearImguiSharp.ImGuiDockNode DockNodeGetRootNode(global::DearImguiSharp.ImGuiDockNode node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var __ret = __Internal.DockNodeGetRootNode(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool DockNodeIsInHierarchyOf(global::DearImguiSharp.ImGuiDockNode node, global::DearImguiSharp.ImGuiDockNode parent)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var __arg1 = parent is null ? __IntPtr.Zero : parent.__Instance;
            var __ret = __Internal.DockNodeIsInHierarchyOf(__arg0, __arg1);
            return __ret;
        }

        public static int DockNodeGetDepth(global::DearImguiSharp.ImGuiDockNode node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var __ret = __Internal.DockNodeGetDepth(__arg0);
            return __ret;
        }

        public static uint DockNodeGetWindowMenuButtonId(global::DearImguiSharp.ImGuiDockNode node)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            var __ret = __Internal.DockNodeGetWindowMenuButtonId(__arg0);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiDockNode GetWindowDockNode()
        {
            var __ret = __Internal.GetWindowDockNode();
            var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool GetWindowAlwaysWantOwnTabBar(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowAlwaysWantOwnTabBar(__arg0);
            return __ret;
        }

        public static void BeginDocked(global::DearImguiSharp.ImGuiWindow window, ref bool p_open)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            fixed (bool* __p_open1 = &p_open)
            {
                var __arg1 = __p_open1;
                __Internal.BeginDocked(__arg0, __arg1);
            }
        }

        public static void BeginDockableDragDropSource(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BeginDockableDragDropSource(__arg0);
        }

        public static void BeginDockableDragDropTarget(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.BeginDockableDragDropTarget(__arg0);
        }

        public static void SetWindowDock(global::DearImguiSharp.ImGuiWindow window, uint dock_id, int cond)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.SetWindowDock(__arg0, dock_id, cond);
        }

        public static void DockBuilderDockWindow(string window_name, uint node_id)
        {
            __Internal.DockBuilderDockWindow(window_name, node_id);
        }

        public static global::DearImguiSharp.ImGuiDockNode DockBuilderGetNode(uint node_id)
        {
            var __ret = __Internal.DockBuilderGetNode(node_id);
            var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiDockNode DockBuilderGetCentralNode(uint node_id)
        {
            var __ret = __Internal.DockBuilderGetCentralNode(node_id);
            var __result0 = global::DearImguiSharp.ImGuiDockNode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static uint DockBuilderAddNode(uint node_id, int flags)
        {
            var __ret = __Internal.DockBuilderAddNode(node_id, flags);
            return __ret;
        }

        public static void DockBuilderRemoveNode(uint node_id)
        {
            __Internal.DockBuilderRemoveNode(node_id);
        }

        public static void DockBuilderRemoveNodeDockedWindows(uint node_id, bool clear_settings_refs)
        {
            __Internal.DockBuilderRemoveNodeDockedWindows(node_id, clear_settings_refs);
        }

        public static void DockBuilderRemoveNodeChildNodes(uint node_id)
        {
            __Internal.DockBuilderRemoveNodeChildNodes(node_id);
        }

        public static void DockBuilderSetNodePos(uint node_id, global::DearImguiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.DockBuilderSetNodePos(node_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static void DockBuilderSetNodeSize(uint node_id, global::DearImguiSharp.ImVec2 size)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg1 = size.__Instance;
            __Internal.DockBuilderSetNodeSize(node_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
        }

        public static uint DockBuilderSplitNode(uint node_id, int split_dir, float size_ratio_for_node_at_dir, ref uint out_id_at_dir, ref uint out_id_at_opposite_dir)
        {
            fixed (uint* __out_id_at_dir3 = &out_id_at_dir)
            {
                var __arg3 = __out_id_at_dir3;
                fixed (uint* __out_id_at_opposite_dir4 = &out_id_at_opposite_dir)
                {
                    var __arg4 = __out_id_at_opposite_dir4;
                    var __ret = __Internal.DockBuilderSplitNode(node_id, split_dir, size_ratio_for_node_at_dir, __arg3, __arg4);
                    return __ret;
                }
            }
        }

        public static void DockBuilderCopyDockSpace(uint src_dockspace_id, uint dst_dockspace_id, global::DearImguiSharp.ImVector_const_charPtr in_window_remap_pairs)
        {
            var __arg2 = in_window_remap_pairs is null ? __IntPtr.Zero : in_window_remap_pairs.__Instance;
            __Internal.DockBuilderCopyDockSpace(src_dockspace_id, dst_dockspace_id, __arg2);
        }

        public static void DockBuilderCopyNode(uint src_node_id, uint dst_node_id, global::DearImguiSharp.ImVectorImGuiID out_node_remap_pairs)
        {
            var __arg2 = out_node_remap_pairs is null ? __IntPtr.Zero : out_node_remap_pairs.__Instance;
            __Internal.DockBuilderCopyNode(src_node_id, dst_node_id, __arg2);
        }

        public static void DockBuilderCopyWindowSettings(string src_name, string dst_name)
        {
            __Internal.DockBuilderCopyWindowSettings(src_name, dst_name);
        }

        public static void DockBuilderFinish(uint node_id)
        {
            __Internal.DockBuilderFinish(node_id);
        }

        public static bool IsDragDropActive()
        {
            var __ret = __Internal.IsDragDropActive();
            return __ret;
        }

        public static bool BeginDragDropTargetCustom(global::DearImguiSharp.ImRect bb, uint id)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.BeginDragDropTargetCustom(__arg0, id);
            return __ret;
        }

        public static void ClearDragDrop()
        {
            __Internal.ClearDragDrop();
        }

        public static bool IsDragDropPayloadBeingAccepted()
        {
            var __ret = __Internal.IsDragDropPayloadBeingAccepted();
            return __ret;
        }

        public static void SetWindowClipRectBeforeSetChannel(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImRect clip_rect)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            if (ReferenceEquals(clip_rect, null))
                throw new global::System.ArgumentNullException("clip_rect", "Cannot be null because it is passed by value.");
            var __arg1 = clip_rect.__Instance;
            __Internal.SetWindowClipRectBeforeSetChannel(__arg0, __arg1);
        }

        public static void BeginColumns(string str_id, int count, int flags)
        {
            __Internal.BeginColumns(str_id, count, flags);
        }

        public static void EndColumns()
        {
            __Internal.EndColumns();
        }

        public static void PushColumnClipRect(int column_index)
        {
            __Internal.PushColumnClipRect(column_index);
        }

        public static void PushColumnsBackground()
        {
            __Internal.PushColumnsBackground();
        }

        public static void PopColumnsBackground()
        {
            __Internal.PopColumnsBackground();
        }

        public static uint GetColumnsID(string str_id, int count)
        {
            var __ret = __Internal.GetColumnsID(str_id, count);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiOldColumns FindOrCreateColumns(global::DearImguiSharp.ImGuiWindow window, uint id)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.FindOrCreateColumns(__arg0, id);
            var __result0 = global::DearImguiSharp.ImGuiOldColumns.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static float GetColumnOffsetFromNorm(global::DearImguiSharp.ImGuiOldColumns columns, float offset_norm)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnOffsetFromNorm(__arg0, offset_norm);
            return __ret;
        }

        public static float GetColumnNormFromOffset(global::DearImguiSharp.ImGuiOldColumns columns, float offset)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            var __ret = __Internal.GetColumnNormFromOffset(__arg0, offset);
            return __ret;
        }

        public static void TableOpenContextMenu(int column_n)
        {
            __Internal.TableOpenContextMenu(column_n);
        }

        public static void TableSetColumnWidth(int column_n, float width)
        {
            __Internal.TableSetColumnWidth(column_n, width);
        }

        public static void TableSetColumnSortDirection(int column_n, int sort_direction, bool append_to_sort_specs)
        {
            __Internal.TableSetColumnSortDirection(column_n, sort_direction, append_to_sort_specs);
        }

        public static int TableGetHoveredColumn()
        {
            var __ret = __Internal.TableGetHoveredColumn();
            return __ret;
        }

        public static float TableGetHeaderRowHeight()
        {
            var __ret = __Internal.TableGetHeaderRowHeight();
            return __ret;
        }

        public static void TablePushBackgroundChannel()
        {
            __Internal.TablePushBackgroundChannel();
        }

        public static void TablePopBackgroundChannel()
        {
            __Internal.TablePopBackgroundChannel();
        }

        public static global::DearImguiSharp.ImGuiTable GetCurrentTable()
        {
            var __ret = __Internal.GetCurrentTable();
            var __result0 = global::DearImguiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiTable TableFindByID(uint id)
        {
            var __ret = __Internal.TableFindByID(id);
            var __result0 = global::DearImguiSharp.ImGuiTable.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginTableEx(string name, uint id, int columns_count, int flags, global::DearImguiSharp.ImVec2 outer_size, float inner_width)
        {
            if (ReferenceEquals(outer_size, null))
                throw new global::System.ArgumentNullException("outer_size", "Cannot be null because it is passed by value.");
            var __arg4 = outer_size.__Instance;
            var __ret = __Internal.BeginTableEx(name, id, columns_count, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, inner_width);
            return __ret;
        }

        public static void TableBeginInitMemory(global::DearImguiSharp.ImGuiTable table, int columns_count)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginInitMemory(__arg0, columns_count);
        }

        public static void TableBeginApplyRequests(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginApplyRequests(__arg0);
        }

        public static void TableSetupDrawChannels(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetupDrawChannels(__arg0);
        }

        public static void TableUpdateLayout(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateLayout(__arg0);
        }

        public static void TableUpdateBorders(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateBorders(__arg0);
        }

        public static void TableUpdateColumnsWeightFromWidth(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableUpdateColumnsWeightFromWidth(__arg0);
        }

        public static void TableDrawBorders(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableDrawBorders(__arg0);
        }

        public static void TableDrawContextMenu(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableDrawContextMenu(__arg0);
        }

        public static void TableMergeDrawChannels(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableMergeDrawChannels(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableInstanceData TableGetInstanceData(global::DearImguiSharp.ImGuiTable table, int instance_no)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetInstanceData(__arg0, instance_no);
            var __result0 = global::DearImguiSharp.ImGuiTableInstanceData.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void TableSortSpecsSanitize(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSortSpecsSanitize(__arg0);
        }

        public static void TableSortSpecsBuild(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSortSpecsBuild(__arg0);
        }

        public static int TableGetColumnNextSortDirection(global::DearImguiSharp.ImGuiTableColumn column)
        {
            var __arg0 = column is null ? __IntPtr.Zero : column.__Instance;
            var __ret = __Internal.TableGetColumnNextSortDirection(__arg0);
            return __ret;
        }

        public static void TableFixColumnSortDirection(global::DearImguiSharp.ImGuiTable table, global::DearImguiSharp.ImGuiTableColumn column)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __arg1 = column is null ? __IntPtr.Zero : column.__Instance;
            __Internal.TableFixColumnSortDirection(__arg0, __arg1);
        }

        public static float TableGetColumnWidthAuto(global::DearImguiSharp.ImGuiTable table, global::DearImguiSharp.ImGuiTableColumn column)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __arg1 = column is null ? __IntPtr.Zero : column.__Instance;
            var __ret = __Internal.TableGetColumnWidthAuto(__arg0, __arg1);
            return __ret;
        }

        public static void TableBeginRow(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginRow(__arg0);
        }

        public static void TableEndRow(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableEndRow(__arg0);
        }

        public static void TableBeginCell(global::DearImguiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableBeginCell(__arg0, column_n);
        }

        public static void TableEndCell(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableEndCell(__arg0);
        }

        public static void TableGetCellBgRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGetCellBgRect(__arg0, __arg1, column_n);
        }

        public static string TableGetColumnNameTablePtr(global::DearImguiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetColumnNameTablePtr(__arg0, column_n);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static uint TableGetColumnResizeID(global::DearImguiSharp.ImGuiTable table, int column_n, int instance_no)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetColumnResizeID(__arg0, column_n, instance_no);
            return __ret;
        }

        public static float TableGetMaxColumnWidth(global::DearImguiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetMaxColumnWidth(__arg0, column_n);
            return __ret;
        }

        public static void TableSetColumnWidthAutoSingle(global::DearImguiSharp.ImGuiTable table, int column_n)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetColumnWidthAutoSingle(__arg0, column_n);
        }

        public static void TableSetColumnWidthAutoAll(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSetColumnWidthAutoAll(__arg0);
        }

        public static void TableRemove(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableRemove(__arg0);
        }

        public static void TableGcCompactTransientBuffersTablePtr(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGcCompactTransientBuffersTablePtr(__arg0);
        }

        public static void TableGcCompactTransientBuffersTableTempDataPtr(global::DearImguiSharp.ImGuiTableTempData table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableGcCompactTransientBuffersTableTempDataPtr(__arg0);
        }

        public static void TableGcCompactSettings()
        {
            __Internal.TableGcCompactSettings();
        }

        public static void TableLoadSettings(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableLoadSettings(__arg0);
        }

        public static void TableSaveSettings(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableSaveSettings(__arg0);
        }

        public static void TableResetSettings(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.TableResetSettings(__arg0);
        }

        public static global::DearImguiSharp.ImGuiTableSettings TableGetBoundSettings(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            var __ret = __Internal.TableGetBoundSettings(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void TableSettingsAddSettingsHandler()
        {
            __Internal.TableSettingsAddSettingsHandler();
        }

        public static global::DearImguiSharp.ImGuiTableSettings TableSettingsCreate(uint id, int columns_count)
        {
            var __ret = __Internal.TableSettingsCreate(id, columns_count);
            var __result0 = global::DearImguiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiTableSettings TableSettingsFindByID(uint id)
        {
            var __ret = __Internal.TableSettingsFindByID(id);
            var __result0 = global::DearImguiSharp.ImGuiTableSettings.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool BeginTabBarEx(global::DearImguiSharp.ImGuiTabBar tab_bar, global::DearImguiSharp.ImRect bb, int flags, global::DearImguiSharp.ImGuiDockNode dock_node)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            var __arg3 = dock_node is null ? __IntPtr.Zero : dock_node.__Instance;
            var __ret = __Internal.BeginTabBarEx(__arg0, __arg1, flags, __arg3);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiTabItem TabBarFindTabByID(global::DearImguiSharp.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarFindTabByID(__arg0, tab_id);
            var __result0 = global::DearImguiSharp.ImGuiTabItem.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static global::DearImguiSharp.ImGuiTabItem TabBarFindMostRecentlySelectedTabForActiveWindow(global::DearImguiSharp.ImGuiTabBar tab_bar)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarFindMostRecentlySelectedTabForActiveWindow(__arg0);
            var __result0 = global::DearImguiSharp.ImGuiTabItem.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void TabBarAddTab(global::DearImguiSharp.ImGuiTabBar tab_bar, int tab_flags, global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg2 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.TabBarAddTab(__arg0, tab_flags, __arg2);
        }

        public static void TabBarRemoveTab(global::DearImguiSharp.ImGuiTabBar tab_bar, uint tab_id)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            __Internal.TabBarRemoveTab(__arg0, tab_id);
        }

        public static void TabBarCloseTab(global::DearImguiSharp.ImGuiTabBar tab_bar, global::DearImguiSharp.ImGuiTabItem tab)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            __Internal.TabBarCloseTab(__arg0, __arg1);
        }

        public static void TabBarQueueReorder(global::DearImguiSharp.ImGuiTabBar tab_bar, global::DearImguiSharp.ImGuiTabItem tab, int offset)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            __Internal.TabBarQueueReorder(__arg0, __arg1, offset);
        }

        public static void TabBarQueueReorderFromMousePos(global::DearImguiSharp.ImGuiTabBar tab_bar, global::DearImguiSharp.ImGuiTabItem tab, global::DearImguiSharp.ImVec2 mouse_pos)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __arg1 = tab is null ? __IntPtr.Zero : tab.__Instance;
            if (ReferenceEquals(mouse_pos, null))
                throw new global::System.ArgumentNullException("mouse_pos", "Cannot be null because it is passed by value.");
            var __arg2 = mouse_pos.__Instance;
            __Internal.TabBarQueueReorderFromMousePos(__arg0, __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2);
        }

        public static bool TabBarProcessReorder(global::DearImguiSharp.ImGuiTabBar tab_bar)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            var __ret = __Internal.TabBarProcessReorder(__arg0);
            return __ret;
        }

        public static bool TabItemEx(global::DearImguiSharp.ImGuiTabBar tab_bar, string label, ref bool p_open, int flags, global::DearImguiSharp.ImGuiWindow docked_window)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            fixed (bool* __p_open2 = &p_open)
            {
                var __arg2 = __p_open2;
                var __arg4 = docked_window is null ? __IntPtr.Zero : docked_window.__Instance;
                var __ret = __Internal.TabItemEx(__arg0, label, __arg2, flags, __arg4);
                return __ret;
            }
        }

        public static void TabItemCalcSize(global::DearImguiSharp.ImVec2 pOut, string label, bool has_close_button)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            __Internal.TabItemCalcSize(__arg0, label, has_close_button);
        }

        public static void TabItemBackground(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImRect bb, int flags, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            __Internal.TabItemBackground(__arg0, __arg1, flags, col);
        }

        public static void TabItemLabelAndCloseButton(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImRect bb, int flags, global::DearImguiSharp.ImVec2 frame_padding, string label, uint tab_id, uint close_button_id, bool is_contents_visible, ref bool out_just_closed, ref bool out_text_clipped)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg1 = bb.__Instance;
            if (ReferenceEquals(frame_padding, null))
                throw new global::System.ArgumentNullException("frame_padding", "Cannot be null because it is passed by value.");
            var __arg3 = frame_padding.__Instance;
            fixed (bool* __out_just_closed8 = &out_just_closed)
            {
                var __arg8 = __out_just_closed8;
                fixed (bool* __out_text_clipped9 = &out_text_clipped)
                {
                    var __arg9 = __out_text_clipped9;
                    __Internal.TabItemLabelAndCloseButton(__arg0, __arg1, flags, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, label, tab_id, close_button_id, is_contents_visible, __arg8, __arg9);
                }
            }
        }

        public static void RenderText(global::DearImguiSharp.ImVec2 pos, string text, string text_end, bool hide_text_after_hash)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderText(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, text, text_end, hide_text_after_hash);
        }

        public static void RenderTextWrapped(global::DearImguiSharp.ImVec2 pos, string text, string text_end, float wrap_width)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderTextWrapped(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, text, text_end, wrap_width);
        }

        public static void RenderTextClipped(global::DearImguiSharp.ImVec2 pos_min, global::DearImguiSharp.ImVec2 pos_max, string text, string text_end, global::DearImguiSharp.ImVec2 text_size_if_known, global::DearImguiSharp.ImVec2 align, global::DearImguiSharp.ImRect clip_rect)
        {
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg0 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg1 = pos_max.__Instance;
            var __arg4 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg5 = align.__Instance;
            var __arg6 = clip_rect is null ? __IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClipped(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, text, text_end, __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, __arg6);
        }

        public static void RenderTextClippedEx(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos_min, global::DearImguiSharp.ImVec2 pos_max, string text, string text_end, global::DearImguiSharp.ImVec2 text_size_if_known, global::DearImguiSharp.ImVec2 align, global::DearImguiSharp.ImRect clip_rect)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg5 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            if (ReferenceEquals(align, null))
                throw new global::System.ArgumentNullException("align", "Cannot be null because it is passed by value.");
            var __arg6 = align.__Instance;
            var __arg7 = clip_rect is null ? __IntPtr.Zero : clip_rect.__Instance;
            __Internal.RenderTextClippedEx(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, text, text_end, __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, __arg7);
        }

        public static void RenderTextEllipsis(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos_min, global::DearImguiSharp.ImVec2 pos_max, float clip_max_x, float ellipsis_max_x, string text, string text_end, global::DearImguiSharp.ImVec2 text_size_if_known)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos_min, null))
                throw new global::System.ArgumentNullException("pos_min", "Cannot be null because it is passed by value.");
            var __arg1 = pos_min.__Instance;
            if (ReferenceEquals(pos_max, null))
                throw new global::System.ArgumentNullException("pos_max", "Cannot be null because it is passed by value.");
            var __arg2 = pos_max.__Instance;
            var __arg7 = text_size_if_known is null ? __IntPtr.Zero : text_size_if_known.__Instance;
            __Internal.RenderTextEllipsis(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, clip_max_x, ellipsis_max_x, text, text_end, __arg7);
        }

        public static void RenderFrame(global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint fill_col, bool border, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrame(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, fill_col, border, rounding);
        }

        public static void RenderFrameBorder(global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, float rounding)
        {
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg0 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg1 = p_max.__Instance;
            __Internal.RenderFrameBorder(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, rounding);
        }

        public static void RenderColorRectWithAlphaCheckerboard(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 p_min, global::DearImguiSharp.ImVec2 p_max, uint fill_col, float grid_step, global::DearImguiSharp.ImVec2 grid_off, float rounding, int flags)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            if (ReferenceEquals(p_max, null))
                throw new global::System.ArgumentNullException("p_max", "Cannot be null because it is passed by value.");
            var __arg2 = p_max.__Instance;
            if (ReferenceEquals(grid_off, null))
                throw new global::System.ArgumentNullException("grid_off", "Cannot be null because it is passed by value.");
            var __arg5 = grid_off.__Instance;
            __Internal.RenderColorRectWithAlphaCheckerboard(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, fill_col, grid_step, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, rounding, flags);
        }

        public static void RenderNavHighlight(global::DearImguiSharp.ImRect bb, uint id, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            __Internal.RenderNavHighlight(__arg0, id, flags);
        }

        public static string FindRenderedTextEnd(string text, string text_end)
        {
            var __ret = __Internal.FindRenderedTextEnd(text, text_end);
            return CppSharp.Runtime.MarshalUtil.GetString(global::System.Text.Encoding.UTF8, __ret);
        }

        public static void RenderMouseCursor(global::DearImguiSharp.ImVec2 pos, float scale, int mouse_cursor, uint col_fill, uint col_border, uint col_shadow)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg0 = pos.__Instance;
            __Internal.RenderMouseCursor(*(global::DearImguiSharp.ImVec2.__Internal*) __arg0, scale, mouse_cursor, col_fill, col_border, col_shadow);
        }

        public static void RenderArrow(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos, uint col, int dir, float scale)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderArrow(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, col, dir, scale);
        }

        public static void RenderBullet(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderBullet(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, col);
        }

        public static void RenderCheckMark(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos, uint col, float sz)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            __Internal.RenderCheckMark(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, col, sz);
        }

        public static void RenderArrowPointingAt(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImVec2 half_sz, int direction, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            if (ReferenceEquals(half_sz, null))
                throw new global::System.ArgumentNullException("half_sz", "Cannot be null because it is passed by value.");
            var __arg2 = half_sz.__Instance;
            __Internal.RenderArrowPointingAt(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, direction, col);
        }

        public static void RenderArrowDockMenu(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImVec2 p_min, float sz, uint col)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(p_min, null))
                throw new global::System.ArgumentNullException("p_min", "Cannot be null because it is passed by value.");
            var __arg1 = p_min.__Instance;
            __Internal.RenderArrowDockMenu(__arg0, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, sz, col);
        }

        public static void RenderRectFilledRangeH(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImRect rect, uint col, float x_start_norm, float x_end_norm, float rounding)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(rect, null))
                throw new global::System.ArgumentNullException("rect", "Cannot be null because it is passed by value.");
            var __arg1 = rect.__Instance;
            __Internal.RenderRectFilledRangeH(__arg0, __arg1, col, x_start_norm, x_end_norm, rounding);
        }

        public static void RenderRectFilledWithHole(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImRect outer, global::DearImguiSharp.ImRect inner, uint col, float rounding)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(outer, null))
                throw new global::System.ArgumentNullException("outer", "Cannot be null because it is passed by value.");
            var __arg1 = outer.__Instance;
            if (ReferenceEquals(inner, null))
                throw new global::System.ArgumentNullException("inner", "Cannot be null because it is passed by value.");
            var __arg2 = inner.__Instance;
            __Internal.RenderRectFilledWithHole(__arg0, __arg1, __arg2, col, rounding);
        }

        public static int CalcRoundingFlagsForRectInRect(global::DearImguiSharp.ImRect r_in, global::DearImguiSharp.ImRect r_outer, float threshold)
        {
            if (ReferenceEquals(r_in, null))
                throw new global::System.ArgumentNullException("r_in", "Cannot be null because it is passed by value.");
            var __arg0 = r_in.__Instance;
            if (ReferenceEquals(r_outer, null))
                throw new global::System.ArgumentNullException("r_outer", "Cannot be null because it is passed by value.");
            var __arg1 = r_outer.__Instance;
            var __ret = __Internal.CalcRoundingFlagsForRectInRect(__arg0, __arg1, threshold);
            return __ret;
        }

        public static void TextEx(string text, string text_end, int flags)
        {
            __Internal.TextEx(text, text_end, flags);
        }

        public static bool ButtonEx(string label, global::DearImguiSharp.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg1 = size_arg.__Instance;
            var __ret = __Internal.ButtonEx(label, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, flags);
            return __ret;
        }

        public static bool CloseButton(uint id, global::DearImguiSharp.ImVec2 pos)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __ret = __Internal.CloseButton(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1);
            return __ret;
        }

        public static bool CollapseButton(uint id, global::DearImguiSharp.ImVec2 pos, global::DearImguiSharp.ImGuiDockNode dock_node)
        {
            if (ReferenceEquals(pos, null))
                throw new global::System.ArgumentNullException("pos", "Cannot be null because it is passed by value.");
            var __arg1 = pos.__Instance;
            var __arg2 = dock_node is null ? __IntPtr.Zero : dock_node.__Instance;
            var __ret = __Internal.CollapseButton(id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg1, __arg2);
            return __ret;
        }

        public static bool ArrowButtonEx(string str_id, int dir, global::DearImguiSharp.ImVec2 size_arg, int flags)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg2 = size_arg.__Instance;
            var __ret = __Internal.ArrowButtonEx(str_id, dir, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, flags);
            return __ret;
        }

        public static void Scrollbar(global::DearImguiSharp.ImGuiAxis axis)
        {
            __Internal.Scrollbar(axis);
        }

        public static bool ScrollbarEx(global::DearImguiSharp.ImRect bb, uint id, global::DearImguiSharp.ImGuiAxis axis, ref long p_scroll_v, long avail_v, long contents_v, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (long* __p_scroll_v3 = &p_scroll_v)
            {
                var __arg3 = __p_scroll_v3;
                var __ret = __Internal.ScrollbarEx(__arg0, id, axis, __arg3, avail_v, contents_v, flags);
                return __ret;
            }
        }

        public static bool ImageButtonEx(uint id, __IntPtr texture_id, global::DearImguiSharp.ImVec2 size, global::DearImguiSharp.ImVec2 uv0, global::DearImguiSharp.ImVec2 uv1, global::DearImguiSharp.ImVec2 padding, global::DearImguiSharp.ImVec4 bg_col, global::DearImguiSharp.ImVec4 tint_col)
        {
            if (ReferenceEquals(size, null))
                throw new global::System.ArgumentNullException("size", "Cannot be null because it is passed by value.");
            var __arg2 = size.__Instance;
            if (ReferenceEquals(uv0, null))
                throw new global::System.ArgumentNullException("uv0", "Cannot be null because it is passed by value.");
            var __arg3 = uv0.__Instance;
            if (ReferenceEquals(uv1, null))
                throw new global::System.ArgumentNullException("uv1", "Cannot be null because it is passed by value.");
            var __arg4 = uv1.__Instance;
            if (ReferenceEquals(padding, null))
                throw new global::System.ArgumentNullException("padding", "Cannot be null because it is passed by value.");
            var __arg5 = padding.__Instance;
            if (ReferenceEquals(bg_col, null))
                throw new global::System.ArgumentNullException("bg_col", "Cannot be null because it is passed by value.");
            var __arg6 = bg_col.__Instance;
            if (ReferenceEquals(tint_col, null))
                throw new global::System.ArgumentNullException("tint_col", "Cannot be null because it is passed by value.");
            var __arg7 = tint_col.__Instance;
            var __ret = __Internal.ImageButtonEx(id, texture_id, *(global::DearImguiSharp.ImVec2.__Internal*) __arg2, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec4.__Internal*) __arg6, *(global::DearImguiSharp.ImVec4.__Internal*) __arg7);
            return __ret;
        }

        public static void GetWindowScrollbarRect(global::DearImguiSharp.ImRect pOut, global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiAxis axis)
        {
            var __arg0 = pOut is null ? __IntPtr.Zero : pOut.__Instance;
            var __arg1 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GetWindowScrollbarRect(__arg0, __arg1, axis);
        }

        public static uint GetWindowScrollbarID(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiAxis axis)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowScrollbarID(__arg0, axis);
            return __ret;
        }

        public static uint GetWindowResizeCornerID(global::DearImguiSharp.ImGuiWindow window, int n)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowResizeCornerID(__arg0, n);
            return __ret;
        }

        public static uint GetWindowResizeBorderID(global::DearImguiSharp.ImGuiWindow window, int dir)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.GetWindowResizeBorderID(__arg0, dir);
            return __ret;
        }

        public static void SeparatorEx(int flags)
        {
            __Internal.SeparatorEx(flags);
        }

        public static bool CheckboxFlagsS64Ptr(string label, ref long flags, long flags_value)
        {
            fixed (long* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsS64Ptr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool CheckboxFlagsU64Ptr(string label, ref ulong flags, ulong flags_value)
        {
            fixed (ulong* __flags1 = &flags)
            {
                var __arg1 = __flags1;
                var __ret = __Internal.CheckboxFlagsU64Ptr(label, __arg1, flags_value);
                return __ret;
            }
        }

        public static bool ButtonBehavior(global::DearImguiSharp.ImRect bb, uint id, ref bool out_hovered, ref bool out_held, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (bool* __out_hovered2 = &out_hovered)
            {
                var __arg2 = __out_hovered2;
                fixed (bool* __out_held3 = &out_held)
                {
                    var __arg3 = __out_held3;
                    var __ret = __Internal.ButtonBehavior(__arg0, id, __arg2, __arg3, flags);
                    return __ret;
                }
            }
        }

        public static bool DragBehavior(uint id, int data_type, __IntPtr p_v, float v_speed, __IntPtr p_min, __IntPtr p_max, string format, int flags)
        {
            var __ret = __Internal.DragBehavior(id, data_type, p_v, v_speed, p_min, p_max, format, flags);
            return __ret;
        }

        public static bool SliderBehavior(global::DearImguiSharp.ImRect bb, uint id, int data_type, __IntPtr p_v, __IntPtr p_min, __IntPtr p_max, string format, int flags, global::DearImguiSharp.ImRect out_grab_bb)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __arg8 = out_grab_bb is null ? __IntPtr.Zero : out_grab_bb.__Instance;
            var __ret = __Internal.SliderBehavior(__arg0, id, data_type, p_v, p_min, p_max, format, flags, __arg8);
            return __ret;
        }

        public static bool SplitterBehavior(global::DearImguiSharp.ImRect bb, uint id, global::DearImguiSharp.ImGuiAxis axis, ref float size1, ref float size2, float min_size1, float min_size2, float hover_extend, float hover_visibility_delay, uint bg_col)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            fixed (float* __size13 = &size1)
            {
                var __arg3 = __size13;
                fixed (float* __size24 = &size2)
                {
                    var __arg4 = __size24;
                    var __ret = __Internal.SplitterBehavior(__arg0, id, axis, __arg3, __arg4, min_size1, min_size2, hover_extend, hover_visibility_delay, bg_col);
                    return __ret;
                }
            }
        }

        public static bool TreeNodeBehavior(uint id, int flags, string label, string label_end)
        {
            var __ret = __Internal.TreeNodeBehavior(id, flags, label, label_end);
            return __ret;
        }

        public static bool TreeNodeBehaviorIsOpen(uint id, int flags)
        {
            var __ret = __Internal.TreeNodeBehaviorIsOpen(id, flags);
            return __ret;
        }

        public static void TreePushOverrideID(uint id)
        {
            __Internal.TreePushOverrideID(id);
        }

        public static global::DearImguiSharp.ImGuiDataTypeInfo DataTypeGetInfo(int data_type)
        {
            var __ret = __Internal.DataTypeGetInfo(data_type);
            var __result0 = global::DearImguiSharp.ImGuiDataTypeInfo.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static int DataTypeFormatString(sbyte* buf, int buf_size, int data_type, __IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeFormatString(buf, buf_size, data_type, p_data, format);
            return __ret;
        }

        public static void DataTypeApplyOp(int data_type, int op, __IntPtr output, __IntPtr arg_1, __IntPtr arg_2)
        {
            __Internal.DataTypeApplyOp(data_type, op, output, arg_1, arg_2);
        }

        public static bool DataTypeApplyFromText(string buf, int data_type, __IntPtr p_data, string format)
        {
            var __ret = __Internal.DataTypeApplyFromText(buf, data_type, p_data, format);
            return __ret;
        }

        public static int DataTypeCompare(int data_type, __IntPtr arg_1, __IntPtr arg_2)
        {
            var __ret = __Internal.DataTypeCompare(data_type, arg_1, arg_2);
            return __ret;
        }

        public static bool DataTypeClamp(int data_type, __IntPtr p_data, __IntPtr p_min, __IntPtr p_max)
        {
            var __ret = __Internal.DataTypeClamp(data_type, p_data, p_min, p_max);
            return __ret;
        }

        public static bool InputTextEx(string label, string hint, sbyte* buf, int buf_size, global::DearImguiSharp.ImVec2 size_arg, int flags, global::DearImguiSharp.ImGuiInputTextCallback callback, __IntPtr user_data)
        {
            if (ReferenceEquals(size_arg, null))
                throw new global::System.ArgumentNullException("size_arg", "Cannot be null because it is passed by value.");
            var __arg4 = size_arg.__Instance;
            var __arg6 = callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(callback);
            var __ret = __Internal.InputTextEx(label, hint, buf, buf_size, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, flags, __arg6, user_data);
            return __ret;
        }

        public static bool TempInputText(global::DearImguiSharp.ImRect bb, uint id, string label, sbyte* buf, int buf_size, int flags)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.TempInputText(__arg0, id, label, buf, buf_size, flags);
            return __ret;
        }

        public static bool TempInputScalar(global::DearImguiSharp.ImRect bb, uint id, string label, int data_type, __IntPtr p_data, string format, __IntPtr p_clamp_min, __IntPtr p_clamp_max)
        {
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg0 = bb.__Instance;
            var __ret = __Internal.TempInputScalar(__arg0, id, label, data_type, p_data, format, p_clamp_min, p_clamp_max);
            return __ret;
        }

        public static bool TempInputIsActive(uint id)
        {
            var __ret = __Internal.TempInputIsActive(id);
            return __ret;
        }

        public static global::DearImguiSharp.ImGuiInputTextState GetInputTextState(uint id)
        {
            var __ret = __Internal.GetInputTextState(id);
            var __result0 = global::DearImguiSharp.ImGuiInputTextState.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ColorTooltip(string text, ref float col, int flags)
        {
            fixed (float* __col1 = &col)
            {
                var __arg1 = __col1;
                __Internal.ColorTooltip(text, __arg1, flags);
            }
        }

        public static void ColorEditOptionsPopup(ref float col, int flags)
        {
            fixed (float* __col0 = &col)
            {
                var __arg0 = __col0;
                __Internal.ColorEditOptionsPopup(__arg0, flags);
            }
        }

        public static void ColorPickerOptionsPopup(ref float ref_col, int flags)
        {
            fixed (float* __ref_col0 = &ref_col)
            {
                var __arg0 = __ref_col0;
                __Internal.ColorPickerOptionsPopup(__arg0, flags);
            }
        }

        public static int PlotEx(global::DearImguiSharp.ImGuiPlotType plot_type, string label, global::DearImguiSharp.Delegates.Func_float___IntPtr_int values_getter, __IntPtr data, int values_count, int values_offset, string overlay_text, float scale_min, float scale_max, global::DearImguiSharp.ImVec2 frame_size)
        {
            var __arg2 = values_getter == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(values_getter);
            if (ReferenceEquals(frame_size, null))
                throw new global::System.ArgumentNullException("frame_size", "Cannot be null because it is passed by value.");
            var __arg9 = frame_size.__Instance;
            var __ret = __Internal.PlotEx(plot_type, label, __arg2, data, values_count, values_offset, overlay_text, scale_min, scale_max, *(global::DearImguiSharp.ImVec2.__Internal*) __arg9);
            return __ret;
        }

        public static void ShadeVertsLinearColorGradientKeepAlpha(global::DearImguiSharp.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::DearImguiSharp.ImVec2 gradient_p0, global::DearImguiSharp.ImVec2 gradient_p1, uint col0, uint col1)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(gradient_p0, null))
                throw new global::System.ArgumentNullException("gradient_p0", "Cannot be null because it is passed by value.");
            var __arg3 = gradient_p0.__Instance;
            if (ReferenceEquals(gradient_p1, null))
                throw new global::System.ArgumentNullException("gradient_p1", "Cannot be null because it is passed by value.");
            var __arg4 = gradient_p1.__Instance;
            __Internal.ShadeVertsLinearColorGradientKeepAlpha(__arg0, vert_start_idx, vert_end_idx, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, col0, col1);
        }

        public static void ShadeVertsLinearUV(global::DearImguiSharp.ImDrawList draw_list, int vert_start_idx, int vert_end_idx, global::DearImguiSharp.ImVec2 a, global::DearImguiSharp.ImVec2 b, global::DearImguiSharp.ImVec2 uv_a, global::DearImguiSharp.ImVec2 uv_b, bool clamp)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            if (ReferenceEquals(a, null))
                throw new global::System.ArgumentNullException("a", "Cannot be null because it is passed by value.");
            var __arg3 = a.__Instance;
            if (ReferenceEquals(b, null))
                throw new global::System.ArgumentNullException("b", "Cannot be null because it is passed by value.");
            var __arg4 = b.__Instance;
            if (ReferenceEquals(uv_a, null))
                throw new global::System.ArgumentNullException("uv_a", "Cannot be null because it is passed by value.");
            var __arg5 = uv_a.__Instance;
            if (ReferenceEquals(uv_b, null))
                throw new global::System.ArgumentNullException("uv_b", "Cannot be null because it is passed by value.");
            var __arg6 = uv_b.__Instance;
            __Internal.ShadeVertsLinearUV(__arg0, vert_start_idx, vert_end_idx, *(global::DearImguiSharp.ImVec2.__Internal*) __arg3, *(global::DearImguiSharp.ImVec2.__Internal*) __arg4, *(global::DearImguiSharp.ImVec2.__Internal*) __arg5, *(global::DearImguiSharp.ImVec2.__Internal*) __arg6, clamp);
        }

        public static void GcCompactTransientMiscBuffers()
        {
            __Internal.GcCompactTransientMiscBuffers();
        }

        public static void GcCompactTransientWindowBuffers(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GcCompactTransientWindowBuffers(__arg0);
        }

        public static void GcAwakeTransientWindowBuffers(global::DearImguiSharp.ImGuiWindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.GcAwakeTransientWindowBuffers(__arg0);
        }

        public static void DebugLog(string fmt)
        {
            __Internal.DebugLog(fmt);
        }

        public static void ErrorCheckEndFrameRecover(global::DearImguiSharp.ImGuiErrorLogCallback log_callback, __IntPtr user_data)
        {
            var __arg0 = log_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(log_callback);
            __Internal.ErrorCheckEndFrameRecover(__arg0, user_data);
        }

        public static void ErrorCheckEndWindowRecover(global::DearImguiSharp.ImGuiErrorLogCallback log_callback, __IntPtr user_data)
        {
            var __arg0 = log_callback == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(log_callback);
            __Internal.ErrorCheckEndWindowRecover(__arg0, user_data);
        }

        public static void DebugDrawItemRect(uint col)
        {
            __Internal.DebugDrawItemRect(col);
        }

        public static void DebugStartItemPicker()
        {
            __Internal.DebugStartItemPicker();
        }

        public static void ShowFontAtlas(global::DearImguiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ShowFontAtlas(__arg0);
        }

        public static void DebugHookIdInfo(uint id, int data_type, __IntPtr data_id, __IntPtr data_id_end)
        {
            __Internal.DebugHookIdInfo(id, data_type, data_id, data_id_end);
        }

        public static void DebugNodeColumns(global::DearImguiSharp.ImGuiOldColumns columns)
        {
            var __arg0 = columns is null ? __IntPtr.Zero : columns.__Instance;
            __Internal.DebugNodeColumns(__arg0);
        }

        public static void DebugNodeDockNode(global::DearImguiSharp.ImGuiDockNode node, string label)
        {
            var __arg0 = node is null ? __IntPtr.Zero : node.__Instance;
            __Internal.DebugNodeDockNode(__arg0, label);
        }

        public static void DebugNodeDrawList(global::DearImguiSharp.ImGuiWindow window, global::DearImguiSharp.ImGuiViewportP viewport, global::DearImguiSharp.ImDrawList draw_list, string label)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            var __arg2 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            __Internal.DebugNodeDrawList(__arg0, __arg1, __arg2, label);
        }

        public static void DebugNodeDrawCmdShowMeshAndBoundingBox(global::DearImguiSharp.ImDrawList out_draw_list, global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImDrawCmd draw_cmd, bool show_mesh, bool show_aabb)
        {
            var __arg0 = out_draw_list is null ? __IntPtr.Zero : out_draw_list.__Instance;
            var __arg1 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            var __arg2 = draw_cmd is null ? __IntPtr.Zero : draw_cmd.__Instance;
            __Internal.DebugNodeDrawCmdShowMeshAndBoundingBox(__arg0, __arg1, __arg2, show_mesh, show_aabb);
        }

        public static void DebugNodeFont(global::DearImguiSharp.ImFont font)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            __Internal.DebugNodeFont(__arg0);
        }

        public static void DebugNodeFontGlyph(global::DearImguiSharp.ImFont font, global::DearImguiSharp.ImFontGlyph glyph)
        {
            var __arg0 = font is null ? __IntPtr.Zero : font.__Instance;
            var __arg1 = glyph is null ? __IntPtr.Zero : glyph.__Instance;
            __Internal.DebugNodeFontGlyph(__arg0, __arg1);
        }

        public static void DebugNodeStorage(global::DearImguiSharp.ImGuiStorage storage, string label)
        {
            var __arg0 = storage is null ? __IntPtr.Zero : storage.__Instance;
            __Internal.DebugNodeStorage(__arg0, label);
        }

        public static void DebugNodeTabBar(global::DearImguiSharp.ImGuiTabBar tab_bar, string label)
        {
            var __arg0 = tab_bar is null ? __IntPtr.Zero : tab_bar.__Instance;
            __Internal.DebugNodeTabBar(__arg0, label);
        }

        public static void DebugNodeTable(global::DearImguiSharp.ImGuiTable table)
        {
            var __arg0 = table is null ? __IntPtr.Zero : table.__Instance;
            __Internal.DebugNodeTable(__arg0);
        }

        public static void DebugNodeTableSettings(global::DearImguiSharp.ImGuiTableSettings settings)
        {
            var __arg0 = settings is null ? __IntPtr.Zero : settings.__Instance;
            __Internal.DebugNodeTableSettings(__arg0);
        }

        public static void DebugNodeInputTextState(global::DearImguiSharp.ImGuiInputTextState state)
        {
            var __arg0 = state is null ? __IntPtr.Zero : state.__Instance;
            __Internal.DebugNodeInputTextState(__arg0);
        }

        public static void DebugNodeWindow(global::DearImguiSharp.ImGuiWindow window, string label)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.DebugNodeWindow(__arg0, label);
        }

        public static void DebugNodeWindowSettings(global::DearImguiSharp.ImGuiWindowSettings settings)
        {
            var __arg0 = settings is null ? __IntPtr.Zero : settings.__Instance;
            __Internal.DebugNodeWindowSettings(__arg0);
        }

        public static void DebugNodeWindowsList(global::DearImguiSharp.ImVectorImGuiWindowPtr windows, string label)
        {
            var __arg0 = windows is null ? __IntPtr.Zero : windows.__Instance;
            __Internal.DebugNodeWindowsList(__arg0, label);
        }

        public static void DebugNodeWindowsListByBeginStackParent(global::DearImguiSharp.ImGuiWindow windows, int windows_size, global::DearImguiSharp.ImGuiWindow parent_in_begin_stack)
        {
            var ____arg0 = windows is null ? __IntPtr.Zero : windows.__Instance;
            var __arg0 = new __IntPtr(&____arg0);
            var __arg2 = parent_in_begin_stack is null ? __IntPtr.Zero : parent_in_begin_stack.__Instance;
            __Internal.DebugNodeWindowsListByBeginStackParent(__arg0, windows_size, __arg2);
        }

        public static void DebugNodeViewport(global::DearImguiSharp.ImGuiViewportP viewport)
        {
            var __arg0 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            __Internal.DebugNodeViewport(__arg0);
        }

        public static void DebugRenderViewportThumbnail(global::DearImguiSharp.ImDrawList draw_list, global::DearImguiSharp.ImGuiViewportP viewport, global::DearImguiSharp.ImRect bb)
        {
            var __arg0 = draw_list is null ? __IntPtr.Zero : draw_list.__Instance;
            var __arg1 = viewport is null ? __IntPtr.Zero : viewport.__Instance;
            if (ReferenceEquals(bb, null))
                throw new global::System.ArgumentNullException("bb", "Cannot be null because it is passed by value.");
            var __arg2 = bb.__Instance;
            __Internal.DebugRenderViewportThumbnail(__arg0, __arg1, __arg2);
        }

        public static global::DearImguiSharp.ImFontBuilderIO ImFontAtlasGetBuilderForStbTruetype()
        {
            var __ret = __Internal.ImFontAtlasGetBuilderForStbTruetype();
            var __result0 = global::DearImguiSharp.ImFontBuilderIO.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImFontAtlasBuildInit(global::DearImguiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildInit(__arg0);
        }

        public static void ImFontAtlasBuildSetupFont(global::DearImguiSharp.ImFontAtlas atlas, global::DearImguiSharp.ImFont font, global::DearImguiSharp.ImFontConfig font_config, float ascent, float descent)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            var __arg1 = font is null ? __IntPtr.Zero : font.__Instance;
            var __arg2 = font_config is null ? __IntPtr.Zero : font_config.__Instance;
            __Internal.ImFontAtlasBuildSetupFont(__arg0, __arg1, __arg2, ascent, descent);
        }

        public static void ImFontAtlasBuildPackCustomRects(global::DearImguiSharp.ImFontAtlas atlas, __IntPtr stbrp_context_opaque)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildPackCustomRects(__arg0, stbrp_context_opaque);
        }

        public static void ImFontAtlasBuildFinish(global::DearImguiSharp.ImFontAtlas atlas)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildFinish(__arg0);
        }

        public static void ImFontAtlasBuildRender8bppRectFromString(global::DearImguiSharp.ImFontAtlas atlas, int x, int y, int w, int h, string in_str, sbyte in_marker_char, byte in_marker_pixel_value)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildRender8bppRectFromString(__arg0, x, y, w, h, in_str, in_marker_char, in_marker_pixel_value);
        }

        public static void ImFontAtlasBuildRender32bppRectFromString(global::DearImguiSharp.ImFontAtlas atlas, int x, int y, int w, int h, string in_str, sbyte in_marker_char, uint in_marker_pixel_value)
        {
            var __arg0 = atlas is null ? __IntPtr.Zero : atlas.__Instance;
            __Internal.ImFontAtlasBuildRender32bppRectFromString(__arg0, x, y, w, h, in_str, in_marker_char, in_marker_pixel_value);
        }

        public static void ImFontAtlasBuildMultiplyCalcLookupTable(byte[] out_table, float in_multiply_factor)
        {
            if (out_table == null || out_table.Length != 256)
                throw new ArgumentOutOfRangeException("out_table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyCalcLookupTable(out_table, in_multiply_factor);
        }

        public static void ImFontAtlasBuildMultiplyRectAlpha8(byte[] table, byte* pixels, int x, int y, int w, int h, int stride)
        {
            if (table == null || table.Length != 256)
                throw new ArgumentOutOfRangeException("table", "The dimensions of the provided array don't match the required size.");
            __Internal.ImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride);
        }

        /// <summary>//////////////////////hand written functions</summary>
        public static void LogText(string fmt)
        {
            __Internal.LogText(fmt);
        }

        public static float GET_FLT_MAX()
        {
            var __ret = __Internal.GET_FLT_MAX();
            return __ret;
        }

        public static float GET_FLT_MIN()
        {
            var __ret = __Internal.GET_FLT_MIN();
            return __ret;
        }

        public static global::DearImguiSharp.ImVectorImWchar ImVectorImWchar_create()
        {
            var __ret = __Internal.ImVectorImWchar_create();
            var __result0 = global::DearImguiSharp.ImVectorImWchar.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static void ImVectorImWchar_destroy(global::DearImguiSharp.ImVectorImWchar self)
        {
            var __arg0 = self is null ? __IntPtr.Zero : self.__Instance;
            __Internal.ImVectorImWchar_destroy(__arg0);
        }

        public static void ImVectorImWcharInit(global::DearImguiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharInit(__arg0);
        }

        public static void ImVectorImWcharUnInit(global::DearImguiSharp.ImVectorImWchar p)
        {
            var __arg0 = p is null ? __IntPtr.Zero : p.__Instance;
            __Internal.ImVectorImWcharUnInit(__arg0);
        }
    }

    public unsafe partial class IDirect3DDevice9
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.IDirect3DDevice9>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.IDirect3DDevice9>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.IDirect3DDevice9 managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.IDirect3DDevice9>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.IDirect3DDevice9 managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static IDirect3DDevice9 __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new IDirect3DDevice9(native.ToPointer(), skipVTables);
        }

        internal static IDirect3DDevice9 __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (IDirect3DDevice9)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static IDirect3DDevice9 __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new IDirect3DDevice9(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private IDirect3DDevice9(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public IDirect3DDevice9(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D11Device
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D11Device>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D11Device>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ID3D11Device managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ID3D11Device>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ID3D11Device managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ID3D11Device __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D11Device(native.ToPointer(), skipVTables);
        }

        internal static ID3D11Device __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ID3D11Device)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ID3D11Device __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D11Device(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11Device(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ID3D11Device(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D11DeviceContext
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D11DeviceContext>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D11DeviceContext>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ID3D11DeviceContext managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ID3D11DeviceContext>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ID3D11DeviceContext managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ID3D11DeviceContext __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D11DeviceContext(native.ToPointer(), skipVTables);
        }

        internal static ID3D11DeviceContext __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ID3D11DeviceContext)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ID3D11DeviceContext __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D11DeviceContext(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D11DeviceContext(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ID3D11DeviceContext(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D12Device
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12Device>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12Device>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ID3D12Device managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ID3D12Device>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ID3D12Device managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ID3D12Device __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D12Device(native.ToPointer(), skipVTables);
        }

        internal static ID3D12Device __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ID3D12Device)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ID3D12Device __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D12Device(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D12Device(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ID3D12Device(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D12DescriptorHeap
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12DescriptorHeap>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12DescriptorHeap>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ID3D12DescriptorHeap managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ID3D12DescriptorHeap>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ID3D12DescriptorHeap managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ID3D12DescriptorHeap __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D12DescriptorHeap(native.ToPointer(), skipVTables);
        }

        internal static ID3D12DescriptorHeap __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ID3D12DescriptorHeap)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ID3D12DescriptorHeap __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D12DescriptorHeap(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D12DescriptorHeap(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ID3D12DescriptorHeap(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ID3D12GraphicsCommandList
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12GraphicsCommandList>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ID3D12GraphicsCommandList>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ID3D12GraphicsCommandList managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ID3D12GraphicsCommandList>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ID3D12GraphicsCommandList managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ID3D12GraphicsCommandList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ID3D12GraphicsCommandList(native.ToPointer(), skipVTables);
        }

        internal static ID3D12GraphicsCommandList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ID3D12GraphicsCommandList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ID3D12GraphicsCommandList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ID3D12GraphicsCommandList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ID3D12GraphicsCommandList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ID3D12GraphicsCommandList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class D3D12CPU_DESCRIPTOR_HANDLE
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.D3D12CPU_DESCRIPTOR_HANDLE>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.D3D12CPU_DESCRIPTOR_HANDLE>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.D3D12CPU_DESCRIPTOR_HANDLE managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.D3D12CPU_DESCRIPTOR_HANDLE>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.D3D12CPU_DESCRIPTOR_HANDLE managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static D3D12CPU_DESCRIPTOR_HANDLE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new D3D12CPU_DESCRIPTOR_HANDLE(native.ToPointer(), skipVTables);
        }

        internal static D3D12CPU_DESCRIPTOR_HANDLE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (D3D12CPU_DESCRIPTOR_HANDLE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static D3D12CPU_DESCRIPTOR_HANDLE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new D3D12CPU_DESCRIPTOR_HANDLE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private D3D12CPU_DESCRIPTOR_HANDLE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public D3D12CPU_DESCRIPTOR_HANDLE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class D3D12GPU_DESCRIPTOR_HANDLE
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.D3D12GPU_DESCRIPTOR_HANDLE>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.D3D12GPU_DESCRIPTOR_HANDLE>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.D3D12GPU_DESCRIPTOR_HANDLE managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.D3D12GPU_DESCRIPTOR_HANDLE>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.D3D12GPU_DESCRIPTOR_HANDLE managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static D3D12GPU_DESCRIPTOR_HANDLE __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new D3D12GPU_DESCRIPTOR_HANDLE(native.ToPointer(), skipVTables);
        }

        internal static D3D12GPU_DESCRIPTOR_HANDLE __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (D3D12GPU_DESCRIPTOR_HANDLE)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static D3D12GPU_DESCRIPTOR_HANDLE __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new D3D12GPU_DESCRIPTOR_HANDLE(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private D3D12GPU_DESCRIPTOR_HANDLE(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public D3D12GPU_DESCRIPTOR_HANDLE(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class GLFWwindow
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.GLFWwindow>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.GLFWwindow>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.GLFWwindow managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.GLFWwindow>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.GLFWwindow managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GLFWwindow __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWwindow(native.ToPointer(), skipVTables);
        }

        internal static GLFWwindow __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GLFWwindow)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GLFWwindow __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWwindow(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWwindow(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GLFWwindow(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class GLFWmonitor
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.GLFWmonitor>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.GLFWmonitor>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.GLFWmonitor managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.GLFWmonitor>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.GLFWmonitor managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static GLFWmonitor __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new GLFWmonitor(native.ToPointer(), skipVTables);
        }

        internal static GLFWmonitor __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (GLFWmonitor)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static GLFWmonitor __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new GLFWmonitor(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private GLFWmonitor(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public GLFWmonitor(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL_Window
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Window>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Window>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.SDL_Window managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.SDL_Window>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.SDL_Window managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SDL_Window __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SDL_Window(native.ToPointer(), skipVTables);
        }

        internal static SDL_Window __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SDL_Window)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SDL_Window __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SDL_Window(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SDL_Window(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SDL_Window(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL_Renderer
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Renderer>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Renderer>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.SDL_Renderer managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.SDL_Renderer>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.SDL_Renderer managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SDL_Renderer __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SDL_Renderer(native.ToPointer(), skipVTables);
        }

        internal static SDL_Renderer __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SDL_Renderer)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SDL_Renderer __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SDL_Renderer(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SDL_Renderer(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SDL_Renderer(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class SDL_Event
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Event>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.SDL_Event>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.SDL_Event managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.SDL_Event>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.SDL_Event managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static SDL_Event __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new SDL_Event(native.ToPointer(), skipVTables);
        }

        internal static SDL_Event __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (SDL_Event)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static SDL_Event __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new SDL_Event(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private SDL_Event(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public SDL_Event(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class ImGuiImplVulkanInitInfo : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 88)]
        public partial struct __Internal
        {
            public __IntPtr Instance;
            public __IntPtr PhysicalDevice;
            public __IntPtr Device;
            public uint QueueFamily;
            public __IntPtr Queue;
            public __IntPtr PipelineCache;
            public __IntPtr DescriptorPool;
            public uint Subpass;
            public uint MinImageCount;
            public uint ImageCount;
            public global::DearImguiSharp.VkSampleCountFlagBits MSAASamples;
            public __IntPtr Allocator;
            public __IntPtr CheckVkResultFn;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGui_ImplVulkan_InitInfo@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanInitInfo>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanInitInfo>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiImplVulkanInitInfo managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanInitInfo>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiImplVulkanInitInfo managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiImplVulkanInitInfo __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanInitInfo(native.ToPointer(), skipVTables);
        }

        internal static ImGuiImplVulkanInitInfo __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiImplVulkanInitInfo)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiImplVulkanInitInfo __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanInitInfo(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiImplVulkanInitInfo(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanInitInfo(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiImplVulkanInitInfo()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanInitInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanInitInfo(global::DearImguiSharp.ImGuiImplVulkanInitInfo _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanInitInfo.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiImplVulkanInitInfo.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiImplVulkanInitInfo.__Internal*) _0.__Instance);
        }

        ~ImGuiImplVulkanInitInfo()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.VkInstanceT Instance
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkInstanceT.__GetOrCreateInstance(((__Internal*)__Instance)->Instance, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Instance = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkPhysicalDeviceT PhysicalDevice
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkPhysicalDeviceT.__GetOrCreateInstance(((__Internal*)__Instance)->PhysicalDevice, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->PhysicalDevice = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkDeviceT Device
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkDeviceT.__GetOrCreateInstance(((__Internal*)__Instance)->Device, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Device = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint QueueFamily
        {
            get
            {
                return ((__Internal*)__Instance)->QueueFamily;
            }

            set
            {
                ((__Internal*)__Instance)->QueueFamily = value;
            }
        }

        public global::DearImguiSharp.VkQueueT Queue
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkQueueT.__GetOrCreateInstance(((__Internal*)__Instance)->Queue, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Queue = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkPipelineCacheT PipelineCache
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkPipelineCacheT.__GetOrCreateInstance(((__Internal*)__Instance)->PipelineCache, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->PipelineCache = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkDescriptorPoolT DescriptorPool
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkDescriptorPoolT.__GetOrCreateInstance(((__Internal*)__Instance)->DescriptorPool, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->DescriptorPool = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public uint Subpass
        {
            get
            {
                return ((__Internal*)__Instance)->Subpass;
            }

            set
            {
                ((__Internal*)__Instance)->Subpass = value;
            }
        }

        public uint MinImageCount
        {
            get
            {
                return ((__Internal*)__Instance)->MinImageCount;
            }

            set
            {
                ((__Internal*)__Instance)->MinImageCount = value;
            }
        }

        public uint ImageCount
        {
            get
            {
                return ((__Internal*)__Instance)->ImageCount;
            }

            set
            {
                ((__Internal*)__Instance)->ImageCount = value;
            }
        }

        public global::DearImguiSharp.VkSampleCountFlagBits MSAASamples
        {
            get
            {
                return ((__Internal*)__Instance)->MSAASamples;
            }

            set
            {
                ((__Internal*)__Instance)->MSAASamples = value;
            }
        }

        public global::DearImguiSharp.VkAllocationCallbacks Allocator
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkAllocationCallbacks.__GetOrCreateInstance(((__Internal*)__Instance)->Allocator, false);
                return __result0;
            }
        }

        public global::DearImguiSharp.Delegates.Action_DearImguiSharp_VkResult CheckVkResultFn
        {
            get
            {
                var __ptr0 = ((__Internal*)__Instance)->CheckVkResultFn;
                return __ptr0 == IntPtr.Zero? null : (global::DearImguiSharp.Delegates.Action_DearImguiSharp_VkResult) Marshal.GetDelegateForFunctionPointer(__ptr0, typeof(global::DearImguiSharp.Delegates.Action_DearImguiSharp_VkResult));
            }

            set
            {
                ((__Internal*)__Instance)->CheckVkResultFn = value == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(value);
            }
        }
    }

    public unsafe partial class ImGuiImplVulkanH_Frame : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 48)]
        public partial struct __Internal
        {
            public __IntPtr CommandPool;
            public __IntPtr CommandBuffer;
            public __IntPtr Fence;
            public __IntPtr Backbuffer;
            public __IntPtr BackbufferView;
            public __IntPtr Framebuffer;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGui_ImplVulkanH_Frame@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Frame>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Frame>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiImplVulkanH_Frame managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Frame>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiImplVulkanH_Frame managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiImplVulkanH_Frame __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_Frame(native.ToPointer(), skipVTables);
        }

        internal static ImGuiImplVulkanH_Frame __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiImplVulkanH_Frame)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiImplVulkanH_Frame __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_Frame(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiImplVulkanH_Frame(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_Frame(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiImplVulkanH_Frame()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_Frame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_Frame(global::DearImguiSharp.ImGuiImplVulkanH_Frame _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_Frame.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiImplVulkanH_Frame.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiImplVulkanH_Frame.__Internal*) _0.__Instance);
        }

        ~ImGuiImplVulkanH_Frame()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.VkCommandPoolT CommandPool
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkCommandPoolT.__GetOrCreateInstance(((__Internal*)__Instance)->CommandPool, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CommandPool = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkCommandBufferT CommandBuffer
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkCommandBufferT.__GetOrCreateInstance(((__Internal*)__Instance)->CommandBuffer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->CommandBuffer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkFenceT Fence
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkFenceT.__GetOrCreateInstance(((__Internal*)__Instance)->Fence, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Fence = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkImageT Backbuffer
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkImageT.__GetOrCreateInstance(((__Internal*)__Instance)->Backbuffer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Backbuffer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkImageViewT BackbufferView
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkImageViewT.__GetOrCreateInstance(((__Internal*)__Instance)->BackbufferView, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->BackbufferView = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkFramebufferT Framebuffer
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkFramebufferT.__GetOrCreateInstance(((__Internal*)__Instance)->Framebuffer, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Framebuffer = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiImplVulkanH_FrameSemaphores : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            public __IntPtr ImageAcquiredSemaphore;
            public __IntPtr RenderCompleteSemaphore;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGui_ImplVulkanH_FrameSemaphores@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiImplVulkanH_FrameSemaphores __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_FrameSemaphores(native.ToPointer(), skipVTables);
        }

        internal static ImGuiImplVulkanH_FrameSemaphores __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiImplVulkanH_FrameSemaphores)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiImplVulkanH_FrameSemaphores __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_FrameSemaphores(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiImplVulkanH_FrameSemaphores(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_FrameSemaphores(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiImplVulkanH_FrameSemaphores()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_FrameSemaphores(global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores.__Internal*) _0.__Instance);
        }

        ~ImGuiImplVulkanH_FrameSemaphores()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::DearImguiSharp.VkSemaphoreT ImageAcquiredSemaphore
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkSemaphoreT.__GetOrCreateInstance(((__Internal*)__Instance)->ImageAcquiredSemaphore, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->ImageAcquiredSemaphore = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkSemaphoreT RenderCompleteSemaphore
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkSemaphoreT.__GetOrCreateInstance(((__Internal*)__Instance)->RenderCompleteSemaphore, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RenderCompleteSemaphore = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGuiImplVulkanH_Window : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 104)]
        public partial struct __Internal
        {
            public int Width;
            public int Height;
            public __IntPtr Swapchain;
            public __IntPtr Surface;
            public global::DearImguiSharp.VkSurfaceFormatKHR.__Internal SurfaceFormat;
            public global::DearImguiSharp.VkPresentModeKHR PresentMode;
            public __IntPtr RenderPass;
            public __IntPtr Pipeline;
            public byte ClearEnable;
            public global::DearImguiSharp.VkClearValue.__Internal ClearValue;
            public uint FrameIndex;
            public uint ImageCount;
            public uint SemaphoreIndex;
            public __IntPtr Frames;
            public __IntPtr FrameSemaphores;

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "??0ImGui_ImplVulkanH_Window@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Window>> NativeToManagedMap =
            new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Window>>();

        internal static void __RecordNativeToManagedMapping(IntPtr native, global::DearImguiSharp.ImGuiImplVulkanH_Window managed)
        {
            NativeToManagedMap[native] = new global::System.WeakReference<global::DearImguiSharp.ImGuiImplVulkanH_Window>(managed);
        }

        internal static bool __TryGetNativeToManagedMapping(IntPtr native, out global::DearImguiSharp.ImGuiImplVulkanH_Window managed)
        {
    
            managed = default;
            return NativeToManagedMap.TryGetValue(native, out var wr) && wr.TryGetTarget(out managed);
        }

        protected bool __ownsNativeInstance;

        internal static ImGuiImplVulkanH_Window __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_Window(native.ToPointer(), skipVTables);
        }

        internal static ImGuiImplVulkanH_Window __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (__TryGetNativeToManagedMapping(native, out var managed))
                return (ImGuiImplVulkanH_Window)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                __RecordNativeToManagedMapping(native, result);
            return result;
        }

        internal static ImGuiImplVulkanH_Window __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new ImGuiImplVulkanH_Window(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private ImGuiImplVulkanH_Window(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_Window(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public ImGuiImplVulkanH_Window()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_Window.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
        }

        public ImGuiImplVulkanH_Window(global::DearImguiSharp.ImGuiImplVulkanH_Window _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::DearImguiSharp.ImGuiImplVulkanH_Window.__Internal));
            __ownsNativeInstance = true;
            __RecordNativeToManagedMapping(__Instance, this);
            *((global::DearImguiSharp.ImGuiImplVulkanH_Window.__Internal*) __Instance) = *((global::DearImguiSharp.ImGuiImplVulkanH_Window.__Internal*) _0.__Instance);
        }

        ~ImGuiImplVulkanH_Window()
        {
            Dispose(false, callNativeDtor : __ownsNativeInstance );
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
            GC.SuppressFinalize(this);
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->Width;
            }

            set
            {
                ((__Internal*)__Instance)->Width = value;
            }
        }

        public int Height
        {
            get
            {
                return ((__Internal*)__Instance)->Height;
            }

            set
            {
                ((__Internal*)__Instance)->Height = value;
            }
        }

        public global::DearImguiSharp.VkSwapchainKHR_T Swapchain
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkSwapchainKHR_T.__GetOrCreateInstance(((__Internal*)__Instance)->Swapchain, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Swapchain = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkSurfaceKHR_T Surface
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkSurfaceKHR_T.__GetOrCreateInstance(((__Internal*)__Instance)->Surface, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Surface = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkSurfaceFormatKHR SurfaceFormat
        {
            get
            {
                return global::DearImguiSharp.VkSurfaceFormatKHR.__CreateInstance(new __IntPtr(&((__Internal*)__Instance)->SurfaceFormat));
            }

            set
            {
                if (ReferenceEquals(value, null))
                    throw new global::System.ArgumentNullException("value", "Cannot be null because it is passed by value.");
                ((__Internal*)__Instance)->SurfaceFormat = *(global::DearImguiSharp.VkSurfaceFormatKHR.__Internal*) value.__Instance;
            }
        }

        public global::DearImguiSharp.VkPresentModeKHR PresentMode
        {
            get
            {
                return ((__Internal*)__Instance)->PresentMode;
            }

            set
            {
                ((__Internal*)__Instance)->PresentMode = value;
            }
        }

        public global::DearImguiSharp.VkRenderPassT RenderPass
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkRenderPassT.__GetOrCreateInstance(((__Internal*)__Instance)->RenderPass, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->RenderPass = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.VkPipelineT Pipeline
        {
            get
            {
                var __result0 = global::DearImguiSharp.VkPipelineT.__GetOrCreateInstance(((__Internal*)__Instance)->Pipeline, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Pipeline = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public bool ClearEnable
        {
            get
            {
                return ((__Internal*)__Instance)->ClearEnable != 0;
            }

            set
            {
                ((__Internal*)__Instance)->ClearEnable = (byte) (value ? 1 : 0);
            }
        }

        public global::DearImguiSharp.VkClearValue ClearValue
        {
            get
            {
                return global::DearImguiSharp.VkClearValue.__CreateInstance(((__Internal*)__Instance)->ClearValue);
            }

            set
            {
                ((__Internal*)__Instance)->ClearValue = value.__Instance;
            }
        }

        public uint FrameIndex
        {
            get
            {
                return ((__Internal*)__Instance)->FrameIndex;
            }

            set
            {
                ((__Internal*)__Instance)->FrameIndex = value;
            }
        }

        public uint ImageCount
        {
            get
            {
                return ((__Internal*)__Instance)->ImageCount;
            }

            set
            {
                ((__Internal*)__Instance)->ImageCount = value;
            }
        }

        public uint SemaphoreIndex
        {
            get
            {
                return ((__Internal*)__Instance)->SemaphoreIndex;
            }

            set
            {
                ((__Internal*)__Instance)->SemaphoreIndex = value;
            }
        }

        public global::DearImguiSharp.ImGuiImplVulkanH_Frame Frames
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiImplVulkanH_Frame.__GetOrCreateInstance(((__Internal*)__Instance)->Frames, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->Frames = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores FrameSemaphores
        {
            get
            {
                var __result0 = global::DearImguiSharp.ImGuiImplVulkanH_FrameSemaphores.__GetOrCreateInstance(((__Internal*)__Instance)->FrameSemaphores, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->FrameSemaphores = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class ImGui
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplWin32Init(__IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_EnableDpiAwareness", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32EnableDpiAwareness();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_GetDpiScaleForHwnd", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiImplWin32GetDpiScaleForHwnd(__IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_GetDpiScaleForMonitor", CallingConvention = __CallingConvention.Cdecl)]
            public static extern float ImGuiImplWin32GetDpiScaleForMonitor(__IntPtr monitor);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplWin32_EnableAlphaCompositing", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplWin32EnableAlphaCompositing(__IntPtr hwnd);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX9Init(__IntPtr device);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX9CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX9_InvalidateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX9InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX11Init(__IntPtr device, __IntPtr device_context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_InvalidateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX11InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX11_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX11CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX12Init(__IntPtr device, int num_frames_in_flight, global::DearImguiSharp.DXGI_FORMAT rtv_format, __IntPtr cbv_srv_heap, IntPtr font_srv_cpu_desc_handle, long font_srv_gpu_desc_handle);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX12Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX12NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX12RenderDrawData(__IntPtr draw_data, __IntPtr graphics_command_list);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_InvalidateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplDX12InvalidateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplDX12_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplDX12CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplVulkanInit(__IntPtr info, __IntPtr render_pass);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanNewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanRenderDrawData(__IntPtr draw_data, __IntPtr command_buffer, __IntPtr pipeline);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_CreateFontsTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplVulkanCreateFontsTexture(__IntPtr command_buffer);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_DestroyFontUploadObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanDestroyFontUploadObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_SetMinImageCount", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanSetMinImageCount(uint min_image_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_AddTexture", CallingConvention = __CallingConvention.Cdecl)]
            public static extern __IntPtr ImGuiImplVulkanAddTexture(__IntPtr sampler, __IntPtr image_view, global::DearImguiSharp.VkImageLayout image_layout);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkan_LoadFunctions", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplVulkanLoadFunctions(__IntPtr loader_func, __IntPtr user_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkanH_CreateOrResizeWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanH_CreateOrResizeWindow(__IntPtr instance, __IntPtr physical_device, __IntPtr device, __IntPtr wnd, uint queue_family, __IntPtr allocator, int w, int h, uint min_image_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkanH_DestroyWindow", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplVulkanH_DestroyWindow(__IntPtr instance, __IntPtr device, __IntPtr wnd, __IntPtr allocator);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkanH_SelectSurfaceFormat", CallingConvention = __CallingConvention.Cdecl)]
            public static extern global::DearImguiSharp.VkSurfaceFormatKHR.__Internal ImGuiImplVulkanH_SelectSurfaceFormat(__IntPtr physical_device, __IntPtr surface, global::DearImguiSharp.VkFormat* request_formats, int request_formats_count, global::DearImguiSharp.VkColorSpaceKHR request_color_space);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkanH_SelectPresentMode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern global::DearImguiSharp.VkPresentModeKHR ImGuiImplVulkanH_SelectPresentMode(__IntPtr physical_device, __IntPtr surface, global::DearImguiSharp.VkPresentModeKHR* request_modes, int request_modes_count);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplVulkanH_GetMinImageCountFromPresentMode", CallingConvention = __CallingConvention.Cdecl)]
            public static extern int ImGuiImplVulkanH_GetMinImageCountFromPresentMode(global::DearImguiSharp.VkPresentModeKHR present_mode);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_InitForOpenGL", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplGlfwInitForOpenGL(__IntPtr window, bool install_callbacks);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_InitForVulkan", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplGlfwInitForVulkan(__IntPtr window, bool install_callbacks);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_InitForOther", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplGlfwInitForOther(__IntPtr window, bool install_callbacks);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwShutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwNewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_InstallCallbacks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwInstallCallbacks(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_RestoreCallbacks", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwRestoreCallbacks(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_WindowFocusCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwWindowFocusCallback(__IntPtr window, int focused);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_CursorEnterCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwCursorEnterCallback(__IntPtr window, int entered);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_CursorPosCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwCursorPosCallback(__IntPtr window, double x, double y);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_MouseButtonCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwMouseButtonCallback(__IntPtr window, int button, int action, int mods);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_ScrollCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwScrollCallback(__IntPtr window, double xoffset, double yoffset);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_KeyCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwKeyCallback(__IntPtr window, int key, int scancode, int action, int mods);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_CharCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwCharCallback(__IntPtr window, uint c);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplGlfw_MonitorCallback", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplGlfwMonitorCallback(__IntPtr monitor, int @event);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL3Init([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string glsl_version);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL3Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL3NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL3RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_CreateFontsTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL3CreateFontsTexture();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_DestroyFontsTexture", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL3DestroyFontsTexture();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL3CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL3_DestroyDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL3DestroyDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_Init", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL2Init();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL2Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL2NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_RenderDrawData", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL2RenderDrawData(__IntPtr draw_data);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_CreateFontsTexture", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL2CreateFontsTexture();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_DestroyFontsTexture", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL2DestroyFontsTexture();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_CreateDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplOpenGL2CreateDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplOpenGL2_DestroyDeviceObjects", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplOpenGL2DestroyDeviceObjects();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_InitForOpenGL", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2InitForOpenGL(__IntPtr window, __IntPtr sdl_gl_context);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_InitForVulkan", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2InitForVulkan(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_InitForD3D", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2InitForD3D(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_InitForMetal", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2InitForMetal(__IntPtr window);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_InitForSDLRenderer", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2InitForSDLRenderer(__IntPtr window, __IntPtr renderer);

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_Shutdown", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplSDL2Shutdown();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_NewFrame", CallingConvention = __CallingConvention.Cdecl)]
            public static extern void ImGuiImplSDL2NewFrame();

            [SuppressUnmanagedCodeSecurity, DllImport("cimgui", EntryPoint = "ImGui_ImplSDL2_ProcessEvent", CallingConvention = __CallingConvention.Cdecl)]
            [return: MarshalAs(UnmanagedType.I1)]
            public static extern bool ImGuiImplSDL2ProcessEvent(__IntPtr @event);
        }

        public static bool ImGuiImplWin32Init(__IntPtr hwnd)
        {
            var __ret = __Internal.ImGuiImplWin32Init(hwnd);
            return __ret;
        }

        public static void ImGuiImplWin32Shutdown()
        {
            __Internal.ImGuiImplWin32Shutdown();
        }

        public static void ImGuiImplWin32NewFrame()
        {
            __Internal.ImGuiImplWin32NewFrame();
        }

        public static void ImGuiImplWin32EnableDpiAwareness()
        {
            __Internal.ImGuiImplWin32EnableDpiAwareness();
        }

        public static float ImGuiImplWin32GetDpiScaleForHwnd(__IntPtr hwnd)
        {
            var __ret = __Internal.ImGuiImplWin32GetDpiScaleForHwnd(hwnd);
            return __ret;
        }

        public static float ImGuiImplWin32GetDpiScaleForMonitor(__IntPtr monitor)
        {
            var __ret = __Internal.ImGuiImplWin32GetDpiScaleForMonitor(monitor);
            return __ret;
        }

        public static void ImGuiImplWin32EnableAlphaCompositing(__IntPtr hwnd)
        {
            __Internal.ImGuiImplWin32EnableAlphaCompositing(hwnd);
        }

        public static bool ImGuiImplDX9Init(global::DearImguiSharp.IDirect3DDevice9 device)
        {
            var __arg0 = device is null ? __IntPtr.Zero : device.__Instance;
            var __ret = __Internal.ImGuiImplDX9Init(__arg0);
            return __ret;
        }

        public static void ImGuiImplDX9Shutdown()
        {
            __Internal.ImGuiImplDX9Shutdown();
        }

        public static void ImGuiImplDX9NewFrame()
        {
            __Internal.ImGuiImplDX9NewFrame();
        }

        public static void ImGuiImplDX9RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX9RenderDrawData(__arg0);
        }

        public static bool ImGuiImplDX9CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX9CreateDeviceObjects();
            return __ret;
        }

        public static void ImGuiImplDX9InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX9InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11Init(global::DearImguiSharp.ID3D11Device device, global::DearImguiSharp.ID3D11DeviceContext device_context)
        {
            var __arg0 = device is null ? __IntPtr.Zero : device.__Instance;
            var __arg1 = device_context is null ? __IntPtr.Zero : device_context.__Instance;
            var __ret = __Internal.ImGuiImplDX11Init(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiImplDX11Shutdown()
        {
            __Internal.ImGuiImplDX11Shutdown();
        }

        public static void ImGuiImplDX11NewFrame()
        {
            __Internal.ImGuiImplDX11NewFrame();
        }

        public static void ImGuiImplDX11RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplDX11RenderDrawData(__arg0);
        }

        public static void ImGuiImplDX11InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX11InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX11CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX11CreateDeviceObjects();
            return __ret;
        }

        public static bool ImGuiImplDX12Init(global::DearImguiSharp.ID3D12Device device, int num_frames_in_flight, global::DearImguiSharp.DXGI_FORMAT rtv_format, global::DearImguiSharp.ID3D12DescriptorHeap cbv_srv_heap, IntPtr font_srv_cpu_desc_handle, long font_srv_gpu_desc_handle)
        {
            var __arg0 = device is null ? __IntPtr.Zero : device.__Instance;
            var __arg3 = cbv_srv_heap is null ? __IntPtr.Zero : cbv_srv_heap.__Instance;
            var __ret = __Internal.ImGuiImplDX12Init(__arg0, num_frames_in_flight, rtv_format, __arg3, font_srv_cpu_desc_handle, font_srv_gpu_desc_handle);
            return __ret;
        }

        public static void ImGuiImplDX12Shutdown()
        {
            __Internal.ImGuiImplDX12Shutdown();
        }

        public static void ImGuiImplDX12NewFrame()
        {
            __Internal.ImGuiImplDX12NewFrame();
        }

        public static void ImGuiImplDX12RenderDrawData(global::DearImguiSharp.ImDrawData draw_data, global::DearImguiSharp.ID3D12GraphicsCommandList graphics_command_list)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            var __arg1 = graphics_command_list is null ? __IntPtr.Zero : graphics_command_list.__Instance;
            __Internal.ImGuiImplDX12RenderDrawData(__arg0, __arg1);
        }

        public static void ImGuiImplDX12InvalidateDeviceObjects()
        {
            __Internal.ImGuiImplDX12InvalidateDeviceObjects();
        }

        public static bool ImGuiImplDX12CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplDX12CreateDeviceObjects();
            return __ret;
        }

        public static bool ImGuiImplVulkanInit(global::DearImguiSharp.ImGuiImplVulkanInitInfo info, global::DearImguiSharp.VkRenderPassT render_pass)
        {
            var __arg0 = info is null ? __IntPtr.Zero : info.__Instance;
            var __arg1 = render_pass is null ? __IntPtr.Zero : render_pass.__Instance;
            var __ret = __Internal.ImGuiImplVulkanInit(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiImplVulkanShutdown()
        {
            __Internal.ImGuiImplVulkanShutdown();
        }

        public static void ImGuiImplVulkanNewFrame()
        {
            __Internal.ImGuiImplVulkanNewFrame();
        }

        public static void ImGuiImplVulkanRenderDrawData(global::DearImguiSharp.ImDrawData draw_data, global::DearImguiSharp.VkCommandBufferT command_buffer, global::DearImguiSharp.VkPipelineT pipeline)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            var __arg1 = command_buffer is null ? __IntPtr.Zero : command_buffer.__Instance;
            var __arg2 = pipeline is null ? __IntPtr.Zero : pipeline.__Instance;
            __Internal.ImGuiImplVulkanRenderDrawData(__arg0, __arg1, __arg2);
        }

        public static bool ImGuiImplVulkanCreateFontsTexture(global::DearImguiSharp.VkCommandBufferT command_buffer)
        {
            var __arg0 = command_buffer is null ? __IntPtr.Zero : command_buffer.__Instance;
            var __ret = __Internal.ImGuiImplVulkanCreateFontsTexture(__arg0);
            return __ret;
        }

        public static void ImGuiImplVulkanDestroyFontUploadObjects()
        {
            __Internal.ImGuiImplVulkanDestroyFontUploadObjects();
        }

        public static void ImGuiImplVulkanSetMinImageCount(uint min_image_count)
        {
            __Internal.ImGuiImplVulkanSetMinImageCount(min_image_count);
        }

        public static global::DearImguiSharp.VkDescriptorSetT ImGuiImplVulkanAddTexture(global::DearImguiSharp.VkSamplerT sampler, global::DearImguiSharp.VkImageViewT image_view, global::DearImguiSharp.VkImageLayout image_layout)
        {
            var __arg0 = sampler is null ? __IntPtr.Zero : sampler.__Instance;
            var __arg1 = image_view is null ? __IntPtr.Zero : image_view.__Instance;
            var __ret = __Internal.ImGuiImplVulkanAddTexture(__arg0, __arg1, image_layout);
            var __result0 = global::DearImguiSharp.VkDescriptorSetT.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        public static bool ImGuiImplVulkanLoadFunctions(global::DearImguiSharp.Delegates.Func_DearImguiSharp_PFN_vkVoidFunction_string8___IntPtr loader_func, __IntPtr user_data)
        {
            var __arg0 = loader_func == null ? global::System.IntPtr.Zero : Marshal.GetFunctionPointerForDelegate(loader_func);
            var __ret = __Internal.ImGuiImplVulkanLoadFunctions(__arg0, user_data);
            return __ret;
        }

        public static void ImGuiImplVulkanH_CreateOrResizeWindow(global::DearImguiSharp.VkInstanceT instance, global::DearImguiSharp.VkPhysicalDeviceT physical_device, global::DearImguiSharp.VkDeviceT device, global::DearImguiSharp.ImGuiImplVulkanH_Window wnd, uint queue_family, global::DearImguiSharp.VkAllocationCallbacks allocator, int w, int h, uint min_image_count)
        {
            var __arg0 = instance is null ? __IntPtr.Zero : instance.__Instance;
            var __arg1 = physical_device is null ? __IntPtr.Zero : physical_device.__Instance;
            var __arg2 = device is null ? __IntPtr.Zero : device.__Instance;
            var __arg3 = wnd is null ? __IntPtr.Zero : wnd.__Instance;
            var __arg5 = allocator is null ? __IntPtr.Zero : allocator.__Instance;
            __Internal.ImGuiImplVulkanH_CreateOrResizeWindow(__arg0, __arg1, __arg2, __arg3, queue_family, __arg5, w, h, min_image_count);
        }

        public static void ImGuiImplVulkanH_DestroyWindow(global::DearImguiSharp.VkInstanceT instance, global::DearImguiSharp.VkDeviceT device, global::DearImguiSharp.ImGuiImplVulkanH_Window wnd, global::DearImguiSharp.VkAllocationCallbacks allocator)
        {
            var __arg0 = instance is null ? __IntPtr.Zero : instance.__Instance;
            var __arg1 = device is null ? __IntPtr.Zero : device.__Instance;
            var __arg2 = wnd is null ? __IntPtr.Zero : wnd.__Instance;
            var __arg3 = allocator is null ? __IntPtr.Zero : allocator.__Instance;
            __Internal.ImGuiImplVulkanH_DestroyWindow(__arg0, __arg1, __arg2, __arg3);
        }

        public static global::DearImguiSharp.VkSurfaceFormatKHR ImGuiImplVulkanH_SelectSurfaceFormat(global::DearImguiSharp.VkPhysicalDeviceT physical_device, global::DearImguiSharp.VkSurfaceKHR_T surface, ref global::DearImguiSharp.VkFormat request_formats, int request_formats_count, global::DearImguiSharp.VkColorSpaceKHR request_color_space)
        {
            var __arg0 = physical_device is null ? __IntPtr.Zero : physical_device.__Instance;
            var __arg1 = surface is null ? __IntPtr.Zero : surface.__Instance;
            fixed (global::DearImguiSharp.VkFormat* __request_formats2 = &request_formats)
            {
                var __arg2 = __request_formats2;
                var __ret = __Internal.ImGuiImplVulkanH_SelectSurfaceFormat(__arg0, __arg1, __arg2, request_formats_count, request_color_space);
                return global::DearImguiSharp.VkSurfaceFormatKHR.__CreateInstance(__ret);
            }
        }

        public static global::DearImguiSharp.VkPresentModeKHR ImGuiImplVulkanH_SelectPresentMode(global::DearImguiSharp.VkPhysicalDeviceT physical_device, global::DearImguiSharp.VkSurfaceKHR_T surface, ref global::DearImguiSharp.VkPresentModeKHR request_modes, int request_modes_count)
        {
            var __arg0 = physical_device is null ? __IntPtr.Zero : physical_device.__Instance;
            var __arg1 = surface is null ? __IntPtr.Zero : surface.__Instance;
            fixed (global::DearImguiSharp.VkPresentModeKHR* __request_modes2 = &request_modes)
            {
                var __arg2 = __request_modes2;
                var __ret = __Internal.ImGuiImplVulkanH_SelectPresentMode(__arg0, __arg1, __arg2, request_modes_count);
                return __ret;
            }
        }

        public static int ImGuiImplVulkanH_GetMinImageCountFromPresentMode(global::DearImguiSharp.VkPresentModeKHR present_mode)
        {
            var __ret = __Internal.ImGuiImplVulkanH_GetMinImageCountFromPresentMode(present_mode);
            return __ret;
        }

        public static bool ImGuiImplGlfwInitForOpenGL(global::DearImguiSharp.GLFWwindow window, bool install_callbacks)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplGlfwInitForOpenGL(__arg0, install_callbacks);
            return __ret;
        }

        public static bool ImGuiImplGlfwInitForVulkan(global::DearImguiSharp.GLFWwindow window, bool install_callbacks)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplGlfwInitForVulkan(__arg0, install_callbacks);
            return __ret;
        }

        public static bool ImGuiImplGlfwInitForOther(global::DearImguiSharp.GLFWwindow window, bool install_callbacks)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplGlfwInitForOther(__arg0, install_callbacks);
            return __ret;
        }

        public static void ImGuiImplGlfwShutdown()
        {
            __Internal.ImGuiImplGlfwShutdown();
        }

        public static void ImGuiImplGlfwNewFrame()
        {
            __Internal.ImGuiImplGlfwNewFrame();
        }

        public static void ImGuiImplGlfwInstallCallbacks(global::DearImguiSharp.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwInstallCallbacks(__arg0);
        }

        public static void ImGuiImplGlfwRestoreCallbacks(global::DearImguiSharp.GLFWwindow window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwRestoreCallbacks(__arg0);
        }

        public static void ImGuiImplGlfwWindowFocusCallback(global::DearImguiSharp.GLFWwindow window, int focused)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwWindowFocusCallback(__arg0, focused);
        }

        public static void ImGuiImplGlfwCursorEnterCallback(global::DearImguiSharp.GLFWwindow window, int entered)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwCursorEnterCallback(__arg0, entered);
        }

        public static void ImGuiImplGlfwCursorPosCallback(global::DearImguiSharp.GLFWwindow window, double x, double y)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwCursorPosCallback(__arg0, x, y);
        }

        public static void ImGuiImplGlfwMouseButtonCallback(global::DearImguiSharp.GLFWwindow window, int button, int action, int mods)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwMouseButtonCallback(__arg0, button, action, mods);
        }

        public static void ImGuiImplGlfwScrollCallback(global::DearImguiSharp.GLFWwindow window, double xoffset, double yoffset)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwScrollCallback(__arg0, xoffset, yoffset);
        }

        public static void ImGuiImplGlfwKeyCallback(global::DearImguiSharp.GLFWwindow window, int key, int scancode, int action, int mods)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwKeyCallback(__arg0, key, scancode, action, mods);
        }

        public static void ImGuiImplGlfwCharCallback(global::DearImguiSharp.GLFWwindow window, uint c)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            __Internal.ImGuiImplGlfwCharCallback(__arg0, c);
        }

        public static void ImGuiImplGlfwMonitorCallback(global::DearImguiSharp.GLFWmonitor monitor, int @event)
        {
            var __arg0 = monitor is null ? __IntPtr.Zero : monitor.__Instance;
            __Internal.ImGuiImplGlfwMonitorCallback(__arg0, @event);
        }

        public static bool ImGuiImplOpenGL3Init(string glsl_version)
        {
            var __ret = __Internal.ImGuiImplOpenGL3Init(glsl_version);
            return __ret;
        }

        public static void ImGuiImplOpenGL3Shutdown()
        {
            __Internal.ImGuiImplOpenGL3Shutdown();
        }

        public static void ImGuiImplOpenGL3NewFrame()
        {
            __Internal.ImGuiImplOpenGL3NewFrame();
        }

        public static void ImGuiImplOpenGL3RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplOpenGL3RenderDrawData(__arg0);
        }

        public static bool ImGuiImplOpenGL3CreateFontsTexture()
        {
            var __ret = __Internal.ImGuiImplOpenGL3CreateFontsTexture();
            return __ret;
        }

        public static void ImGuiImplOpenGL3DestroyFontsTexture()
        {
            __Internal.ImGuiImplOpenGL3DestroyFontsTexture();
        }

        public static bool ImGuiImplOpenGL3CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplOpenGL3CreateDeviceObjects();
            return __ret;
        }

        public static void ImGuiImplOpenGL3DestroyDeviceObjects()
        {
            __Internal.ImGuiImplOpenGL3DestroyDeviceObjects();
        }

        public static bool ImGuiImplOpenGL2Init()
        {
            var __ret = __Internal.ImGuiImplOpenGL2Init();
            return __ret;
        }

        public static void ImGuiImplOpenGL2Shutdown()
        {
            __Internal.ImGuiImplOpenGL2Shutdown();
        }

        public static void ImGuiImplOpenGL2NewFrame()
        {
            __Internal.ImGuiImplOpenGL2NewFrame();
        }

        public static void ImGuiImplOpenGL2RenderDrawData(global::DearImguiSharp.ImDrawData draw_data)
        {
            var __arg0 = draw_data is null ? __IntPtr.Zero : draw_data.__Instance;
            __Internal.ImGuiImplOpenGL2RenderDrawData(__arg0);
        }

        public static bool ImGuiImplOpenGL2CreateFontsTexture()
        {
            var __ret = __Internal.ImGuiImplOpenGL2CreateFontsTexture();
            return __ret;
        }

        public static void ImGuiImplOpenGL2DestroyFontsTexture()
        {
            __Internal.ImGuiImplOpenGL2DestroyFontsTexture();
        }

        public static bool ImGuiImplOpenGL2CreateDeviceObjects()
        {
            var __ret = __Internal.ImGuiImplOpenGL2CreateDeviceObjects();
            return __ret;
        }

        public static void ImGuiImplOpenGL2DestroyDeviceObjects()
        {
            __Internal.ImGuiImplOpenGL2DestroyDeviceObjects();
        }

        public static bool ImGuiImplSDL2InitForOpenGL(global::DearImguiSharp.SDL_Window window, __IntPtr sdl_gl_context)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplSDL2InitForOpenGL(__arg0, sdl_gl_context);
            return __ret;
        }

        public static bool ImGuiImplSDL2InitForVulkan(global::DearImguiSharp.SDL_Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplSDL2InitForVulkan(__arg0);
            return __ret;
        }

        public static bool ImGuiImplSDL2InitForD3D(global::DearImguiSharp.SDL_Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplSDL2InitForD3D(__arg0);
            return __ret;
        }

        public static bool ImGuiImplSDL2InitForMetal(global::DearImguiSharp.SDL_Window window)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __ret = __Internal.ImGuiImplSDL2InitForMetal(__arg0);
            return __ret;
        }

        public static bool ImGuiImplSDL2InitForSDLRenderer(global::DearImguiSharp.SDL_Window window, global::DearImguiSharp.SDL_Renderer renderer)
        {
            var __arg0 = window is null ? __IntPtr.Zero : window.__Instance;
            var __arg1 = renderer is null ? __IntPtr.Zero : renderer.__Instance;
            var __ret = __Internal.ImGuiImplSDL2InitForSDLRenderer(__arg0, __arg1);
            return __ret;
        }

        public static void ImGuiImplSDL2Shutdown()
        {
            __Internal.ImGuiImplSDL2Shutdown();
        }

        public static void ImGuiImplSDL2NewFrame()
        {
            __Internal.ImGuiImplSDL2NewFrame();
        }

        public static bool ImGuiImplSDL2ProcessEvent(global::DearImguiSharp.SDL_Event @event)
        {
            var __arg0 = @event is null ? __IntPtr.Zero : @event.__Instance;
            var __ret = __Internal.ImGuiImplSDL2ProcessEvent(__arg0);
            return __ret;
        }
    }

    public enum DXGI_FORMAT
    {
        DXGI_FORMAT_UNKNOWN = 0,
        DXGI_FORMAT_R32G32B32A32TYPELESS = 1,
        DXGI_FORMAT_R32G32B32A32FLOAT = 2,
        DXGI_FORMAT_R32G32B32A32UINT = 3,
        DXGI_FORMAT_R32G32B32A32SINT = 4,
        DXGI_FORMAT_R32G32B32TYPELESS = 5,
        DXGI_FORMAT_R32G32B32FLOAT = 6,
        DXGI_FORMAT_R32G32B32UINT = 7,
        DXGI_FORMAT_R32G32B32SINT = 8,
        DXGI_FORMAT_R16G16B16A16TYPELESS = 9,
        DXGI_FORMAT_R16G16B16A16FLOAT = 10,
        DXGI_FORMAT_R16G16B16A16UNORM = 11,
        DXGI_FORMAT_R16G16B16A16UINT = 12,
        DXGI_FORMAT_R16G16B16A16SNORM = 13,
        DXGI_FORMAT_R16G16B16A16SINT = 14,
        DXGI_FORMAT_R32G32TYPELESS = 15,
        DXGI_FORMAT_R32G32FLOAT = 16,
        DXGI_FORMAT_R32G32UINT = 17,
        DXGI_FORMAT_R32G32SINT = 18,
        DXGI_FORMAT_R32G8X24TYPELESS = 19,
        DXGI_FORMAT_D32FLOAT_S8X24UINT = 20,
        DXGI_FORMAT_R32FLOAT_X8X24TYPELESS = 21,
        DXGI_FORMAT_X32TYPELESS_G8X24UINT = 22,
        DXGI_FORMAT_R10G10B10A2TYPELESS = 23,
        DXGI_FORMAT_R10G10B10A2UNORM = 24,
        DXGI_FORMAT_R10G10B10A2UINT = 25,
        DXGI_FORMAT_R11G11B10FLOAT = 26,
        DXGI_FORMAT_R8G8B8A8TYPELESS = 27,
        DXGI_FORMAT_R8G8B8A8UNORM = 28,
        DXGI_FORMAT_R8G8B8A8UNORM_SRGB = 29,
        DXGI_FORMAT_R8G8B8A8UINT = 30,
        DXGI_FORMAT_R8G8B8A8SNORM = 31,
        DXGI_FORMAT_R8G8B8A8SINT = 32,
        DXGI_FORMAT_R16G16TYPELESS = 33,
        DXGI_FORMAT_R16G16FLOAT = 34,
        DXGI_FORMAT_R16G16UNORM = 35,
        DXGI_FORMAT_R16G16UINT = 36,
        DXGI_FORMAT_R16G16SNORM = 37,
        DXGI_FORMAT_R16G16SINT = 38,
        DXGI_FORMAT_R32TYPELESS = 39,
        DXGI_FORMAT_D32FLOAT = 40,
        DXGI_FORMAT_R32FLOAT = 41,
        DXGI_FORMAT_R32UINT = 42,
        DXGI_FORMAT_R32SINT = 43,
        DXGI_FORMAT_R24G8TYPELESS = 44,
        DXGI_FORMAT_D24UNORM_S8UINT = 45,
        DXGI_FORMAT_R24UNORM_X8TYPELESS = 46,
        DXGI_FORMAT_X24TYPELESS_G8UINT = 47,
        DXGI_FORMAT_R8G8TYPELESS = 48,
        DXGI_FORMAT_R8G8UNORM = 49,
        DXGI_FORMAT_R8G8UINT = 50,
        DXGI_FORMAT_R8G8SNORM = 51,
        DXGI_FORMAT_R8G8SINT = 52,
        DXGI_FORMAT_R16TYPELESS = 53,
        DXGI_FORMAT_R16FLOAT = 54,
        DXGI_FORMAT_D16UNORM = 55,
        DXGI_FORMAT_R16UNORM = 56,
        DXGI_FORMAT_R16UINT = 57,
        DXGI_FORMAT_R16SNORM = 58,
        DXGI_FORMAT_R16SINT = 59,
        DXGI_FORMAT_R8TYPELESS = 60,
        DXGI_FORMAT_R8UNORM = 61,
        DXGI_FORMAT_R8UINT = 62,
        DXGI_FORMAT_R8SNORM = 63,
        DXGI_FORMAT_R8SINT = 64,
        DXGI_FORMAT_A8UNORM = 65,
        DXGI_FORMAT_R1UNORM = 66,
        DXGI_FORMAT_R9G9B9E5SHAREDEXP = 67,
        DXGI_FORMAT_R8G8B8G8UNORM = 68,
        DXGI_FORMAT_G8R8G8B8UNORM = 69,
        DXGI_FORMAT_BC1TYPELESS = 70,
        DXGI_FORMAT_BC1UNORM = 71,
        DXGI_FORMAT_BC1UNORM_SRGB = 72,
        DXGI_FORMAT_BC2TYPELESS = 73,
        DXGI_FORMAT_BC2UNORM = 74,
        DXGI_FORMAT_BC2UNORM_SRGB = 75,
        DXGI_FORMAT_BC3TYPELESS = 76,
        DXGI_FORMAT_BC3UNORM = 77,
        DXGI_FORMAT_BC3UNORM_SRGB = 78,
        DXGI_FORMAT_BC4TYPELESS = 79,
        DXGI_FORMAT_BC4UNORM = 80,
        DXGI_FORMAT_BC4SNORM = 81,
        DXGI_FORMAT_BC5TYPELESS = 82,
        DXGI_FORMAT_BC5UNORM = 83,
        DXGI_FORMAT_BC5SNORM = 84,
        DXGI_FORMAT_B5G6R5UNORM = 85,
        DXGI_FORMAT_B5G5R5A1UNORM = 86,
        DXGI_FORMAT_B8G8R8A8UNORM = 87,
        DXGI_FORMAT_B8G8R8X8UNORM = 88,
        DXGI_FORMAT_R10G10B10XR_BIAS_A2UNORM = 89,
        DXGI_FORMAT_B8G8R8A8TYPELESS = 90,
        DXGI_FORMAT_B8G8R8A8UNORM_SRGB = 91,
        DXGI_FORMAT_B8G8R8X8TYPELESS = 92,
        DXGI_FORMAT_B8G8R8X8UNORM_SRGB = 93,
        DXGI_FORMAT_BC6H_TYPELESS = 94,
        DXGI_FORMAT_BC6H_UF16 = 95,
        DXGI_FORMAT_BC6H_SF16 = 96,
        DXGI_FORMAT_BC7TYPELESS = 97,
        DXGI_FORMAT_BC7UNORM = 98,
        DXGI_FORMAT_BC7UNORM_SRGB = 99,
        DXGI_FORMAT_AYUV = 100,
        DXGI_FORMAT_Y410 = 101,
        DXGI_FORMAT_Y416 = 102,
        DXGI_FORMAT_NV12 = 103,
        DXGI_FORMAT_P010 = 104,
        DXGI_FORMAT_P016 = 105,
        DXGI_FORMAT_420OPAQUE = 106,
        DXGI_FORMAT_YUY2 = 107,
        DXGI_FORMAT_Y210 = 108,
        DXGI_FORMAT_Y216 = 109,
        DXGI_FORMAT_NV11 = 110,
        DXGI_FORMAT_AI44 = 111,
        DXGI_FORMAT_IA44 = 112,
        DXGI_FORMAT_P8 = 113,
        DXGI_FORMAT_A8P8 = 114,
        DXGI_FORMAT_B4G4R4A4UNORM = 115,
        DXGI_FORMAT_P208 = 130,
        DXGI_FORMAT_V208 = 131,
        DXGI_FORMAT_V408 = 132,
        DXGI_FORMAT_SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 133,
        DXGI_FORMAT_SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 134,
        DXGI_FORMAT_FORCE_UINT = -1
    }

    namespace Delegates
    {
        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr(__IntPtr atlas);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr(__IntPtr user_data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_string8(__IntPtr user_data, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr(__IntPtr viewport, __IntPtr data);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_DearImguiSharp_ImVec2___Internal(__IntPtr vp, global::DearImguiSharp.ImVec2.__Internal pos);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::DearImguiSharp.ImVec2.__Internal Func_DearImguiSharp_ImVec2___Internal___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr_float(__IntPtr vp, float alpha);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr(__IntPtr vp);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr_ulong___IntPtr_ulongPtr(__IntPtr vp, ulong vk_inst, __IntPtr vk_allocators, ulong* out_vk_surface);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate __IntPtr Func___IntPtr___IntPtr___IntPtr_string8(__IntPtr ctx, __IntPtr handler, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string name);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr___IntPtr_string8(__IntPtr ctx, __IntPtr handler, __IntPtr entry, [MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string line);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action___IntPtr___IntPtr___IntPtr(__IntPtr ctx, __IntPtr handler, __IntPtr out_buf);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        [return: MarshalAs(UnmanagedType.I1)]
        public unsafe delegate bool Func_bool___IntPtr_int_sbytePtrPtr(__IntPtr data, int idx, sbyte** out_text);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate float Func_float___IntPtr_int(__IntPtr data, int idx);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate int Func_int___IntPtr___IntPtr(__IntPtr __0, __IntPtr __1);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate void Action_DearImguiSharp_VkResult(global::DearImguiSharp.VkResult err);

        [SuppressUnmanagedCodeSecurity, UnmanagedFunctionPointer(__CallingConvention.Cdecl)]
        public unsafe delegate global::DearImguiSharp.PFN_vkVoidFunction Func_DearImguiSharp_PFN_vkVoidFunction_string8___IntPtr([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string function_name, __IntPtr user_data);
    }
}
